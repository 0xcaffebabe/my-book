{"content":"# 集成\n\n## 理想的集成技术\n\n- 避免破坏性修改\n  - 一个服务的修改会导致服务的消费方也发生变化\n- 保证API的技术无关性\n  - 也就说，API不管使用什么技术，应该都能实现，保证通信方式的技术无关性是非常重要的，这样各个服务才有可能使用不同的技术实现\n- 使服务易于消费方使用\n- 隐藏内部实现细节\n  - 如果消费方与服务的实现细节绑定在一起，会增加两者间的耦合\n\n## 通信\n\n### 交互方式\n\n- 一对一与一对多\n- 同步与异步\n\n模式   | 一对一          | 一对多\n---- | ------------ | -------------\n同步模式 | 请求/响应        | 无\n异步模式 | 异步请求/响应 单向通知 | 发布/订阅 发布/异步响应\n\n#### 同步还是异步\n\n同步通信，发起一个远程调用后，会阻塞自己并等待整个操作的完成\n\n异步通信，则不需要等待操作结束就可以访问\n\n使用哪种方式，要取决于哪种风格的通信解决的问题\n\n### API定义\n\n如何定义API取决于进程间通信机制。\n\n随着应用演进，API也会随着演进。\n\n- 次要且向后兼容的演进：增加可选属性、添加新操作等\n- 主要且不向后兼容的演进：此时可以引入版本号\n\n### 消息格式\n\n- 基于文本消息格式：xml、json。好处在于可读性高、自描述。缺点在于消息过度冗长。\n- 二进制消息格式：protocol buffers、avro。编译器根据定义的IDL生成序列化与反序列代码。好处性能高。\n\n## 跨服务业务流程\n\n有两种方式：编排与协同\n\n编排是有一个控制中心，指导其他服务应该做些什么，具体怎么做，则交给具体服务\n\n```\n事件发生：\n    控制中心调用服务A\n    控制中心调用服务B\n```\n\n使用这种方式的缺点是会让控制中心承担太多的职责，并会导致少量的“上帝服务（上帝视角）”\n\n若使用协同，则是可以客户触发一个事件，监听到这个事件的具体服务去做一些事情\n\n```\n事件发生：\n    服务A接收到事件，做一些事\n    服务B接收到事件，做一些事\n```\n\n这个方式的优点是能显著地消除耦合，但是缺点是无法看到清晰的业务流程，所以这种方式需要一定的监控手段来保证业务的正确性\n\n### 断路器模式处理局部故障\n\n服务保护自己的方式：\n\n- 网络超时：对某个服务的超时不能无限\n- 限制客户端的请求数量\n- 断路器模式\n\n### 服务发现\n\n- 应用层：服务直接与服务注册表交互\n\n![屏幕截图 2021-01-19 112903](/assets/屏幕截图%202021-01-19%20112903.png)\n\n好处在于可以处理多平台部署问题，弊端则是需要为每种编程语言提供一个SDK。\n\n- 平台层：使用基础设施来实现服务发现\n\n![屏幕截图 2021-01-19 112958](/assets/屏幕截图%202021-01-19%20112958.png)\n\n## 同步的编排方式\n\n![屏幕截图 2021-01-19 105517](/assets/屏幕截图%202021-01-19%20105517.png)\n\n### 远程过程调用（RPC）\n\n>在分布式计算，远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）\n\n#### 一些问题\n\n- 技术耦合\n  - 如果使用JAVA RMI，就会将服务端与客户端都绑定在JVM上\n- 远程调用的开销\n  - 网络是不可靠的\n- 脆弱\n  - 一端的修改很容易影响到另外一端\n\n### REST\n\nREST是RPC的一种替代方案\n\n#### REST成熟度模型\n\n- 0：每个请求都指明了需要执行的操作和必要的参数\n- 1：引入了资源的概念，对资源进行操作\n- 2：使用HTTP动词来执行操作\n- 3：基于HAEOAS，超文本驱动，客户端无需硬编码REST链接。让客户端自行遍历与发现API，可以很好地隐藏低层细节，使得客户端与服务端之间实现了松耦合\n\n#### REST与HTTP\n\nREST本身没有定义应该使用哪种协议实现，但是使用HTTP协议，会简单的很多\n\n#### 载体形式\n\n- JSON\n- XML\n\n#### 过多的约定\n\n数据持久化继承并非是一件需要过早操心的事，最好是先设计外部接口，这样可以确保服务的接口是由消费者的需求驱动出来的\n\n#### 缺点\n\n基于HTTP的REST有一些缺点：\n\n- 时延不低\n- 数据包不够精简\n- 需要手动编写客户端代码\n- 有些框架HTTP动词支持不好\n\n### gRPC\n\n```c\nservice UserService {\n  rpc createUser(CreateUserRequest) returns(CreateUserReply) {}\n}\n...\n```\n\n- 高效紧凑\n- 支持双向流式\n\n## 异步的协作方式\n\n同步消息会降低可用性，为消除同步交互，可：\n\n- 使用消息代理来进行异步交互\n- 复制数据来避免与其他服务同步交互\n\n异步协作的两种架构：\n\n- 消息代理：需要一些中间件来实现异步协作，尽量让中间件保持简单\n  - 耦合低\n  - 更为灵活\n  - **额外的复杂性**\n- 无代理架构：直接向服务发送消息\n  - 性能较高\n  - 复杂性较低\n  - **耦合过紧**\n\n![屏幕截图 2021-01-19 142008](/assets/屏幕截图%202021-01-19%20142008.png)\n![屏幕截图 2021-01-19 142721](/assets/屏幕截图%202021-01-19%20142721.png)\n\n可实现的交互方式：\n\n- 请求/响应模型\n- 单向通知\n- 发布订阅\n- 发布/响应\n\n### API规范\n\n![屏幕截图 2021-01-19 142500](/assets/屏幕截图%202021-01-19%20142500.png)\n\n异步操作：\n\n- 请求/异步响应API\n- 单向通知API\n\n记录事件发布API\n\n### 技术选择\n\n- MQ\n- 基于HTTP的发布订阅模式\n\n### 异步架构复杂性\n\n采用异步架构，要考虑的事情就更多了\n\n- 并发与消息顺序\n  - 在kafka中，使用了分片来解决顺序\n- 重复消息\n  - 应用程序需要自己进行幂等处理\n- 事务性消息\n  - 消息队列表与分布式事务\n\n### 服务即状态机\n\n服务拥有在限界上下文中的所有逻辑，这样可以在唯一一个地方处理逻辑\n\n### 响应式扩展\n\n把多个调用的结果组装起来，并在此上做操作（类似于stream）\n\n### 微服务中代码复用的危险\n\n不同的服务复用同一块代码，一个服务修改的代码很可能影响另一个服务\n\n### 按引用访问\n\n在进行事件通知时，传递的数据应该是指向资源的一个引用，这样当其他服务处理这个事件时，就可以根据这个引用得到最新的数据，而避免数据不一致的情况\n\n### 版本管理\n\n- 尽可能推迟修改\n\n**宽进严出原则：对自己发送的东西要严格，对接收的东西可以宽容一点**\n\n- 及早发现破坏性修改\n\n- 使用语义化的版本管理\n  - 通过版本号来告知消费方功能增加或是否向后兼容\n- 多版本接口共存\n- 多版本服务共存\n\n### 用户界面\n\n- 数字化\n  - 未来的需求很难预测，提供细粒度的API\n- 不同场景的约束\n- API的组合\n  - 使用网关来缓解客户端与服务之间的过多交互\n- 服务直接提供UI片段\n\n### 为前端服务的后端\n\n再在服务之上封装一个API提供粗粒度的接口，这些接口通过调用下层的服务来提供服务\n\n但是这层API很容易发展为一个怪兽，并且可能会有业务逻辑混入其中\n\n### 集成第三方软件\n\n一些风险：\n\n- 缺乏控制\n\n\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}