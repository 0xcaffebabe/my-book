{"content":"# 服务网关\n\nAPI网关统一服务入口，可方便实现对平台众多服务接口进行管控，对访问服务的身份认证、防报文重放与防数据篡改、功能调用的业务鉴权、响应数据的脱敏、流量与并发控制，甚至基于API调用的计量或者计费等等\n\n## 网关分类\n\n- 开放api\n- 服务网关\n\n## 接口设计\n\n接口权限(开放接口|内部接口)、考虑幂等性、安全性(Https )防止篡改数据(验证签名)、使用网关拦截\n接口实现黑名单和白名单、接口使用http协议+json格式restful 目的为了跨平台。\n考虑高并发对接口服务实现保护服务降级、熔断、隔离之类，最后使用统一API管理平台api swagger \n\n## 应用场景\n\n- 黑白名单\n- 日志\n- 协议适配\n- 身份认证\n- 计流限流\n- 路由\n\n## 网关部署架构\n\n![202002221510](/assets/202002221510.png)\n\n- nginx面向服务器\n- 网关面向服务\n\n## Spring Cloud Zuul\n\n![202037144831](/assets/202037144831.png)\n\n### zuul与nginx\n\n- Nginx是采用服务器负载均衡进行转发\n- Zuul依赖Ribbon和eureka实现本地负载均衡转发\n\nNginx功能比Zuul功能更加强大，能够整合其他语言比如lua脚本实现强大的功能，同时Nginx可以更好的抗高并发，Zuul网关适用于请求过滤和拦截\n\n### 使用\n\n- 添加依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-zuul</artifactId>\n</dependency>\n```\n\n- 配置\n\n```properties\nserver.port=8010\nspring.application.name=gateway\n\n# 这里的配置表示，访问/bd/** 直接重定向到http://baidu.com/**\nzuul.routes.baidu.path=/bd/**\nzuul.routes.baidu.url=http://baidu.com/\n\neureka.client.serviceUrl.defaultZone=http://localhost:8001/eureka/\n```\n```java\n@EnableZuulProxy\n```\n\n### 默认路由规则\n\n<http://ZUUL_HOST:ZUUL_PORT/微服务在Eureka上的serviceId/**>\n\n比如访问<http://localhost:8010/producer/>\n\n则gateway就会把请求转发到producer服务上面去\n\n### 简化路由配置\n\n```yml\nzuul:\n  routes:\n    user-service: /user-service/** # 这里是映射路径\n```\n\n### Zuul的核心\n\n- Fliter\n\n  ![](http://favorites.ren/assets/images/2018/springcloud/zuul-core.png)\n- 场景\n  - 请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了\n  - 异常处理：一般会在error类型和post类型过滤器中结合来处理。\n  - 服务调用时长统计\n\n### 自定义Filter\n\n- 实现ZuulFilter\n\n```java\n@Component\npublic class MyFilter extends ZuulFilter {\n\n    @Override\n    public String filterType() {return FilterConstants.PRE_TYPE;}\n\n    @Override\n    public int filterOrder() {return FilterConstants.PRE_DECORATION_FILTER_ORDER;}\n\n    @Override\n    public boolean shouldFilter() {return true;}\n\n    @Override\n    public Object run() throws ZuulException {\n\n        RequestContext ctx = RequestContext.getCurrentContext();\n        HttpServletRequest request = ctx.getRequest();\n\n        String token = request.getParameter(\"token\");\n        if (\"my\".equals(token)){\n            ctx.setSendZuulResponse(true);\n            ctx.setResponseStatusCode(200);\n            ctx.set(\"isSuccess\",true);\n        }else{\n            ctx.setSendZuulResponse(false);\n            ctx.setResponseStatusCode(400);\n            ctx.setResponseBody(\"error token\");\n            ctx.set(\"isSuccess\",false);\n\n        }\n        return null;\n    }\n}\n```\n\n这样当通过网关访问服务时，不符合条件的请求将会被过滤掉\n\n### 整合配置中心\n\n- 依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-config</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n- 手动配置zuul配置对象\n\n```java\n@RefreshScope\n@ConfigurationProperties(\"zuul\")\npublic ZuulProperties zuulProperties() {\n    return new ZuulProperties();\n}\n```\n\n### 进行跨域配置\n\n```java\n@Configuration\npublic class CorsConfig {\n    @Bean\n    public CorsFilter corsFilter() {\n        final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n        final CorsConfiguration config = new CorsConfiguration();\n        config.setAllowCredentials(true); // 允许cookies跨域\n        config.addAllowedOrigin(\"*\");// #允许向该服务器提交请求的URI，*表示全部允许，在SpringMVC中，如果设成*，会自动转成当前请求头中的Origin\n        config.addAllowedHeader(\"*\");// #允许访问的头信息,*表示全部\n        config.setMaxAge(18000L);// 预检请求的缓存时间（秒），即在这个时间段里，对于相同的跨域请求不会再预检了\n        config.addAllowedMethod(\"*\");// 允许提交请求的方法，*表示全部允许\n        source.registerCorsConfiguration(\"/**\", config);\n        return new CorsFilter(source);\n    }\n}\n```\n\n### 忽略\n\n```properties\n# 忽略该服务\nzuul.ignored-services: upload-servie \n```\n\n## 路由熔断\n\n- 自定义fallback\n\n```java\n@Component\npublic class MyFallback implements FallbackProvider {\n    @Override\n    public String getRoute() {\n        return \"producer\";\n    }\n\n    @Override\n    public ClientHttpResponse fallbackResponse(String route, Throwable cause) {\n\n        cause.printStackTrace();\n\n\n        return new ClientHttpResponse() {\n            @Override\n            public HttpStatus getStatusCode() throws IOException {\n                return HttpStatus.valueOf(500);\n            }\n\n            @Override\n            public int getRawStatusCode() throws IOException {\n                return 500;\n            }\n\n            @Override\n            public String getStatusText() throws IOException {\n                return \"SERVER ERROR\";\n            }\n\n            @Override\n            public void close() {\n\n            }\n\n            @Override\n            public InputStream getBody() throws IOException {\n                return new ByteArrayInputStream(\"service is unavailable\".getBytes());\n            }\n\n            @Override\n            public HttpHeaders getHeaders() {\n                HttpHeaders headers = new HttpHeaders();\n                headers.setContentType(MediaType.TEXT_PLAIN);\n                return headers;\n            }\n        };\n    }\n}\n```\n\n当producer挂掉时，将会返回相关信息\n\n## 路由重试\n\n- 添加依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.retry</groupId>\n    <artifactId>spring-retry</artifactId>\n</dependency>\n```\n\n- 配置\n\n```properties\n#是否开启重试功能\nzuul.retryable=true\n#对当前服务的重试次数\nribbon.MaxAutoRetries=2\n#切换相同Server的次数\nribbon.MaxAutoRetriesNextServer=0\n```\n\n当相同的服务挂掉一部分后，如果多次请求不成功，则接下来的请求则会转发到其他服务上\n\n> 也就是说,自动的寻找到正确响应的服务上去.错误的实例被抛弃\n\n## zuul高可用\n\n- 启动两个网关实例8000和7000\n- 配置nginx负载均衡\n\n```nginx\nupstream gateway {\n        server 127.0.0.1:8000;\n        server 127.0.0.1:7000;\n}\nserver {\n        listen 6060;\n        location / {\n                proxy_pass http://gateway;\n                proxy_connect_timeout 1s;\n                proxy_send_timeout 1s;\n                proxy_read_timeout 1s;\n        }\n}\n```\n\n## Spring Cloud Gateway\n\n- 路由\n- 断言\n- 过滤器\n\n![批注 2020-04-07 130836](/assets/批注%202020-04-07%20130836.png)\n\n## vs zuul\n\nZuuL网关属于Netflix公司开源框架，属于第一代微服务网关.\nGateWay属于SpringCloud自己研发的网关框架，属于第二代微服务网关.\n\ngateway不依赖servlet api，所以性能更强\ngateway的转发是在tcp层\n\n### 配置\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-gateway</artifactId>\n</dependency>\n```\n\n#### 定义路由规则\n\n```java\n@Bean\npublic RouteLocator customRouteLocator(RouteLocatorBuilder builder) {\n    return builder.routes()\n            .route(\"path_route\", r -> r.path(\"/hi\")\n                    .uri(\"http://localhost:8503\"))\n            .build();\n}\n```\n\n- 通过时间匹配\n\n```java\nbuilder.routes()\n       .route(\"path_route\", r -> r.before(ZonedDateTime.now())\n               .uri(\"http://localhost:8503\"))\n       .build();\n```\n\n- 通过Cookie匹配\n\n```java\nbuilder.routes()\n       .route(\"path_route\", r -> r.cookie(\"key\",\"value\")\n               .uri(\"http://localhost:8503\"))\n       .build();\n```\n\n- 通过header属性匹配\n- 通过Host匹配\n- 通过请求方式匹配\n- 通过请求路径匹配\n- 通过请求参数匹配\n- 通过请求IP匹配\n\n### 服务化\n\n- 依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n- 配置\n\n```yml\nserver:\n  port: 8888\nspring:\n  application:\n    name: gateway\n  cloud:\n    gateway:\n      discovery:\n        locator:\n          enabled: true\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8001/eureka/\nlogging:\n  level:\n    org.springframework.cloud.gateway: debug\n```\n\n- 默认转发规则\n\n<http://网关/服务serviceId/具体的url>\n\n### Filter\n\n- PRE\n\n> 这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等\n\n- POST\n\n> 这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的 HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等\n\n#### 简单过滤器实例\n\n- 配置\n\n```yml\nserver:\n  port: 8888\nspring:\n  application:\n    name: gateway\n  cloud:\n    gateway:\n      routes:\n      - id: add_request_parameter_route\n        uri: http://localhost:9003\n        filters:\n        - AddRequestParameter=name, my\n        predicates:\n          - Method=GET\n      discovery:\n        locator:\n          enabled: true\n\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8001/eureka/\nlogging:\n  level:\n    org.springframework.cloud.gateway: debug\n```\n\n在上面的配置中，添加了一个路由过滤规则：对9003端口的get请求添加一个请求参数name:my\n\n- 服务化配置\n\n改成`uri: lb://producer` 则路由配置只会对producer服务生效\n\n#### 修改路径的过滤器\n\n- StripPrefix Filter\n\n```yml\n- id: nameRoot\n  uri: lb://producer\n  predicates:\n    - Path=/name/**\n  filters:\n    - StripPrefix=2\n```\n\n如果访问/name/my/hello，网关就会将路径修改为/hello\n\n- PrefixPath Filter\n\n```yml\n- id: prefixpath_route\n  uri: lb://producer\n  predicates:\n  - Path=*\n  filters:\n  - PrefixPath=/mypath\n```\n\n自动给URL加上mypath前缀\n\n#### 自定义Filter\n\n```java\n@Component\npublic class TokenFilter implements GlobalFilter {\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        var token = exchange.getRequest().getQueryParams().get(\"token\");\n        if (!CollectionUtils.isEmpty(token)){\n            return chain.filter(exchange);\n        }\n        ServerHttpResponse response = exchange.getResponse();\n        response.setStatusCode(HttpStatus.FORBIDDEN);\n        return response.writeWith(\n                Mono.just(\n                        response.bufferFactory().wrap(\"token is null\".getBytes())\n                )\n        );\n    }\n}\n```\n\n#### 限速路由器\n\n#### 熔断路由器\n\n- 依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n```\n\n```yml\n- id: hystrix_route\n  uri: http://localhost:9001\n  predicates:\n    - Path=/*\n  filters:\n    - Hystrix=myCommandName\n```\n\n#### 重试路由器\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}