{"content":"# 注册中心\n\n- 服务治理\n\n如果服务与服务之间的依赖关系非常多的情况下，服务URL管理起起来非常复杂。在这时候可以使用服务治理技术，管理每个服务与服务之间的依赖关系.可以本地负载均衡、实现服务发现与注册、容错等。\n\n## 服务注册原理\n\n![批注 2020-07-03 083637](/assets/批注%202020-07-03%20083637.png)\n\n## Eureka\n\n> Eureka是Netflix开发的服务发现框架,Eureka包含两个组件： Eureka Server和Eureka Client.\n\n各个节点启动后，会在Eureka Server中进行注册，这样Eureka Server中的服务注册表中将会存储所有可用服务节点的信息\n\n在应用启动后，将会 向Eureka Server发送心跳,默认周期为30秒\n\n保证**AP**，eureka在设计时优先保证可用性，每一个节点都是平等的，一部分节点挂掉不会影响到正常节点的工作，不会出现类似zk的选举leader的过程\n\n![202034165552](/assets/202034165552.png)\n\n- 流程\n\n![批注 2020-07-03 085520](/assets/批注%202020-07-03%20085520.png)\n![批注 2020-07-03 085612](/assets/批注%202020-07-03%20085612.png)\n\n- 依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n```\n\n- 配置\n\n```properties\nspring.application.name=eureka-server\nserver.port=8001\n#是否将自己注册到注册中心\neureka.client.register-with-eureka=false\n#是否从注册中心获取注册信息\neureka.client.fetch-registry=false\neureka.client.serviceUrl.defaultZone=http://localhost:${server.port}/eureka/\n```\n\n```java\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaServerApplication.class, args);\n    }\n}\n```\n\n### 服务注册\n\n- 获取读锁\n- 在注册表查找instance info\n- 租约是否存在\n  - 不存在：创建新租约\n  - 存在：判断最后更新时间\n    - 如果更新时间比较大，则更新时间戳\n    - 设置上线时间\n\n### 服务续约\n\n```yml\neureka:\n  instance:\n    lease-expiration-duration-in-seconds: 10 # 10秒即过期\n    lease-renewal-interval-in-seconds: 5 # 5秒一次心跳\n```\n\n- 接收服务心跳\n\n![批注 2020-07-03 091553](/assets/批注%202020-07-03%20091553.png)\n\n### 失效剔除与自我保护\n\n- 失效剔除\n\n有些时候，我们的服务实例并不一定会正常下线，可能由于内存溢出、网络故障等原因使得服务不能正常工作，而服务注册中心并未收到“服务下线”的请求。为了从服务表中将这些无法提供服务的实例剔除，Eureka Server 在启动的时候会创建一个定时任多默认每隔一一段时间(默认为60秒)将当前清单中超时(默认为90秒)没有续约的服务除出去\n\n- 自我保护\n\n默认情况下,EurekaClient会定时向EurekaServer端发送心跳，如果EurekaServer在一定时间内没有收到EurekaClient发送的心跳，便会把该实例从注册服务列表中剔除（默认是90秒）,为了防止只是EurekaClient与EurekaServer之间的网络故障，在短时间内丢失大量的实例心跳，这时候EurekaServer会**开启自我保护机制，EurekaServer不会踢出这些服务**\n\n在开发中，由于会重复重启服务实例，所以经常会出现以下警告：\n\n```\nEMERGENCY!EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY'RE NOT.RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEGING EXPIRED JUST TO BE SAFE.\n```\n\n所以开发时需要关闭自我保护\n\n```yml\neureka:\n  server:\n    enable-self-preservation: false # 关闭自我保护模式（缺省为打开）\n    eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms）\n```\n\n### 服务下线\n\n- 是否有租约\n  - 没有租约下线失败\n  - 否则从注册表中移除\n  - 设置下线时间\n  - 添加下线记录\n\n### Eureka集群\n\nEureka 满足AP 牺牲了 C\n\n- 配置\n\n```properties\n# eureka1\nspring.application.name=spring-cloud-eureka\nserver.port=8001\neureka.client.serviceUrl.defaultZone=http://localhost:8002/eureka/\n```\n\n```properties\n# eureka2\nspring.application.name=spring-cloud-eureka\nserver.port=8002\neureka.client.serviceUrl.defaultZone=http://localhost:8001/eureka/\n```\n\n- 根据两个配置文件启动两个实例\n\n- 客户端配置\n\n```properties\neureka.client.service-url.defaultZone=http://localhost:8001/eureka,http://localhost:8002/eureka\n```\n\n#### 集群同步\n\n![2020739306](/assets/2020739306.png)\n\n## 注册中心Consul\n\n### 工作原理\n\n![](http://favorites.ren/assets/images/2018/springcloud/consol_service.png)\n\n### 安装\n\n```text\nhttps://www.consul.io/downloads.html\n```\n\n### 启动\n\n```shell\nconsul agent -dev\n```\n\n### 生产者配置\n\n- 依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n</dependency>\n```\n\n- 配置\n\n```properties\nspring.application.name=consul-producer\nserver.port=8503\nspring.cloud.consul.host=localhost\nspring.cloud.consul.port=8500\n#注册到consul的服务名称\nspring.cloud.consul.discovery.serviceName=producer\n```\n\n### 消费者\n\n- 依赖同生产者\n\n- 配置\n\n```properties\nspring.application.name=consul-consumer\nserver.port=8504\nspring.cloud.consul.host=127.0.0.1\nspring.cloud.consul.port=8500\n#设置不需要注册到 consul 中\nspring.cloud.consul.discovery.register=false\n```\n\n- 使用\n\n```java\n@RestController\npublic class ServiceController {\n\n    @Autowired\n    LoadBalancerClient loadBalancerClient;\n\n    @Autowired\n    DiscoveryClient discoveryClient;\n\n    // 获取相关服务实例\n    @RequestMapping(\"/services\")\n    public Object services(){\n        return discoveryClient.getInstances(\"producer\");\n    }\n\n    // 自动选择服务实例\n    @RequestMapping(\"/discover\")\n    public Object discover(){\n        return loadBalancerClient.choose(\"producer\").getUri().toString();\n    }\n\n    @RequestMapping(\"/hi\")\n    public String hi(){\n        ServiceInstance instance = loadBalancerClient.choose(\"producer\");\n\n        return new RestTemplate().getForObject(instance.getUri().toString()+\"/hi\",String.class);\n    }\n}\n```\n\n## 注册中心Zookeeper\n\nSpringCloud把Zookeeper作为注册中心\n\n保证**CP**，即任何时刻对zookeeper的访问请求能得到一致性的数据结果，同时系统对网络分割具备容错性，但是它不能保证每次服务的可用性\n\n- 启动zk\n- 服务依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>\n</dependency>\n```\n- 服务配置\n\n```properties\nserver.port=8101\nspring.application.name=zk-producer\nspring.cloud.zookeeper.connect-string=127.0.0.1:2181\n```\n\n```java\n@EnableDiscoveryClient\n```","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}