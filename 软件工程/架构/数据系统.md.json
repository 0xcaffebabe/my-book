{"content":"# 数据系统\n\n- 在线系统：服务等待客户的请求或指令到达。每收到一个，服务会试图尽快处理它，并发回一个响应\n- 批处理系统：大量的输入数据，跑一个作业（job）来处理它，并生成一些输出数据\n- 流处理系统：像批处理系统一样，流处理消费输入并产生输出（并不需要响应请求）。但是，流式作业在事件发生后不久就会对事件进行操作\n\n## 基石\n\n### 可靠性\n\n造成错误的原因叫做故障（fault），预料并应对故障的系统特性可称为容错（fault-tolerant）。\n\n故障（fault）不同于失效（failure），故障定义的是系统偏离正常状态，失效则是整个系统不能对用户提供服务\n\n### 可伸缩性\n\n可伸缩性（Scalability） 是用来描述系统应对负载增长能力的术语\n\n负载可以用一些称为 负载参数（load parameters） 的数字来描述,如每秒请求数、读写请求比率等等。\n\n为了描述性能，单个请求的响应参数是没有太多参考参考价值的，需要通过一个可测量的数值分布来描述：\n\n![202131141817](/assets/202131141817.png)\n\n为了明确大多数用户的指标，中位数是最有价值的。\n\n为了应对负载，可以进行垂直扩展或者水平扩展。没有一种银弹可以解决所有的应对负载需求，一个良好适配应用的可扩展架构，是围绕着假设（assumption）建立的，这就是所谓负载参数。\n\n### 可维护性\n\n可操作性：降低运维复杂度。\n\n简单性：通过封装降低复杂度。\n\n可演化性：简单易懂的系统通常比复杂系统更容易修改。\n\n### 数据模型\n\n不同的数据模型是为不同的应用场景而设计的。选择适合应用程序的数据模型非常重要。\n\n应用层有各种领域概念，存储层则有JSON、XML或关系模型，数据库层则有以内存或字节来表示JSON、XML等，最底层使用电流或者脉冲来表示字节。\n\n关系模型已经持续称霸了大约25~30年，2010年新起的NoSQL文档模型在最近一段时间内也慢慢与关系模型配合使用，随着时间的推移，关系数据库和文档数据库似乎变得越来越相似。\n\n当前的文档模型和上世纪70年代的层次模型很像，一对多很容易支持，但多对多就抓瞎了，文档模型会不会重蹈层次模型的覆辙。\n\n文档模型拥有较关系模型强的架构灵活性，因为我们对数据的解释是发生在我们的代码之中，这意味着一旦数据模型发生改变，修改代码就好了。\n\n同时文档模型拥有数据局部性优势，但这只对同时需要同一文档里的大部分数据时下的场景有效。\n\n### 查询语言\n\n相较于命令式查询，声明式查询更适合并行。\n\n对于声明式查询语言来说，在编写查询语句时，不需要指定执行细节：查询优化程序会自动选择预测效率最高的策略\n\n### 存储与查询\n\n许多数据库在内部使用了日志（log），也就是一个 仅追加（append-only） 的数据文件，这种方式对于写入的性能非常好，但读取性能很差，于是引入了索引。\n\n索引是数据库维护的一个主数据的附加结构，根据这个附加结构可以提升查询速度，但会对写入速度造成影响。\n\n- 哈希索引\n\n这种索引要求全部的索引要能放入内存，这会导致许多问题，同时哈希索引也无法进行范围查找。\n\n- SSTables和LSM树\n- B树\n\n为了避免进行事务分析对在线事务的影响，通过采用同步数据到数据仓库的方式来解决这个需求，将数据存入仓库的过程称为“抽取-转换-加载（ETL）”\n\n![202133144449](/assets/202133144449.png)\n\n对于部分的查询只需要用到少部分列，但一个事实表可能用来成百上千个列，这个时候引入列存储来提升性能\n\n### 编码与演化\n\n新旧版本的代码，以及新旧数据格式可能会在系统中同时共处。系统想要继续顺利运行，就需要保持双向兼容性：\n\n- 向后兼容：​新代码可以读旧数据\n- 向前兼容：旧代码可以读新数据\n\n数据的使用形式：\n\n- 在内存中，数据保存在对象，结构体，列表，数组，哈希表，树等中\n- 在传输中，数据通过XML或者JSON等进行编码\n\n相较于XML和JSON，二进制编码更加节省空间。\n\n为了保证软件演化过程的向前向后兼容，对每个字段，通过一个唯一标签来标志，只要字段不被删除，新的代码肯定可以处理老数据，但反过来，只有添加的每个字段是可选的或者有默认值，才能向前兼容。\n\n数据类型也对演化过程有影响，如果老数据时32位的，新数据时64位的，升级可以无缝迁移，但向前兼容时就会有问题。\n\n使用读者跟作者模式解决差异：\n\n![20213315519](/assets/20213315519.png)\n\n同时如果数据流经过旧代码，那么部分数据很有可能丢失：\n\n![20213315109](/assets/20213315109.png)\n\n## 流处理\n\n### 消息系统\n\n- 生产者直接到消费者\n- 使用消息代理缓存\n\n当有多个消费者时，如何进行消息传递：\n\n- 负载均衡\n- 扇出\n\n![202132318324](/assets/202132318324.png)\n\n- 分区日志消息系统\n\n### 流与数据库\n\n- 如何保持同步\n- 变更数据捕获\n- 事件溯源\n\n### 流处理\n\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}