{"content":"# 可观测性\n\n![20201125142726](/assets/20201125142726.png)\n\n- 日志：记录离散事件，通过这些记录事后分析出程序的行为\n- 追踪：单体的调用栈追踪或者服务调用之间的分布式追踪\n- 度量：度量是指对系统中某一类信息的统计聚合\n\n日志收集：与具体技术栈无关 ELK EFK\n\n度量：Prometheus\n\n链路追踪：Zipkin...\n\n## 日志\n\n![20201125143743](/assets/20201125143743.jpg)\n\n### 输出\n\n输出的日志应该是什么样的：\n\n- 避免敏感信息\n- 避免引用到慢操作信息\n- 避免输出的信息有误导性\n\n- 记录TraceID 没有TraceID就要自动生成来对请求进行标记\n- 记录系统运行时的关键事件\n\n### 收集&缓冲\n\n- Logstash\n- Beats\n\n为了缓解收集大量日志的压力 可以在收集器之前假设Kafka或者Redis作为缓冲层 面对突发流量\n\n### 加工&聚合\n\n- 将非结构化数据转为结构化数据\n\n### 存储&查询\n\nES是这方面唯一的选择\n\n日志有如下性质：\n\n1. 写入后基本无需修改\n2. 分为冷热数据 更早的日志价值更低\n3. 日志可离线查询与实时查询\n\n## 链路追踪\n\n目标：排查故障 分析性能数据\n\n- trace与span\n\n![2020112514590](/assets/2020112514590.png)\n\n链路追踪的挑战：\n\n1. 异构技术\n2. 对性能敏感\n3. 对应用透明\n4. 自动扩缩容\n5. 持续的监控\n\n### 数据收集\n\n- 基于日志信息的追踪：将Trace、Span等信息直接输出到应用日志中，然后随着所有节点的日志归集过程汇聚到一起，再从全局日志信息中反推出完整的调用链拓扑关系\n- 基于服务的追踪：通过代码注入的方式可以得到方法调用栈等信息 并且需要通过独立的网络调用上报信息 需要消耗更多的资源\n- 基于sidecar代理的方式：这种方式对应用透明 但它只能实现服务调用层面的追踪\n\n### 追踪规范化\n\nOpenTracing -> OpenCensus -> OpenTelemetry\n\n## 聚合度量\n\n### 指标收集\n\n指标数据类型\n\n- 计数度量器（Counter）：对有相同量纲、可加减数值的合计量\n- 瞬态度量器（Gauge）：表示某个指标在某个时点的数值\n- 吞吐率度量器（Meter）：单位时间内某个事件的发生次数\n- 直方图度量器（Histogram）\n- 采样点分位图度量器（Quantile Summary）\n\n指标采集方式\n\n- push\n- pull\n\n指标传输协议：\n\n- OpenMetrics\n\n健康检查API模式：\n\n![屏幕截图 2021-01-29 094428](/assets/屏幕截图%202021-01-29%20094428.png)\n\n### 存储查询\n\n如果使用传统的关系型数据库存储度量数据 那每天监控数据的产生量将会非常的大\n\n大部分度量数据都可以使用专门的时序数据库来进行存储\n\n由于度量数据多写少读、几乎不删改、数据只顺序追加这些特点，时序数据库就可以使用某些策略来进行优化：\n\n1. 日志结构的合并树\n2. 对数据进行采样进行节省空间 比如几周前的数据就只保留一天 几年前的就保留一周\n3. 轮替数据存储 类似于环形缓冲区 输入可以无限 存储有限\n\n### 监控预警\n\n- Grafana\n- Alter Manager\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}