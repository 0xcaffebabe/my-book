{"content":"## 分布式锁\n\n在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁\n\n阻塞锁使用一个互斥量来实现：\n\n- 0代表其他进程在使用锁\n- 1代表未锁定\n\n可以用一个整数表示，或者也可以用某个数据是否存在来表示\n\n### 数据库唯一索引\n\n获得锁时向表中插入一条记录，释放锁时删除这条记录\n\n- 锁没有失效时间，容易死锁\n- 是非阻塞的，获取锁失败就报错\n- 不可重入\n\n### redis setnx\n\n1.获取锁的时候，对某个key执行setnx，加锁（如果设置成功（获得锁）返回1，否则返回0），并使用expire命令为锁添加一个超时时间，超过该时间则自动释放锁，锁的value值为一个随机生成的UUID，通过此在释放锁的时候进行判断。\n\n2.获取锁的时候还设置一个获取的超时时间(防止死锁)，若超过这个时间则放弃获取锁。\n\n3.释放锁的时候，通过UUID判断是不是该锁，若是该锁，则执行delete进行锁释放\n\n#### 实现\n\n```java\npublic class RedisLock {\n    \n    private StringRedisTemplate template;\n\n    private static final String LOCK_KEY = \"LOCK\";\n\n    private String identifyValue;\n\n    public RedisLock(StringRedisTemplate template) {this.template = template;}\n\n    /**\n     * @param acquireTimeout 获取锁之前的超时时间\n     * @param expireTime     锁的过期时间\n     * @return\n     */\n    public boolean lock(long acquireTimeout, long expireTime) {\n        // 获取锁的时间\n        long inTime = System.currentTimeMillis();\n        identifyValue = UUID.randomUUID().toString();\n        for (; ; ) {\n            // 判断获取锁是否超时\n            if (System.currentTimeMillis() - inTime >= acquireTimeout) {\n                return false;\n            }\n            // 通过setnx的方式来获取锁\n            if (template.opsForValue().setIfAbsent(LOCK_KEY, identifyValue, expireTime, TimeUnit.MILLISECONDS)) {\n                // 获取锁成功\n                return true;\n            }\n            // 获取锁失败，继续自旋\n        }\n    }\n\n    public void release() {\n        if (identifyValue == null){\n            throw new IllegalStateException(\"没有获取锁\");\n        }\n        // 删除的时候验证value，必须确保释放的锁是自己创建的\n        if (!identifyValue.equals(template.opsForValue().get(LOCK_KEY))){\n            throw new IllegalStateException(\"锁的value不一致\");\n        }\n        template.delete(LOCK_KEY);\n    }\n}\n```\n\n#### 与zookeeper比较\n\n相对比来说Redis比Zookeeper性能要好，从可靠性角度分析，Zookeeper可靠性比Redis更好。因为Redis有效期不是很好控制，可能会产生有效期延迟\n\n\n### redis redlock\n\n使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用\n\n计算获取锁消耗的时间，只有消耗的时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功\n如果获取锁失败，就到每个实例上释放锁\n\n### zookeeper临时节点\n\n多个进程同时在zookeeper.上创建同一个相同的节点(/lock) , 因为zookeeper节点是唯一的，如果是唯一的话，那么同时如果有多个客户端创建相同的节点/lock的话，最终只有看谁能够快速的抢资源，谁就能创建/lock节点,创建节点不成功的进程，会注册一个监听事件，等节点被删除的时候，重新竞争这个锁\n这个时候节点类型应该使用临时类型。\n\n当一个进程释放锁后（关闭zk连接或者会话超时），临时节点会被删除，等待锁的其他进程会收到节点被删除的通知，这些等待的进程会重新参与到竞争\n\n需要注意的是，要根据业务设置锁等待时间，避免死锁\n\n#### 实现\n\n- 上锁\n\n```java\npublic void lock() {\n    // 尝试获取锁，如果成功，就真的成功了\n    if (tryLock()) {\n        System.out.println(Thread.currentThread().getName() + \"获取锁成功\");\n    // 否则等待锁\n    } else {\n        waitLock(); \n        // 当等待被唤醒后重新去竞争锁\n        lock();\n    }\n}\nprivate boolean tryLock() {\n    try {\n        // 通过zk创建临时节点的成功与否来表示是否获得锁\n        zkClient.createEphemeral(\"/lock\");\n        return true;\n    } catch (Exception e) {\n        return false;\n    }\n}\nprivate void waitLock() {\n    // 监听节点被删除的事件\n    zkClient.subscribeDataChanges(\"/lock\", new IZkDataListener() {\n        @Override\n        public void handleDataDeleted(String s) throws Exception {\n            // 如果节点被删除，唤醒latch\n            if (latch != null) {\n                latch.countDown();\n            }\n        }\n    });\n    // 如果zk有lock这个锁\n    if (zkClient.exists(\"/lock\")) {\n        // 在这里进行等待，直至被上面的事件监听唤醒\n        latch = new CountDownLatch(1);\n        try {\n            latch.await();\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    // 等待完成删除所有监听事件，避免监听器堆积影响性能\n    zkClient.unsubscribeAll();\n}\n```\n\n- 释放锁\n\n```java\npublic void release() {\n    if (zkClient != null) {\n        // 关闭zk客户端，临时节点也随之被删除，相当于释放锁，让其他人去竞争\n        zkClient.close();\n        System.out.println(Thread.currentThread().getName()+\"释放锁完成\");\n    }\n}\n```\n\n### zookeeper临时顺序节点\n\n有一把锁，被多个人给竞争，此时多个人会排队，第一个拿到锁的人会执行，然后释放锁；后面的每个人都会去监听排在自己前面的那个人创建的 node 上，一旦某个人释放了锁，排在自己后面的人就会被 zookeeper 给通知，一旦被通知了之后，就 ok 了，自己就获取到了锁\n\n### zk锁 vs redis锁\n\n- redis 分布式锁，其实需要自己不断去尝试获取锁，比较消耗性能\n- zk 分布式锁，获取不到锁，注册个监听器即可，等待zk的通知\n- redis如果客户端没有及时释放锁，会发生死锁\n\n## 分布式Session\n\n### 集群产生的问题\n\n服务器集群后，因为session是存放在服务器上，客户端会使用同一个Sessionid在多个不同的服务器上获取对应的Session，从而会导致Session不一致问题\n\n### 解决方案\n\n- cookie代替session\n- nginx将同一个ip的请求都转发到同一台服务器\n- 使用数据库存储session\n- 使用web容器的session同步\n- 使用redis存储session\n- 使用token或者jwt存储用户信息，需要时再去数据库或者cache查\n\n### SpringSession 使用redis存储session\n\n- 依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.session</groupId>\n    <artifactId>spring-session-data-redis</artifactId>\n</dependency>\n```\n\n- 配置\n\n```java\n@EnableRedisHttpSession\n```\n\n这时候，Session的存取都是通过redis来了","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}