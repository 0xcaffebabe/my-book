{"content":"# 结构型模式\n\n- 如何组合类和对象以获得更大的结构\n\n## 适配器\n\n> 将一个接口转换成另一个接口\n\n![](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1788250168,1635174602&fm=26&gp=0.jpg)\n\n- 双向适配器\n\n```java\ninterface Target{\n    void ops();\n}\n\nclass Adaptee{\n    public void run() { }\n}\n\nclass Adapter implements Target{\n    private Adaptee adaptee;\n    public Adapter(Adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n\n    @Override\n    public void ops() {\n        // do something\n        adaptee.run();\n    }\n}\n// 使用\nTarget target = new Adapter(new Adaptee());\ntarget.ops();\n```\n\n分类：\n- 类适配器\n- 对象适配\n- 接口适配方式\n\n## 桥接\n\n> 将抽象部分与实现部分分离,使它们都可以独立地变化\n\n```java\nabstract class Window {\n    //...\n    abstract setMenu(Menu menu)\n}\ninterface Menu{}\n\nclass LinuxWindow extends Window{...}\nclass MacWindow extends Window{...}\n\nclass PlainMenu implements Menu{...}\nclass RichMenu implements Menu{...}\n```\n\n## 组合\n\n>将对象组合成树形结构的部分-整体层次结构，使得客户使用单个对象或组合对象都有一致性\n\n![屏幕截图 2021-05-27 162917](/assets/屏幕截图%202021-05-27%20162917.png)\n\n```java\ninterface Route {\n    Route segement1, segement2;\n} // 路线\nclass NationalHighway implements Route{} // 国道\nclass CountryRoad implements Route {} // 乡道\n```\n\n组合模式很重要的一点就是客户端使用所有节点的方式都相同，同时这些节点内部又以组合的方式组合其他节点。\n\n## 装饰器\n\n> 给一个对象添加额外的职责\n\n![](https://images0.cnblogs.com/blog/296990/201301/26160050-91ebe03edf184c2da06e52074451c0da.x-png)\n\n装饰器与被装饰的对象都拥有同一个接口，所以说，装饰器对客户来说是透明的\n\n```java\nabstract class InputStream{...}\nclass FileInputStream extends InpurStream{...}\n```\n\n## 外观\n\n>为系统中的一组接口提供一致的界面\n\n![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1574653911824&di=6dd446e801e1345522df25149fd6ff0c&imgtype=jpg&src=http%3A%2F%2Fimg1.imgtn.bdimg.com%2Fit%2Fu%3D2321038136%2C3677263216%26fm%3D214%26gp%3D0.jpg)\n\n```java\nclass Facade{\n    private SubSystem1 subSystem1;\n    private SubSystem2 subSystem2;\n\n    void ops(){\n        subSystem1.ops1();\n        subSystem2.ops2();\n    }\n}\n// 使用\nFacade facade = new Facade();\nfacade.ops();\n```\n\n## 享元\n\n> 共享系统中大量的细粒度对象\n\n- 提高性能\n\n![](https://img.mukewang.com/58de211b00016e1511450584.png)\n\n```java\nclass MessageFactory{\n    Message getHeartBeatMeessage();\n}\ninterface Message{...}\nclass HeartBeatMessage implements Message{...}\n```\n\n## 代理\n\n>为其他对象提供一个代理访问控制\n\n- 又称为委托模式\n\n![](https://images0.cnblogs.com/blog/533121/201411/261700405126302.png)\n\n### 静态代理\n\n- 结构简单，代码繁琐\n\n![](https://img-blog.csdn.net/20180525135117709?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjIyODMzOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n```java\ninterface Subject{\n    void run();\n}\nclass Proxy implements Subject{\n    private Subject realObject = new RealSubject();\n    void run(){\n        //before\n        realObject.run();\n        //after\n    }\n}\n\n// 使用\nSubject subject = new Proxy();\nsubject.run();\n```\n\n### 动态代理\n\n![](http://upload-images.jianshu.io/upload_images/2085791-87f2922c993fd520?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- JDK动态代理\n\n```java\nSubjectImpl impl = new SubjectImpl();\nSubject proxy = (Subject) Proxy.newProxyInstance(impl.getClass().getClassLoader(), \n                impl.getClass().getInterfaces(), (proxy1, method, args1) -> {\n    System.out.println(\"pre invoke\");\n    return method.invoke(impl, args1);\n});\nproxy.request();\n```\n\n如果多个接口重名，则调用接口方法以第一个接口为主\n\n- cglib动态代理\n\n```java\nEnhancer enhancer = new Enhancer();\nObject target = new Object();\nenhancer.setSuperclass(Object.class);\nenhancer.setCallback((MethodInterceptor) (obj, method, args1, proxy) -> {\n    System.out.println(method+\" invoke\");\n    return method.invoke(target, args1);\n});\nObject o = enhancer.create();\nSystem.out.println(o.hashCode());\n```\n\n## generation gap（生成模式）\n\n该模式会生成代码导出行为 再通过编程来丰富程序行为 只修改或扩展一次 而可以生成代码多次 win下的GUI设计好像就这么做的\n\n![屏幕截图 2020-12-23 162057](/assets/屏幕截图%202020-12-23%20162057.png)\n\n问题：\n\n需求变化导致生成代码的变化\n\n解决方式一是警告禁止修改 二是计算代码差异重新生成 三则是隐藏生成的代码的细节 隔离变与不变\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}