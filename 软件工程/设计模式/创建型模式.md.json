{"content":"# 创建型模式\n\n- 封装了系统使用哪些类\n- 隐藏了这些类类的实例是如何创建和放在一起的\n\n## 建造者\n\n> 将复杂对象的构建与表示相分离，同样的构建过程可以创建不同的表示\n\n![](https://www.cnblogs.com/images/cnblogs_com/mhx1982/builder.GIF)\n\n- 可以改变一个产品内部表示\n- 构造代码与表示代码分离\n- 对构造进行更细粒度的控制\n\n```java\ninterface Builder{\n    Builder process1();\n    Builder process2();\n    Builder process3();\n    Product build();\n}\nclass ConcreteBuilder implements Builder{\n    // 方法实现...\n}\nclass ProductDirector{\n    public Product constructProduct(Builder builder){\n        builder.process1();\n        builder.process2();\n        builder.process3();\n        return builder.build();\n    }\n}\n// 使用\nProductDirector director = new ProductDirector();\nProduct product = director.constructProduct(new ConcreteBuilder());\n```\n\n## 工厂模式\n\n### 简单工厂\n\n客户无需知道具体产品的名称，只需要知道产品类所对应的参数即可\n\n```java\nclass Factory{\n    public Product get(int condition){\n        switch(condition){\n            case 1:\n                return new Product1();\n            case 2:\n                return new Product2();\n        }\n        return null;\n    }\n}\n```\n\n但是工厂的职责过重，而且当类型过多时不利于系统的扩展维护\n\n### 工厂方法\n\n> 定义一个接口，让子类创建该接口的实例，也就是将实例化延迟到工厂的子类\n\n![屏幕截图 2021-06-04 113651](/assets/屏幕截图%202021-06-04%20113651.png)\n\n- 工厂方法模式适合于构造同属于同一个类别的不同产品，所有的产品属于同一个系列中\n\n模板方式和工厂模式的核心思想非常类似， 都是把一些操作留给子类去实现。模板方法经常使用工厂方法作为其算法的一部分\n\n```java\nabstract class AbstractCreator{\n    abstract Product get();\n\n    public void doSomething(){\n        // do something\n        Product product = get();\n        // do something\n    }\n}\nclass Creator1 extends AbstractCreator{\n    Product get(){...}\n}\nclass Creator2 extends AbstractCreator{\n    Product get(){...}\n}\n// 使用\nFactory factory = new Creator2();\nProduct product = factory.doSomething();\n```\n\n### 抽象工厂\n\n> 提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体类\n\n![屏幕截图 2021-04-09 150901](/assets/屏幕截图%202021-04-09%20150901.png)\n\n- 分离了具体的类\n- 使得产品改变变得容易\n- 利于维护产品的一致性\n- **扩展产品种类困难**\n\n```java\nabstract class Factory{\n    abstract Product get(int condition);\n}\nclass ProductAFactory extends Factory{\n    ProductA get(int condition){...}\n}\nclass ProductBFactory extends Factory{\n    ProductB get(int condition){...}\n}\n// 使用\nFactory factory = new ProductAFactory();\nProduct product = factory.get(condition);\n```\n\n在实践中，每个工厂一般都会是单例。工厂内部可使用原型模式来实现\n\n## 原型\n\n>通过一个原型对象创建新的对象\n\n![](https://zhenyulu.cnblogs.com/images/cnblogs_com/zhenyulu/Pic55.gif)\n\n- 可以在运行时刻动态改变产品种类\n- 改变值或结构就能获得新对象\n- 动态配置\n\n```java\nclass Product {\n    Part1 part1;\n\n    @Override\n    protected Object clone() throws CloneNotSupportedException {\n        Product product = (Product) super.clone();\n        product.part1 = (Part1)part1.clone();\n        return product;\n    }\n}\n```\n\n## 单例\n\n>一个类仅有一个实例，并只拥有一个全局访问点\n\n问题：谁来销毁单例对象？什么时候销毁？\n\n- 单例模式适用于生命周期很长的对象 一般不会显式销毁\n- 使用SingletonDestroyer在程序关闭时进行销毁\n    - 对于相互依赖的单例对象 需要注意顺序\n\n### 饿汉式\n\n- 类初始化时,会立即加载该对象，线程天生安全,调用效率高\n\n```java\npublic class Singleton {\n    private static final Singleton SINGLETON = new Singleton();\n    private Singleton() { }\n    \n    public static Singleton getInstance(){\n        return SINGLETON;\n    }\n}\n```\n\n### 懒汉式\n\n- 类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能\n\n```java\npublic class Singleton {\n    private static Singleton SINGLETON ;\n    private Singleton() { }\n\n    // 线程不安全\n    public static Singleton getInstance(){\n        if (SINGLETON == null){\n            SINGLETON = new Singleton();\n        }\n        return SINGLETON;\n    }\n}\n```\n\n### 静态内部类方式\n\n- 结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的\n\n```java\npublic class Singleton {\n    \n    private Singleton() { }\n\n    private static class SingletonClass{\n        public static final Singleton SINGLETON = new Singleton();\n    }\n    \n    public static Singleton getInstance(){\n        return SingletonClass.SINGLETON;\n    }\n}\n```\n\n### 枚举单例\n\n- 使用枚举实现单例模式 优点:实现简单、调用效率高，枚举本身就是单例，由jvm从根本上提供保障!避免通过反射和反序列化的漏洞， 缺点没有延迟加载\n\n```java\npublic class Singleton {\n\n    private Singleton() { }\n\n    private enum  SingletonEnum{\n        INSTANCE;\n        private Singleton singleton;\n\n        SingletonEnum() {\n            singleton = new Singleton();\n        }\n\n        public Singleton getSingleton() {\n            return singleton;\n        }\n    }\n\n    public static Singleton getInstance(){\n        return SingletonEnum.INSTANCE.getSingleton();\n    }\n}\n```\n\n### 双重检测加锁\n\n```java\npublic class Singleton {\n\n    private static volatile Singleton SINGLETON; // 如果没有volatile JVM的指令重排序很有可能导致实例化多个对象\n\n    private Singleton() { }\n\n    public static Singleton getInstance(){\n        if (SINGLETON == null){\n            synchronized (Singleton.class){\n                if (SINGLETON == null){\n                    SINGLETON = new Singleton();\n                }\n            }\n        }\n        return SINGLETON;\n    }\n}\n```\n\n\n```java\n// SINGLETON = new Singleton() 可以分解为以下三个步骤\n1 memory=allocate();// 分配内存 相当于c的malloc\n2 ctorInstanc(memory) //初始化对象\n3 s=memory //设置s指向刚分配的地址\n\n// 上述三个步骤可能会被重排序为 1-3-2，也就是：\n1 memory=allocate();// 分配内存 相当于c的malloc\n3 s=memory //设置s指向刚分配的地址\n2 ctorInstanc(memory) //初始化对象\n```\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}