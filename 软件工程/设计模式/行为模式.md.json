{"content":"# 行为模式\n\n- 主要涉及到算法和对象之间的职责分配\n\n## 责任链\n\n> 使多个对象都有机会处理请求，避免发送者与接受者之间的耦合\n\n![屏幕截图 2021-05-27 093547](/assets/屏幕截图%202021-05-27%20093547.png)\n\n- 拥有动态添加职责的灵活性\n- **不保证被接受**\n\n```java\npublic interface Filter {\n\n    void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3) throws IOException, ServletException;\n}\npublic class LoggingFilter implements Filter {\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        //...\n    }\n}\n```\n\n在GOF的书中描述的责任链每个节点都有一个后继节点，前驱节点可根据特定的逻辑来将请求传递到后继节点来进行处理，代表着一种责任的转移。\n\n另外一种责任链的变体模式：\n\n1. 引入一个责任链实体，即责任链节点编排器：\n\n```java\npublic class Chain {\n    void process(){\n        for(var chainNode : chain) {\n            if (!chainNode.process()) {\n                break;\n            }\n        }\n    }\n}\n```\n\n2. 责任链节点可通过传回一个布尔值或者抛出异常来终止整个流程。\n\n这种方式的问题在于无法实现类似于Web Filter的对Response的过滤处理。上述的Filter可以在后继Filter处理完毕后回来处理后继Filter处理过的Response，而通过引入一个第三方编排校色的方式则无法实现。\n\n## 命令\n\n> 将请求封装为对象\n\n该模式解耦了调用请求的对象与知道如何处理该请求的对象\n\n![202164142850](/assets/202164142850.jpg)\n![202164145026](/assets/202164145026.jpg)\n\n```java\ninterface Command {\n    void execute();\n}\nclass ConcreteCommand1 implements Command {\n    Reveiver reveiver;\n    void execute() {\n        reveiver.action(); // do something\n    }\n}\nclass ConcreteCommand2 implements Command {...}\n\nclass Invoker {\n    void invoke(){\n        Command command;\n        command.execute();\n    }\n}\n```\n\n在该模式的实现中，一个很重要的一点是可以考虑在Invoker记录该命令的操作历史，定义另外一个接口unexecute 来实现对命令撤销。\n\n## 解释器\n\n> 定义一个文法，定义一个解释器，解释器解释执行做一些操作\n\n![](https://images0.cnblogs.com/blog/533121/201412/091203106181898.png)\n\n## 迭代器\n\n> 提供一种顺序访问对象中的各个元素，并不暴露内部表示\n\n![](http://image.codes51.com/Article/image/20160509/20160509193506_2193.jpg)\n\n- 外部迭代与内部迭代的区别在于是由客户控制还是迭代器控制迭代\n\n```java\ninterface Iterator{\n    hasNext();\n    next();\n}\nclass ArrayListItr implements Iterator{...}\n```\n\n## 中介者\n\n> 用一个中介对象封装一系列对象之间的交互\n\n- 与外观模式不同之处在于中介模式的交互是双向的，而外观模式只是从外观对象到子系统之间的单向协议\n\n![](https://imgedu.lagou.com/1209090-20190829171805208-637969589.png)\n\n## 备忘录\n\n> 不破坏封装性的情况下，保存一个对象的内部状态\n\n![](https://www.cnblogs.com/images/cnblogs_com/yangfengming/Design%20Patterns/21.Memento_01.jpg)\n\n## 观察者\n\n>定义对象间一对多的依赖关系，依赖它的对象都会得到通知并自动更新\n\n![](https://img-blog.csdn.net/20161111191040882)\n\n- 具体目标与具体观察者之间是抽象耦合\n- 广播通信\n- 推模型与拉模型\n\n```java\nabstract class Subject{\n    add(Observer ob);\n    del(Observer ob);\n    notify();\n}\ninterface Observer{\n    update();\n}\nclass ConcreteSubject{\n    notify(){\n        obServerlist.forEachNotify();\n    }\n}\nclass ConcreteObserver implements Observer{\n    ...\n}\n```\n\n\n## 状态\n\n> 允许一个对象在其内部状态改变时改变它的行为\n\n![屏幕截图 2020-08-06 134707](/assets/屏幕截图%202020-08-06%20134707.png)\n\n- 对象就是一个状态机，当从一个状态转移到另外一个状态，其行为就会发生改变\n\n```java\nclass LoginContext{\n    private UserState state;\n    login(){\n        state.login()\n    }\n}\ninterface UserState{\n    login();\n}\nclass UserNormalState{\n    login(){\n        if (loginFailCount == 5){\n            context.state = new UserBannedState();\n        }\n        print \"login success\";\n    }\n}\nclass UserBannedState{\n    login(){\n        print \"you are banned\";\n    }\n}\n```\n\n## 策略模式\n\n> 封装一系列算法，以使它们可以互相替换\n\n- 策略模式与状态模式之间的区别在于状态模式的各个状态之间是有联系的\n\n![202153110326](/assets/202153110326.jpg)\n\n```java\ninterface Strategy{\n    void execute(..);\n}\n\nclass Context {\n    private Strategy strategy;\n\n    public Context(Strategy strategy) {\n        this.strategy = strategy;\n    }\n    \n    void execute(){\n        strategy.execute(..);\n    }\n}\n\nclass StrategyA implements Strategy{\n    // 具体实现\n}\n// 使用\nContext context = new Context(new StrategyA());\ncontext.execute();\n```\n\n策略模式要求客户代码必须了解不同策略模式的差异，也就是客户必须针对具体实现进行编码。\n\n另外一个要考虑的是不同策略所需要的参数不同，虽然可以一股脑将全部参数传递给具体策略，但为了降低性能开销，某些策略并不需要用到那么多参数，此时可以传递一个Context的引用给具体策略，让具体策略按需索取，但这种方式则对Context接口的粒度做了过细的要求。\n\n**组合模式 + 策略模式**\n\n可以通过组合多个策略得到一个新的策略：\n\n```java\nclass CompositeStrategy implements Strategy{\n    void execute(){\n        StrategyA...\n        StrategyB...\n    }\n}\n```\n\n## 模板方法\n\n> 在父类当中定以算法骨架，将一些步骤延迟到子类当中实现\n\n实现一些操作时，整体步骤很固定，但是呢。就是其中一小部分容易变，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现\n\n![](https://s1.51cto.com/wyfs02/M02/07/E3/wKiom1nTsy6QH7fSAABnq3D-dY4625.jpg)\n\n- 钩子操作\n\n```java\nabstract class BaseAlgorithm{\n    void process(){\n        process1();\n        process2();\n    }\n    abstract void process1();\n    abstract void process2();\n}\nclass ConcreteAlgorithm extends BaseAlgorithm{\n    // 实现方法\n}\n// 使用\nBaseAlgorithm algorithm = new ConcreteAlgorithm();\nalgorithm.process();\n```\n\n## 访问者\n\n> 表示一个作用于对象结构中的各元素的操作\n\n识图避免新功能的引入造成接口的修改\n\n![屏幕截图 2021-06-15 161411](/assets/屏幕截图%202021-06-15%20161411.png)\n\n```java\nclass Visitor {\n    visit(ElementA);\n    visit(ElementB);\n}\nclass VisitorA extends Visitor {\n    visit(ElementA){...}\n    visit(ElementB){...}\n}\nclass VisitorB extends Visitor {\n    visit(ElementA){...}\n    visit(ElementB){...}\n}\nclass Element{\n    accept(Vistor);\n}\nclass ElementA extends Element {\n    accept(Vistor) {\n        Visitor.visit(this)\n    }\n}\n...\n```\n\n访问者设计模式提出的根本原因是为了在不修改类的前提下 增加类的行为。\n\n在这里，当需要增加新的行为时，就将新增一个具体的Vistor 然后传递给响应的Element。\n\n该模式适合在对象数据结构稳定，不会变更且经常需要定义新操作的场景下使用。\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}