{"content":"# 表述\n\n## 分层架构\n\n![批注 2020-06-26 092443](/assets/批注%202020-06-26%20092443.png)\n\n将系统按照职责拆分和组织，上层依赖于下层定义的各种服务，下层对上层隐藏下下层的细节\n\n层次并不能封装所有东西，有时会带来级联修改，过多的层次也会影响性能\n\n- OSI七层模型\n- CS/BS架构\n- 企业应用分层\n  - 表现层\n  - 领域层\n  - 数据源层\n\n### 为何分层\n\n- 关注点分离（降低复杂度）\n- 隔离变化/错误\n- 扩展性伸缩性\n- 可测试性\n\n### 分层的问题\n\n- 性能开销：通信、数据转化\n- 开发成本\n\n### 分层架构设计\n\n- [依赖原则](/软件工程/架构/软件架构.md#依赖关系规则)\n- 定义职责：职责分离 高层抽象\n- 层技术栈选择：每层需求自定 参考成功架构 适合自己组织\n- 集成：单层内部的单元测试 -> 层之间的集成测试\n\n### 分层架构模型\n\n#### MVC\n\n随着前后端分离以及后端微服务化的不断发展，传统的MVC已不适合现在的纯后端系统，Controller其实也是API，它代表了服务对外提供的接口，是一种合约\n\n- model:模型代表一个存取数据的对象或 JAVA POJO。它也可以带有逻辑，在数据变化时更新控制器\n- view:视图代表模型包含的数据的可视化\n- controller:控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开\n\n- Model1模型\n\n![2021106133223](/assets/2021106133223.jpg)\n\n- Model2模型\n\n![202110613336](/assets/202110613336.jpg)\n\n当有用户的行为触发操作时，会有控制器更新模型，并通知视图进行更新，在这时视图向模型请求新的数据\n\n**优势**\n\n- 清晰的职责划分\n- 组件独立，代码重用\n- 后期维护方便\n- 适合任何项目\n\n**弊端**\n\n- 展示数据慢（针对jsp）\n- 对开发者架构设计能力要求高\n- 异步交互不方便\n\n#### MVP\n\n![2021106132821](/assets/2021106132821.png)\n\n- Presenter较为复杂 可以脱离view进行测试\n\n#### [MVVM](/编程语言/JavaScript/Vue/nav.md#MVVM)\n\n#### BFF\n\n- 为前端而生的后端服务\n\n![](/assets/20201119152838.png)\n\n## 事件驱动架构\n\n- 异步分发事件\n  - 发生的事件\n  - 变化的状态\n- 耦合较低 灵活 扩展较容易\n- 由于异步与细粒度的处理单元 正常情况下性能较高 但在出现异常重试时性能会降低\n- **集成测试、维护很难**\n\n### 两种模式\n\n#### Mediator\n\n![2021106152652](/assets/2021106152652.png)\n\n- Event Queue：只关注事件的接收和发送\n- Event Mediator：将原始事件转化成业务事件\n- Event Channel：业务事件的聚合 由感兴趣的processor监听\n- Event Processor：业务事件执行单元\n\n#### Broker\n\n![202110615598](/assets/202110615598.png)\n\n- 无中心编排控制点\n- 无业务逻辑的消息分发\n\n两种模式的processor都是单一职责的最小执行单元\n\n## 组织领域逻辑\n\n- 编写业务逻辑\n\n### 事务脚本\n\n优点\n\n- 易于理解\n- 能与简单数据源层很好合作\n- 事务边界容易划分\n\n缺点\n\n- 业务复杂导致代码冗余复杂\n\n#### 领域模型\n\n- 使用面向对象的方法\n\n开销来源于使用复杂以及数据源的复杂，还要面对将领域模型映射到数据库的问题\n\n### 表模块\n\n- 围绕表组织领域逻辑\n\n### 服务层\n\n- 将领域层再拆为两层，服务层提供简单的API接口\n\n## 映射到关系数据库\n\n### 架构模式\n\n- 活动记录\n  - 类似于JAVA Bean\n- 数据映射器\n  - ORM\n\n### 行为\n\n如何保证对领域对象的修改能及时存储到数据库\n\n- 标志映射\n  - 保证相同的对象只被加载一次\n- 延迟加载\n\n### 读取数据\n\n### 结构映射模式\n\n#### 关系的映射\n\n- 外键映射一对多\n- 关联表映射多对多\n\n#### 继承\n\n- 单表继承\n  - 多个层次共享同一张表\n\n![](https://chuhang123.github.io/images/97.png)\n\n- 具体表继承\n  - 一个层次一张表\n\n![](https://chuhang123.github.io/images/100.png)\n\n- 类表继承\n  - 一个类一张表\n\n![](https://chuhang123.github.io/images/98.png)\n\n### 建立映射\n\n将数据库设计看做一种持久化对象数据的方法\n\n- 双向映射\n  - 将对象-数据库以及数据库-对象两种映射分开设计\n\n### 元数据\n\n- 通过元数据的描述自动生成代码\n\n### 数据库连接\n\n- 使用连接池管理连接\n- 将连接与事务绑定在一起\n\n## web表现层\n\n### 模板视图\n\njsp php\n\n### 转换视图\n\njson\n\n### 两阶视图\n\n生成一个逻辑视图，再将逻辑视图对应到html\n\n## 并发\n\n### 本质问题\n\n- 更新丢失\n- 不一致读\n\n### 执行语境\n\n- 一个请求对应一个会话，可以使进程，也可以是线程，但创建进程耗费资源，使用线程又会导致线程安全问题\n- 数据库中的语境是事务\n\n### 方案\n\n- 隔离：划分数据，一片数据只能被一个工作单元访问\n- 不变：不变的数据是线程安全的\n\n#### 乐观锁与悲观锁\n\n- 使用读写控制\n- 死锁\n\n### 事务\n\n事务是一个又边界的工作序列，开始和结束都有明确定义\n\n- 事务的特性\n\n#### 事务资源\n\n横跨多个请求的被称为长事务\n\n锁升级：一个事务锁住了许多行，则直接升级到对整个表的锁\n\n#### 减少事务隔离提高灵活性\n\n可串行化：当并发执行的结果与以某种顺序一致时\n\n#### 系统事务与业务事务\n\n#### 离线并发控制\n\n只有在数据提交失败的时候才能发现\n\n### 应用服务器并发\n\n使用每会话一个进程的方式来避免处理线程的麻烦\n\n## 会话状态\n\n- 无状态服务器\n\n### 存储方法\n\n- 客户端存储\n  - cookie\n  - 注意会话数据大小以及数据安全性完整性\n- 服务器存储\n  - session\n- 数据库存储\n  - 将会话信息存储在数据库中\n\n### 会话迁移\n\n会话可以在服务器集群之间转移\n\n## 分布\n\n### 远程接口与本地接口\n\n进程内的过程调用非常快\n\n### 何时必须使用分布对象\n\n- 客户机与服务器之间\n- 服务器与数据库之间\n- web系统之间\n- 使用软件包\n\n### 分布边界\n\n注意远程调用的边界\n\n### 分布接口\n\n- 基于XML与HTTP\n\n如果系统基于相同的平台构建，最好使用系统自己的远程调用机制\n\n\n\n\n\n\n\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}