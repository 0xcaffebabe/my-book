{"content":"# 代码重构\n\n在不改变代码外在行为的前提下，对代码进行修改，以改进程序的内部结构\n\n- 如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添加该特性。\n- 重构前，先检查自己是否有一套可靠的测试代码。这些测试必须有自我检验能力。\n- 重构技术就是以微小的步伐修改程序。 如果你犯下错误，很容易便可发现它。\n\n## 重构原则\n\n### 为何重构\n\n- 改进软件的设计\n- 使代码更容易理解\n- 提高编程速度\n\n### 何时重构\n\n- 预备性重构：添加新功能的时候\n- 帮助理解的重构：为了理解系统或者代码所做的工作\n- 捡垃圾式重构：偶然发现一处坏代码，重构它\n- 修复错误的时候\n- 代码审查的时候\n\n### 何时不该重构\n\n- 不会被用到的代码\n- 重构的代价比重写的代价还高的代码\n\n### 如何保证重构的正确性\n\n测试是保证代码正确性的强有力保证\n\n- 自动化\n- 测试不通过真的会失败\n- 频繁运行测试\n- 注意边界条件\n- 使用测试来重现bug\n\n## 代码的坏味道\n\n- 奇怪的命名\n- 重复代码\n- 过长的函数\n- 过长的参数列表\n- 全局数据\n- 可变数据\n- 发散式变化\n  - 一个修改会影响到许多地方\n- 霰弹式修改\n  - 一个变化需要修改许多地方\n- 过度依赖外部模块\n- 类中重复的数据\n- 基本类型偏执\n  - 总觉得基本类型效率更高，不愿使用对象\n- 大量重复的switch/if\n- 复杂的循环语句\n- 冗余的元素\n  - 一个简单的函数、一个简单的操作\n- 过度设计的通用性\n  - 过度考虑了对象/函数的用途\n- 临时字段\n- 过长的对象调用\n- 没有必要的中间对象\n- 两个模块耦合过紧\n  - 考虑将它们移动到新模块\n- 过大的类\n- 过度相似的类\n- 纯数据类\n  - 数据和行为没有在一起\n- 继承父类，但不提供父类的接口\n\n## 重构列表\n\n### 函数/变量\n\n- 提炼函数\n\n![批注 2020-06-30 103655](/assets/批注%202020-06-30%20103655.png)\n\n根据代码意图进行拆分函数，如果发现一段代码需要阅读一会才能知道是干嘛的，那就提炼它\n\n```js\nfunction printOwing(invoice) {\n　printBanner();\n　let outstanding = calculateOutstanding();\n\n　//print details\n　console.log(`name: ${invoice.customer}`);\n　console.log(`amount: ${outstanding}`);\n}\n```\n\n↓\n\n```js\nfunction printOwing(invoice) {\n　printBanner();\n　let outstanding = calculateOutstanding();\n　printDetails(outstanding);\n\n　function printDetails(outstanding) {\n　　console.log(`name: ${invoice.customer}`);\n　　console.log(`amount: ${outstanding}`);\n　}\n}\n```\n\n- 内联函数\n\n![批注 2020-06-30 104427](/assets/批注%202020-06-30%20104427.png)\n\n提炼函数的反向操作\n\n如果函数的代码跟函数名称一样拥有可读性，那么可以直接内联它\n\n- 提炼变量\n\n![批注 2020-06-30 104817](/assets/批注%202020-06-30%20104817.png)\n\n给一些表达式起个有意义的名称，有助于阅读、调试\n\n```js\nreturn order.quantity * order.itemPrice -\n　Math.max(0, order.quantity - 500) * order.itemPrice * 0.05 +\n　Math.min(order.quantity * order.itemPrice * 0.1, 100)\n```\n\n↓\n\n```js\nconst basePrice = order . quantity * order . itemPrice;\nconst quantityDiscount = Math. max(0, order . quantity - 500) * order. itemPrice * 0.05;\nconst shipping = Math. min(basePrice * 0.1, 100);\nreturn basePrice - quantityDiscount + shipping;\n```\n\n- 内联变量\n\n上述的反向重构\n\n有些表达式本身就已经很有语义，没必要引入变量再来说明\n\n- 改变函数签名\n\n注意函数签名的上下文，不同的上下文通用性程度不一样\n\n- 直接修改\n- 迁移式\n  - 暴露新旧两个接口，将旧接口设置为废弃\n\n- 封装变量\n\n对于访问域过大的数据，使用函数进行封装，这样在重构、监控上更加容易\n\n```js\nlet defaultOwner = {firstName: \"Martin\", lastName: \"Fowler\"};\n```\n\n↓\n\n```js\nlet defaultOwnerData = {firstName: \"Martin\", lastName: \"Fowler\"};\nexport function defaultOwner()       {return defaultOwnerData;}\nexport function setDefaultOwner(arg) {defaultOwnerData = arg;}\n```\n\n- 变量改名\n\n好的命名是整洁代码的核心\n\n- 引入参数对象\n\n让数据项自己的关系变得清晰，并且缩短参数列表\n\n```js\nfunction amountInvoiced(startDate, endDate) {...} \nfunction amountReceived(startDate, endDate) {...} \nfunction amountOverdue(startDate, endDate) {...}\n```\n\n↓\n\n```js\nfunction amountInvoiced(aDateRange) {...} \nfunction amountReceived(aDateRange) {...} \nfunction amountOverdue(aDateRange) {...}\n```\n\n- 函数组合成类\n\n发现行为与数据之间的联系，发现其他的计算逻辑\n\n```js\nfunction base(aReading) {...}\nfunction taxableCharge(aReading) {...} \nfunction calculateBaseCharge(aReading) {...}\n```\n\n↓\n\n```js\nclass Reading { \n  base() {...}\n  taxableCharge() {...} \n  calculateBaseCharge() {...}\n}\n```\n\n- 合并函数\n\n对于多个操作相同的数据，并且逻辑可以集中的函数，可以将它们合并成同一个函数\n\n```js\nfunction base(aReading) {...}\nfunction taxableCharge(aReading) {...}\n```\n\n↓\n\n```js\nfunction enrichReading(argReading) {\n  const aReading = _.cloneDeep(argReading);\n  aReading.baseCharge = base(aReading);\n  aReading.taxableCharge = taxableCharge(aReading);\n  return aReading;\n}\n```\n\n- 拆分阶段\n\n一段代码做了多件事，将它拆分为多个函数\n\n### 封装\n\n- 封装记录\n\n封装能更好地应对变化\n\n```js\norganization = {name: \"Acme Gooseberries\", country: \"GB\"};\n```\n\n↓\n\n```js\nclass Organization {...}\n```\n\n- 封装集合\n\n对集合成员变量进行封装，返回其一个副本，避免其被修改带来的诸多问题\n\n```js\nclass Person {\n  get courses() {return this._courses;}\n  set courses(aList) {this._courses = aList;}\n}\n```\n\n↓\n\n```js\nclass Person {\n  get courses() {return this._courses.slice();} \n  addCourse(aCourse) { ... } \n  removeCourse(aCourse) { ... }\n}\n```\n\n- 以对象取代基本类型\n\n一开始使用基本类型能很好地表示，但随着代码演进，这些数据可能会产生一些行为，此时最好将其封装为对象\n\n```js\norders.filter(o => \"high\" === o.priority\n               || \"rush\" === o.priority);\n```\n\n↓\n\n```js\norders.filter(o => o.priority.higherThan(new Priority(\"normal\")))\n```\n\n- 以查询取代临时变量\n\n使用函数封装临时变量的计算，对于可读性、可复用性有提升\n\n```js\nconst basePrice = this._quantity * this._itemPrice; \nif (basePrice > 1000)\n  return basePrice * 0.95; \nelse\n  return basePrice * 0.98;\n```\n\n↓\n\n```js\nget basePrice() {this._quantity * this._itemPrice;}\n...\nif (this.basePrice > 1000) \n  return this.basePrice * 0.95;\nelse\n  return this.basePrice * 0.98;\n```\n\n- 提炼类\n\n随着代码演进，类不断成长，会变得越加复杂，需要拆分它\n\n```js\nclass Person {\n　get officeAreaCode() {return this._officeAreaCode;} \n　get officeNumber()   {return this._officeNumber;}\n}\n```\n\n↓\n\n```js\nclass Person {\n　get officeAreaCode() {return this._telephoneNumber.areaCode;} \n　get officeNumber()   {return this._telephoneNumber.number;}\n}\nclass TelephoneNumber {\n　get areaCode() {return this._areaCode;} \n　get number()   {return this._number;}\n}\n```\n\n- 内联类\n\n上述的反向操作，由于类职责的改变，或者两个类合并在一起会更加简单\n\n- 隐藏委托关系\n\n封装意味着模块间相互了解的程度应该尽可能小，一旦发生变化，影响也会较小\n\n```js\nmanager = aPerson.department.manager;\n```\n\n↓\n\n```js\nmanager = aPerson.manager; \n\nclass Person {\n  get manager() {return this.department.manager;}\n}\n```\n\n- 移除中间人\n\n上述的反向操作，对于一些没必要的委托，可以直接让其跟真实对象打交道，避免中间层对象成为一个纯粹的转发对象\n\n- 替换算法\n\n不改变行为的前提下，将比较差的算法替换成比较好的算法\n\n```js\nfunction foundPerson(people) {\n　for(let i = 0; i < people.length; i++) { \n　　if (people[i] === \"Don\") {\n　　　return \"Don\";\n　　}\n　　if (people[i] === \"John\") { \n　　　return \"John\";\n　　}\n　　if (people[i] === \"Kent\") { \n　　　return \"Kent\";\n　　}\n　}\n　return \"\";\n}\n```\n\n↓\n\n```js\nfunction foundPerson(people) {\n　const candidates = [\"Don\", \"John\", \"Kent\"];\n　return people.find(p => candidates.includes(p)) || '';\n}\n```\n\n### 搬移特性\n\n- 搬移函数\n\n对于某函数，如果它频繁使用了其他上下文的元素，那么就考虑将它搬移到那个上下文里\n\n```js\nclass Account {\n　get overdraftCharge() {...}\n}\n```\n\n↓\n\n```js\nclass AccountType {\n    get overdraftCharge() {...}\n}\n```\n\n- 搬移字段\n\n![批注 2020-07-02 124318](/assets/批注%202020-07-02%20124318.png)\n\n对于早期设计不良的数据结构，使用此方法改造它\n\n```js\nclass Customer {\n  get plan() {return this._plan;}\n  get discountRate() {return this._discountRate;}\n}\n```\n\n↓\n\n```js\nclass Customer {\n  get plan() {return this._plan;}\n  get discountRate() {return this.plan.discountRate;}\n}\n```\n\n- 搬移语句到函数\n\n使用这个方法将分散的逻辑聚合到函数里面，方便理解修改\n\n```js\nresult.push(`<p>title: ${person.photo.title}</p>`); \nresult.concat(photoData(person.photo));\n\nfunction photoData(aPhoto) { \n　return [\n　　`<p>location: ${aPhoto.location}</p>`,\n　　`<p>date: ${aPhoto.date.toDateString()}</p>`,\n ];\n}\n```\n\n↓\n\n```js\nresult.concat(photoData(person.photo));\n\nfunction photoData(aPhoto) { \n　return [\n　　`<p>title: ${aPhoto.title}</p>`,\n　　`<p>location: ${aPhoto.location}</p>`,\n　　`<p>date: ${aPhoto.date.toDateString()}</p>`,\n　];\n}\n```\n\n- 搬移语句到调用者\n\n上述的反向操作\n\n对于代码演进，函数某些代码职责发生变化，将它们移除出去\n\n- 以函数调用取代内联代码\n\n一些函数的函数名就拥有足够的表达能力\n\n```js\nlet appliesToMass = false; \nfor(const s of states) {\n  if (s === \"MA\") appliesToMass = true;\n}\n```\n\n↓\n\n```js\nappliesToMass = states.includes(\"MA\");\n```\n\n- 移动语句\n\n让存在关联的东西一起出现，可以使代码更容易理解\n\n```js\nconst pricingPlan = retrievePricingPlan(); \nconst order = retreiveOrder();\nlet charge;\nconst chargePerUnit = pricingPlan.unit;\n```\n\n↓\n\n```js\nconst pricingPlan = retrievePricingPlan(); \nconst chargePerUnit = pricingPlan.unit; \nconst order = retreiveOrder();\nlet charge;\n```\n\n- 拆分循环\n\n对一个循环做了多件事的代码，拆分它，使各段代码职责更加明确\n\n虽然这样可能会对性能造成一些损失\n\n```js\nlet averageAge = 0;\nlet totalSalary = 0;\nfor (const p of people) {\n　averageAge += p.age;\n　totalSalary += p.salary;\n}\naverageAge = averageAge / people.length;\n```\n\n↓\n\n```js\nlet totalSalary = 0;\nfor (const p of people) { \n　totalSalary += p.salary;\n}\n\nlet averageAge = 0;\nfor (const p of people) {\n　averageAge += p.age;\n}\naverageAge = averageAge / people.length;\n```\n\n- 以管代取代循环\n\n一些逻辑如果采用管道编写，可读性会更强\n\n```js\nconst names = [];\nfor (const i of input) {\n  if (i.job === \"programmer\") \n    names.push(i.name);\n}\n```\n\n↓\n\n```js\nconst names = input\n  .filter(i => i.job === \"programmer\")\n  .map(i => i.name);\n```\n\n- 移除死代码\n\n移除那些永远不会允许的代码\n\n### 重新组织数据\n\n- 拆分变量\n\n如果一个变量被用于多种用途，很明显违反了单一职责原则，这样的代码会造成理解上的困难\n\n```js\nlet temp = 2 * (height + width); \nconsole.log(temp);\ntemp = height * width; \nconsole.log(temp);\n```\n\n↓\n\n```js\nconst perimeter = 2 * (height + width); \nconsole.log(perimeter);\nconst area = height * width; \nconsole.log(area);\n```\n\n- 字段改名\n\n对于命名不够良好的字段进行改名\n\n- 以查询取代派生变量\n\n使用查询封装变量是消除可变数据的第一步\n\n```js\nget discountedTotal() {return this._discountedTotal;} \nset discount(aNumber) {\n　const old = this._discount; \n　this._discount = aNumber; \n　this._discountedTotal += old - aNumber;\n}\n```\n\n↓\n\n```js\nget discountedTotal() {return this._baseTotal - this._discount;} \nset discount(aNumber) {this._discount = aNumber;}\n```\n\n- 将引用对象改为值对象\n\n如果非一定需要引用对象，使用值对象不可变的特性能避免很多问题\n\n- 将值对象改为引用对象\n\n如果一个对象需要在多个地方做更新，值对象就不适合了，需要改为引用\n\n### 简化条件逻辑\n\n- 分解条件表达式\n\n使用函数封装条件逻辑，提升代码的可理解性\n\n```js\nif (!aDate.isBefore(plan.summerStart) && !aDate.isAfter(plan.summerEnd)) \n　charge = quantity * plan.summerRate;\nelse\n　charge = quantity * plan.regularRate + plan.regularServiceCharge;\n```\n\n↓\n\n```js\nif (summer())\n　charge = summerCharge(); \nelse\n　charge = regularCharge();\n```\n\n- 合并条件表达式\n\n一些条件的返回值都相等，就将它们封装到同一个函数逻辑里面\n\n```js\nif (anEmployee.seniority < 2) return 0;\nif (anEmployee.monthsDisabled > 12) return 0;\nif (anEmployee.isPartTime) return 0;\n```\n\n↓\n\n```js\nif (isNotEligibleForDisability()) return 0; \n\nfunction isNotEligibleForDisability() {\n　return ((anEmployee.seniority < 2)\n　　　　　|| (anEmployee.monthsDisabled > 12)\n　　　　　|| (anEmployee.isPartTime));\n}\n```\n\n- 以卫语句取代嵌套条件表达式\n\n有时候单一出口原则，似乎不是那么重要\n\n```js\nfunction getPayAmount() { \n　let result;\n　if (isDead)\n　　result = deadAmount(); \n　else {\n　　if (isSeparated)\n　　　result = separatedAmount(); \n　　else {\n　　　if (isRetired)\n　　　　result = retiredAmount(); \n　　　else\n　　　　result = normalPayAmount();\n　　}\n　}\n　return result;\n}\n```\n\n↓\n\n```js\nfunction getPayAmount() {\n　if (isDead) return deadAmount();\n　if (isSeparated) return separatedAmount(); \n　if (isRetired) return retiredAmount(); \n　return normalPayAmount();\n}\n```\n\n- 以多态取代条件表达式\n\n如果发现一些行为适合用多态取代，试试这样重构它\n\n```js\nswitch (bird.type) {\n　case 'EuropeanSwallow': \n　　return \"average\";\n　case 'AfricanSwallow':\n　　return (bird.numberOfCoconuts > 2) ? \"tired\" : \"average\"; \n　case 'NorwegianBlueParrot':\n　　return (bird.voltage > 100) ? \"scorched\" : \"beautiful\"; \n　default:\n　　return \"unknown\";\n```\n\n↓\n\n```js\nclass EuropeanSwallow { \n　get plumage() {\n　　return \"average\";\n　}\nclass AfricanSwallow { \n　get plumage() {\n　　 return (this.numberOfCoconuts > 2) ? \"tired\" : \"average\";\n　}\nclass NorwegianBlueParrot { \n　get plumage() {\n　　 return (this.voltage > 100) ? \"scorched\" : \"beautiful\";\n}\n```\n\n- 引入特例\n\n所谓特例，就是满足这个类的行为，但却表达了特例的含义\n\n```js\nif (aCustomer === \"unknown\") customerName = \"occupant\";\n```\n\n↓\n\n```js\nclass UnknownCustomer {\n    get name() {return \"occupant\";}\n```\n\n- 引入断言\n\n断言提供了一种对系统当前状态的假设，对调试以及阅读很有帮助\n\n```js\nif (this.discountRate)\n  base = base - (this.discountRate * base);\n```\n\n↓\n\n```js\nassert(this.discountRate>= 0); \nif (this.discountRate)\n  base = base - (this.discountRate * base);\n```\n\n### 重构API\n\n- 查询函数和修改函数分离\n\n对于无副作用的函数，有助于测试\n\n```js\nfunction getTotalOutstandingAndSendBill() {\n  const result = customer.invoices.reduce((total, each) => each.amount + total, 0);\n  sendBill();\n  return result;\n}\n```\n\n↓\n\n```js\nfunction totalOutstanding() {\n  return customer.invoices.reduce((total, each) => each.amount + total, 0);\n}\nfunction sendBill() { \n  emailGateway.send(formatBill(customer));\n}\n```\n\n- 函数参数化\n\n本质还是消除重复，将函数名字中的参数提取到参数列表中\n\n```js\nfunction tenPercentRaise(aPerson) { \n  aPerson.salary = aPerson.salary.multiply(1.1);\n}\nfunction fivePercentRaise(aPerson) { \n  aPerson.salary = aPerson.salary.multiply(1.05);\n}\n```\n\n↓\n\n```js\nfunction raise(aPerson, factor) {\n  aPerson.salary = aPerson.salary.multiply(1 + factor);\n}\n```\n\n- 移除标记参数\n\n标记参数的存在会增加理解接口调用的难度\n\n```js\nfunction setDimension(name, value) { \n　if (name === \"height\") {\n　　this._height = value; \n　　return;\n　}\n　if (name === \"width\") { \n　　this._width = value; \n　　return;\n　}\n}\n```\n\n↓\n\n```js\nfunction setHeight(value) {this._height = value;} \nfunction setWidth (value) {this._width = value;}\n```\n\n- 保持对象完整\n\n传递整个对象能更好地应对未来的变化\n\n```js\nconst low = aRoom.daysTempRange.low; \nconst high = aRoom.daysTempRange.high; \nif (aPlan.withinRange(low, high))\n```\n\n↓\n\n```js\nif (aPlan.withinRange(aRoom.daysTempRange))\n```\n\n- 以查询取代参数\n\n参数列表尽量避免重复，参数列表越短越容易理解\n\n```js\navailableVacation(anEmployee, anEmployee.grade); \nfunction availableVacation(anEmployee, grade) {}\n```\n\n↓\n\n```js\navailableVacation(anEmployee)\n\nfunction availableVacation(anEmployee) {}\n```\n\n- 以参数取代查询\n\n上述操作的反向重构，如果不想函数依赖某个元素，那就使用这个方式\n\n- 移除设值函数\n\n取消设值函数，代表着数据不应该被修改的意图\n\n```js\nclass Person {\n  get name() {...}\n  set name(aString) {...}\n}\n```\n\n↓\n\n```js\nclass Person {\n  get name() {...}\n}\n```\n\n- 以工厂函数取代构造函数\n\n构造函数使用起来较不灵活，尝试把创建对象的职责交给工厂\n\n```js\nleadEngineer = new Employee(document.leadEngineer, 'E');\n```\n\n↓\n\n```js\nleadEngineer = createEngineer(document.leadEngineer);\n```\n\n- 以命名取代函数\n\n命令对象大都服务于单一的函数，命令相交于过程性代码，拥有了大部分面向对象的能力\n\n```js\nfunction score(candidate, medicalExam, scoringGuide) { \n  let result = 0;\n  let healthLevel = 0;\n  // long body code\n}\n```\n\n↓\n\n```js\nclass Scorer {\n  constructor(candidate, medicalExam, scoringGuide) { \n    this._candidate = candidate;\n    this._medicalExam = medicalExam; \n    this._scoringGuide = scoringGuide;\n  }\n\n  execute() { \n    this._result = 0;\n    this._healthLevel = 0;\n    // long body code\n  }\n}\n```\n\n- 以函数取代命令\n\n上述的反向重构，在不是很复杂的情况下，直接使用函数完成任务即可\n\n### 处理继承关系\n\n- 函数上移\n\n本质上还是为了避免重复，重复代码是滋生bug的温床\n\n```js\nclass Employee {...}\n\nclass Salesman extends Employee { \n　get name() {...}\n}\n\nclass Engineer extends Employee { \n　get name() {...}\n}\n```\n\n↓\n\n```js\nclass Employee { \n　get name() {...}\n}\n\nclass Salesman extends Employee {...} \nclass Engineer extends Employee {...}\n```\n\n- 字段上移\n\n同上，函数换成字段\n\n- 构造函数本体上移\n\n将子类里的共同行为提取到父类\n\n```js\nclass Party {...}\n\nclass Employee extends Party { \n　constructor(name, id, monthlyCost) {\n　　super(); \n　　this._id = id;\n　　this._name = name; \n　　this._monthlyCost = monthlyCost;\n　}\n}\n```\n\n↓\n\n```js\nclass Party { \n　constructor(name){\n　　this._name = name;\n　}\n}\n\nclass Employee extends Party { \n　constructor(name, id, monthlyCost) {\n　　super(name); \n　　this._id = id;\n　　this._monthlyCost = monthlyCost;\n　}\n}\n```\n\n- 函数下移\n\n函数上移的反向重构，如果超类的某个函数只与部分子类有关，那就需要将函数下移\n\n- 字段下移\n\n字段上移的反向重构，动机同上\n\n- 以子类取代类型码\n\n使用多态来替代逻辑判断\n\n```js\nfunction createEmployee(name, type) { \n  return new Employee(name, type);\n}\n```\n\n↓\n\n```js\nfunction createEmployee(name, type) { \n  switch (type) {\n    case \"engineer\": return new Engineer(name); \n    case \"salesman\": return new Salesman(name); \n    case \"manager\": return new Manager (name);\n}\n```\n\n- 移除子类\n\n随着代码演进，子类压根就不需要了\n\n```js\nclass Person {\n　get genderCode() {return \"X\";}\n}\nclass Male extends Person {\n　get genderCode() {return \"M\";}\n}\nclass Female extends Person { \n　get genderCode() {return \"F\";}\n}\n```\n\n↓\n\n```js\nclass Person {\n  get genderCode() {return this._genderCode;}\n}\n```\n\n- 提炼超类\n\n如果两个类再做相似的事，利用继承机制将它们的相似之处进行提炼\n\n```js\nclass Department {\n　get totalAnnualCost() {...} \n　get name() {...}\n　get headCount() {...}\n}\n\nclass Employee {\n　get annualCost() {...}\n　get name() {...}\n　get id() {...}\n}\n```\n\n↓\n\n```js\nclass Party {\n　get name() {...}\n　get annualCost() {...}\n}\n\nclass Department extends Party { \n　get annualCost() {...}\n　get headCount() {...}\n}\n\nclass Employee extends Party { \n　get annualCost() {...}\n　get id() {...}\n}\n```\n\n- 折叠继承体系\n\n随着继承体系演化，一个类与其超类已经没有多大区别\n\n```js\nclass Employee {...}\nclass Salesman extends Employee {...}\n```\n\n↓\n\n```js\nclass Employee {...}\n```\n\n- 以委托取代子类\n\n继承会给子类带来极大的耦合，父类的任何修改都会影响到子类，使用委托就是一种组合关系，在任何情况下，组合应该优先于继承\n\n```js\nclass Order {\n　get daysToShip() {\n　　return this._warehouse.daysToShip;\n　}\n}\n\nclass PriorityOrder extends Order { \n　get daysToShip() {\n　　return this._priorityPlan.daysToShip;\n　}\n}\n```\n\n↓\n\n```js\nclass Order {\n　get daysToShip() {\n　　return (this._priorityDelegate)\n　　　? this._priorityDelegate.daysToShip\n　　　: this._warehouse.daysToShip;\n　}\n}\n\nclass PriorityOrderDelegate { \n　get daysToShip() {\n　　return this._priorityPlan.daysToShip\n　}\n}\n```\n\n- 以委托取代超类\n\n如果父类的一些接口不适合让子类暴露，那么这个类应该就通过组合的方式复用\n\n```js\nclass List {...}\nclass Stack extends List {...}\n```\n\n↓\n\n```js\nclass Stack { \n  constructor() {\n    this._storage = new List();\n  }\n}\nclass List {...}\n```\n\n### 速查表\n\n<table> \n <thead> \n  <tr> \n   <th> <p>坏味道（英文）</p> </th> \n   <th> <p>坏味道（中文）</p> </th> \n   <th> <p>页码</p> </th> \n   <th> <p>常用重构</p> </th> \n  </tr> \n </thead> \n <tbody> \n  <tr> \n   <td> <p>Alternative Classes with Different Interfaces</p> </td> \n   <td> <p>异曲同工的类</p> </td> \n   <td> <p>83</p> </td> \n   <td> <p>改变函数声明（124），搬移函数（198），提炼超类（375）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Comments</p> </td> \n   <td> <p>注释</p> </td> \n   <td> <p>84</p> </td> \n   <td> <p>提炼函数（106），改变函数声明（124），引入断言（302）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Data Class</p> </td> \n   <td> <p>纯数据类</p> </td> \n   <td> <p>83</p> </td> \n   <td> <p>封装记录（162），移除设值函数（331），搬移函数（198），提炼函数（106），拆分阶段（154）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Data Clumps</p> </td> \n   <td> <p>数据泥团</p> </td> \n   <td> <p>78</p> </td> \n   <td> <p>提炼类（182），引入参数对象（140），保持对象完整（319）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Divergent Change</p> </td> \n   <td> <p>发散式变化</p> </td> \n   <td> <p>76</p> </td> \n   <td> <p>拆分阶段（154），搬移函数（198），提炼函数（106），提炼类（182）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Duplicated Code</p> </td> \n   <td> <p>重复代码</p> </td> \n   <td> <p>72</p> </td> \n   <td> <p>提炼函数（106），移动语句（223），函数上移（350）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Feature Envy</p> </td> \n   <td> <p>依恋情结</p> </td> \n   <td> <p>77</p> </td> \n   <td> <p>搬移函数（198），提炼函数（106）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Global Data</p> </td> \n   <td> <p>全局数据</p> </td> \n   <td> <p>74</p> </td> \n   <td> <p>封装变量（132）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Insider Trading</p> </td> \n   <td> <p>内幕交易</p> </td> \n   <td> <p>82</p> </td> \n   <td> <p>搬移函数（198），搬移字段（207），隐藏委托关系（189），以委托取代子类（381），以委托取代超类（399）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Large Class</p> </td> \n   <td> <p>过大的类</p> </td> \n   <td> <p>82</p> </td> \n   <td> <p>提炼类（182），提炼超类（375），以子类取代类型码（362）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Lazy Element</p> </td> \n   <td> <p>冗赘的元素</p> </td> \n   <td> <p>80</p> </td> \n   <td> <p>内联函数（115），内联类（186），折叠继承体系（380）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Long Function</p> </td> \n   <td> <p>过长函数</p> </td> \n   <td> <p>73</p> </td> \n   <td> <p>提炼函数（106），以查询取代临时变量（178），引入参数对象（140），保持对象完整（319），以命令取代函数（337），分解条件表达式（260），以多态取代条件表达式（272），拆分循环（227）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Long Parameter List</p> </td> \n   <td> <p>过长参数列</p> </td> \n   <td> <p>74</p> </td> \n   <td> <p>以查询取代参数（324），保持对象完整（319），引入参数对象（140），移除标记参数（314），函数组合成类（144）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Loops</p> </td> \n   <td> <p>循环语句</p> </td> \n   <td> <p>79</p> </td> \n   <td> <p>以管道取代循环（231）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Message Chains</p> </td> \n   <td> <p>过长的消息链</p> </td> \n   <td> <p>81</p> </td> \n   <td> <p>隐藏委托关系（189），提炼函数（106），搬移函数（198）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Middle Man</p> </td> \n   <td> <p>中间人</p> </td> \n   <td> <p>81</p> </td> \n   <td> <p>移除中间人（192），内联函数（115），以委托取代超类（399），以委托取代子类（381）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Mutable Data</p> </td> \n   <td> <p>可变数据</p> </td> \n   <td> <p>75</p> </td> \n   <td> <p>封装变量（132），拆分变量（240），移动语句（223），提炼函数（106），将查询函数和修改函数分离（306），移除设值函数（331），以查询取代派生变量（248），函数组合成类（144），函数组合成变换（149），将引用对象改为值对象（252）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Mysterious Name</p> </td> \n   <td> <p>神秘命名</p> </td> \n   <td> <p>72</p> </td> \n   <td> <p>改变函数声明（124），变量改名（137），字段改名（244）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Primitive Obsession</p> </td> \n   <td> <p>基本类型偏执</p> </td> \n   <td> <p>78</p> </td> \n   <td> <p>以对象取代基本类型（174），以子类取代类型码（362），以多态取代条件表达式（272），提炼类（182），引入参数对象（140）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Refused Bequest</p> </td> \n   <td> <p>被拒绝的遗赠</p> </td> \n   <td> <p>83</p> </td> \n   <td> <p>函数下移（359），字段下移（361），以委托取代子类（381），以委托取代超类（399）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Repeated Switches</p> </td> \n   <td> <p>重复的switch</p> </td> \n   <td> <p>79</p> </td> \n   <td> <p>以多态取代条件表达式（272）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Shotgun Surgery</p> </td> \n   <td> <p>霰弹式修改</p> </td> \n   <td> <p>76</p> </td> \n   <td> <p>搬移函数（198），搬移字段（207），函数组合成类（144），函数组合成变换（149），拆分阶段（154），内联函数（115），内联类（186）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Speculative Generality</p> </td> \n   <td> <p>夸夸其谈通用性</p> </td> \n   <td> <p>80</p> </td> \n   <td> <p>折叠继承体系（380），内联函数（115），内联类（186），改变函数声明（124），移除死代码（237）</p> </td> \n  </tr> \n  <tr> \n   <td> <p>Temporary Field</p> </td> \n   <td> <p>临时字段</p> </td> \n   <td> <p>80</p> </td> \n   <td> <p>提炼类（182），搬移函数（198），引入特例（289）</p> </td> \n  </tr> \n </tbody> \n</table>","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}