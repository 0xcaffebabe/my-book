{"content":"# 内存模型\n\n- 面向并发\n\n## Goroutine\n\nGoroutine采用的是半抢占式的协作调度，只有在当前Goroutine发生阻塞时才会导致调度，且调度发生在用户态，所以Goroutine是一种比线程更加轻量的玩意\n\n## 原子操作\n\n- 锁实现\n\n```go\nvar ai struct {\n\tsync.Mutex\n\tvalue int\n}\n\nfunc main() {\n\tgo worker();\n\tgo worker();\n}\n\nfunc worker(){\n\tai.Lock();\n\tai.value += 1;\n\tai.Unlock();\n}\n```\n\n这种方式比较繁琐且效率低，标准库的sync/atomic包对原子操作提供了丰富的支持\n\n## 顺序一致性内存模型\n\n同JVM 在Go语言中 编译器也会进行乱序优化 \n\n但Go保证在同一个Goroutine中不会乱序\n\n## 基于Channel的通信\n\nChannel通信是在Goroutine之间进行同步的主要方法，无缓存的Channel上的发送操作总在对应的接收操作完成前发生\n\n```go\nvar done = make(chan bool)\nvar msg string\nfunc aGoroutine() {\n\tmsg = \"你好, 世界\"\n\tdone <- true\n}\n\nfunc main() {\n\tgo aGoroutine()\n\t<-done\n\tprintln(msg)\n}\n```\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}