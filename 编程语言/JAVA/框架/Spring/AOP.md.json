{"content":"# AOP\n\n## 动态代理\n\n- 基于接口 JDK\n- 基于子类\n\n```java\npublic class Main {\n\n    public static void main(String[] args) {\n        Bean bean = (Bean) Enhancer.create(Bean.class, new MethodInterceptor() {\n            private Bean bean = new Bean();\n            @Override\n            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n                System.out.println(method);\n                return method.invoke(bean,objects);\n            }\n        });\n\n        bean.run();\n    }\n}\n\nclass Bean{\n    public void run(){\n        System.out.println(\"bean run\");\n    }\n}\n```\n\n## AOP简介\n\n![20211520172](/assets/20211520172.png)\n\nAOP术语:\n\n- 通知(Advice):所谓通知是指拦截到Joinpoint之后所要做的事情就是通知\n\n  - 前置通知（before）:执行前执行\n  - 后置通知（after）：执行后执行\n  - 返回通知（after returning）\n  - 异常通知（after throwing）\n  - 环绕通知（around）\n\n_使用xml时，后置通知与返回通知以及异常通知的执行顺序取决于配置顺序_\n\n- 连接点(Joinpoint):所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法,因为spring只支持方法类型的连接点。\n- 切点(Pointcut):所谓切入点是指我们要对哪些Joinpoint进行拦截的定义。\n- 切面(Aspect):是切入点和通知（引介）的结合。\n- 引入(Introduction):引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field。\n- 织入(Weaving):是指把增强应用到目标对象来创建新的代理对象的过程。\n\n### 编写切点\n\n- AspectJ指示器\n\nSpring借助AspectJ的切点表达式语言来定义切面\n\nAspectJ指示器  | 描述\n----------- | ----------------------------------------------------\narg()       | 限制连接点匹配参数为指定类型的执行方法\n@args()     | 限制连接点匹配参数由指定注解标注的执行方法\nexecution() | 用于匹配是连接点的执行方法\nthis()      | 限制连接点匹配AOP代理的Bean引用为指定类型的类\ntarget()    | 限制连接点匹配目标对象为指定类型的类\n@target ()  | 限制连接点匹配特定的执行对象，这些对象对应的类要具备指定类型的注解\nwithin()    | 限制连接点匹配指定的类型\n@within()   | 限制连接点匹配指定注解所标注的类型( 当使用Spring AOP时，方法定义在由指定的注解所标注的类里)\n@annotation | 限制匹配带有指定注解连接点\n\n- 一个简单的切点实例\n\n```\nexecution(* wang.ismy.spring.service.Service.doSth(..))\n```\n\n#### execution\n\n![](https://img2018.cnblogs.com/blog/475392/201810/475392-20181031104431559-1365885037.png)\n\n### 创建切面\n\n```java\n@Aspect\n@Component\n@Slf4j\npublic class ErrorPageAspect {\n\n    @Pointcut(\"@annotation(wang.ismy.zbq.annotations.ErrorPage)\")\n    public void pointCut(){}\n\n    @Around(\"pointCut()\")\n    public Object around(ProceedingJoinPoint joinPoint){\n        try {\n            return joinPoint.proceed();\n        } catch (Throwable throwable) {\n\n            ModelAndView modelAndView = new ModelAndView();\n            modelAndView.setViewName(\"error\");\n            modelAndView.addObject(\"error\",throwable.getMessage());\n\n            return modelAndView;\n        }\n\n    }\n}\n```\n\n#### 使用xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <aop:config>\n        <!--配置切面-->\n        <aop:aspect id=\"loggerAdvice\" ref=\"logger\">\n            <aop:around method=\"log\" pointcut=\"execution(* wang.ismy.spring.service.Service.doSth(..))\"/>\n        </aop:aspect>\n    </aop:config>\n\n    <bean class=\"wang.ismy.spring.service.impl.ServiceImpl\"/>\n    <bean id=\"logger\" class=\"wang.ismy.spring.Logger\"/>\n</beans>\n```\n\n## AOP 原理\n\nAbstractAutoProxyCreator 实现了BeanPostProcessor \n\n通过在Bean 实例化后，通过动态代理的方式 createProxy 对 Bean进行一层包裹 返回代理完成后的Bean\n\nAopProxy 目前Spring 有2种方式 ...\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}