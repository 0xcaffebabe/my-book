{"content":"# Bean 注册\n\nSpring的配置方案\n\n- XML\n- JAVA\n- 自动装配\n\n## 自动化装配\n\n自动化装配指的是通过一系列描述性代码，描述Bean对象之间的依赖关系，从而交由Spring自动组装出来，目前有两种方式：\n\n- 组件扫描\n- 自动装配\n\n### @Component注解\n\n```java\n@Component // 将当前类对象存入容器\npublic class Tea {...}\n```\n\nSpring自动注入\n\n```java\n@Component\n  public class Cup {\n\n    private Tea tea;\n\n    @Autowired\n    public Cup(Tea tea) {\n        this.tea = tea;\n    }\n  }\n```\n\n其他功能一样，但语义不同的注解：\n\n- @Controller\n- @Service\n- @Repository\n\n### @ComponentScan注解\n\n创建一个组件扫描配置：\n\n```java\n@ComponentScan(basePackages = \"wang.ismy.spring\")\npublic class Config {}\n```\n\n#### 指定扫描策略\n\n```java\n@ComponentScan(value = \"*\",\n        excludeFilters = {\n                @Filter(type = FilterType.ANNOTATION,\n                        classes = {Controller.class, Repository.class}),\n                @Filter(type = FilterType.ASSIGNABLE_TYPE, classes = User.class)\n        })\n```\n\n1. 根据注解来排除（type = FilterType.ANNOTATION）,这些注解的类型为classes = {Controller.class, Repository.class}。即Controller和Repository注解标注的类不再被纳入到IOC容器中。\n\n2. 根据指定类型类排除（type = FilterType.ASSIGNABLE_TYPE），排除类型为User.class，其子类，实现类都会被排除。\n\n#### 自定义扫描策略\n\n```java\n@ComponentScan(value = \"*\",\n        excludeFilters = {\n            @Filter(type = FilterType.CUSTOM, classes = MyTypeFilter.class)\n        })\n...\npublic class MyTypeFilter implements TypeFilter {\n    @Override\n    public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) {...}\n}\n```\n\n### 获取context使用bean\n\n```java\nAnnotationConfigApplicationContext context = \n                new AnnotationConfigApplicationContext(Config.class);\ncontext.getBean(Bean.class).say();\n```\n\n### 处理自动装配歧义性\n\n- @Resource注解：使用该注解可以直接指定bean name，该注解非spring提供\n\n- 标示首选bean @Primary注解\n\n```java\n@Bean\n@Primary // 当有多个可选项时，将优先使用这个bean\npublic Bean1 bean1(){\n    Bean1 bean1 = new Bean1();\n    bean1.setName(\"pro\");\n    return bean1;\n}\n```\n\n- 限定自动装配的bean\n\n```java\n@Autowired\n@Qualifier(\"bean1f\") // 当有多个可选项时，将使用名为bean1f的bean\npublic void setBean1(Bean1 bean1){}\n```\n\n*@Qualifier也可以用在方法参数上*\n\n## 导入\n\n```java\n@ImportResource(\"classpath:spring.xml\") // 导入xml配置\n@Import(Config.class) // 导入java代码配置\n@Import(MyImportSelector.class) // 自定义导入策略\npublic class Config {}\n\npublic class MyImportSelector implements ImportSelector {\n    @Override\n    public String[] selectImports(AnnotationMetadata importingClassMetadata) {\n        return new String[]{\n                \"*\",\n                \"*\",\n                \"*\"\n        };\n    }\n}\n```\n\n## 使用FactoryBean注册组件\n\n```java\npublic class CherryFactoryBean implements FactoryBean<Cherry> {\n    @Override\n    public Cherry getObject() {\n        return new Cherry();\n    }\n\n    @Override\n    public Class<?> getObjectType() {\n        return Cherry.class;\n    }\n\n    @Override\n    public boolean isSingleton() {\n        return false;\n    }\n}\n```\n\n如果我们要获取cherryFactoryBean本身，则可以这样做：\n\n```java\ncontext.getBean(\"&cherryFactoryBean\");\n```\n\n## @Profile\n\n通过编写不同的profile，以此达到切换不同的profile，装配不同Bean的功能\n\n- 手动编写不同profile的配置\n\n```java\n@Configuration\n@Profile(\"pro\")\npublic class Config1 {\n  @Bean\n  public Bean1 bean1(){\n      Bean1 bean1 = new Bean1();\n      bean1.setName(\"pro\");\n      return bean1;\n  }\n}\n```\n```java\n@Configuration\n@Profile(\"dev\")\npublic class Config {\n  @Bean\n  public Bean1 bean1(){\n      Bean1 bean1 = new Bean1();\n      bean1.setName(\"dev\");\n      return bean1;\n  }\n}\n```\n\n- 激活profile\n\n```java\nSystem.setProperty(\"spring.profiles.active\",\"pro\");\nAnnotationConfigApplicationContext context =\n        new AnnotationConfigApplicationContext(MasterConfig.class);\ncontext.getBean(Bean1.class).run();\n```\n\n## 条件化装配\n\n@Conditional注解\n\n```java\n@Bean\n  @Conditional(MyConditional.class)\n  public Bean1 bean1(){\n      Bean1 bean1 = new Bean1();\n      bean1.setName(\"pro\");\n      return bean1;\n  }\n```\n\n只要自定实现Condition接口，就可以控制bean的装配：\n\n```java\npublic class MyConditional implements Condition {\n\n  @Override\n  public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {\n      // ...\n      return true;\n  }\n}\n```\n\n## JAVA代码装配\n\n由于某些类来源于外部，我们无法修改其源码如在类上加上@Component注解来注入容器，所以可以使用java代码的方式创建后注入\n\n```java\n@Configuration\npublic class Config {\n\n    @Bean // 默认值是方法名称\n    public wang.ismy.spring.Bean bean(Bean1 bean1){return new wang.ismy.spring.Bean(bean1);}\n\n    @Bean\n    public Bean1 bean1(){return new Bean1();}\n}\n```\n\n## 作用域\n\n- singleton：单例\n- prototype：每次获取都会创建实例\n- session：每个会话一个bean\n- request：每个请求一个bean\n- global session：应用在Portlet环境.如果没有Portlet环境那么globalSession相当于session\n\n### 使用\n\n```java\n@Component\n@Scope(\"prototype\")\npublic class Bean { }\n```\n\n```xml\n<bean scope=\"prototype\" class=\"wang.ismy.spring.Bean\"/>\n```\n\n### 懒加载@Lazy\n\n使用该注解后，Bean只有在真正需要时才会被初始化，而非在容器启动后就被初始化\n\n## 使用XML配置\n\n由于spring早期大量使用xml来配置，所以这节的内容还是需要了解一下的。 不过对于新项目，还是推荐使用注解或者java配置\n\n- 创建一个xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n</beans>\n```\n\n- 创建一个bean\n\n```xml\n<!--方式1-->\n<bean class=\"wang.ismy.spring.Bean\"/>\n<!--方式2：普通工厂创建-->\n<bean id=\"factory\" class=\"wang.ismy.spring.Factory\"/>\n<bean factory-bean=\"factory\" factory-method=\"get\"/>\n<!--方式3：静态工厂-->\n<bean class=\"wang.ismy.spring.Factory\" factory-method=\"get\"/>\n```\n\n- 生命周期方法回调\n\n```xml\n<!--只有作用范围是单例时destroy才会被调用-->\n<bean scope=\"singleton\" class=\"wang.ismy.spring.Bean\" \ninit-method=\"init\" destroy-method=\"destroy\"/>\n```\n\n- 属性注入\n\n```java\npublic class Bean1 {\n\n    private String name;\n\n    public void setName(String name){ this.name = name;}\n}\n```\n\n```xml\n<bean class=\"wang.ismy.spring.Bean1\">\n        <property name=\"name\" value=\"hello\"/>\n</bean>\n```\n\n- 构造器注入\n\n  - constructor-arg标签\n\n    - index:指定参数在构造函数参数列表的索引位置\n    - type:指定参数在构造函数中的数据类型\n    - name:指定参数在构造函数中的名称\n    - value:它能赋的值是基本数据类型和String类型\n    - ref:它能赋的值是其他bean类型，也就是说，必须得是在配置文件中配置过的bean\n\n```xml\n<bean class=\"wang.ismy.spring.Bean\">\n    <constructor-arg name=\"name\" value=\"abc\"/>\n    <constructor-arg name=\"value\" value=\"-1\"/>\n</bean>\n\n<bean name=\"bean1\" class=\"wang.ismy.spring.Bean1\"/>\n<bean class=\"wang.ismy.spring.Bean\">\n    <constructor-arg ref=\"bean1\"/>\n</bean>\n```\n\n- 集合注入\n\n```xml\n<bean class=\"wang.ismy.spring.Bean\">\n        <!--注入数组-->\n        <property name=\"array\">\n            <array> <value>AAA</value> <value>BBB</value> <value>CCC</value> </array>\n        </property>\n        <!--注入集合-->\n        <property name=\"set\">\n            <set> <value>AAA</value> <value>BBB</value> <value>CCC</value> </set>\n        </property>\n        <!--注入list-->\n        <property name=\"list\">\n            <list> <value>AAA</value> <value>BBB</value> <value>CCC</value> </list>\n        </property>\n        <!--注入map-->\n        <property name=\"map\">\n            <map>\n                <entry key=\"a\" value=\"a\"/>\n                <entry key=\"b\" value=\"b\"/>\n            </map>\n        </property>\n        <!--注入properties-->\n        <property name=\"prop\">\n            <props>\n                <prop key=\"a\">a</prop>\n                <prop key=\"b\">b</prop>\n            </props>\n        </property>\n    </bean>\n```\n\n- 使用xml配置运行：\n\n```java\nClassPathXmlApplicationContext context =\n                new ClassPathXmlApplicationContext(\"classpath:spring.xml\");\ncontext.getBean(Bean1.class).run();\n```\n\n## 运行时值注入\n\n```java\n@Configuration\n@ComponentScan(basePackages = \"wang.ismy.spring\")\n@PropertySource(\"classpath:config.properties\")\npublic class Config { }\n```\n\nconfig.properties\n\n```properties\nname=my\n```\n\n```java\n@Component\npublic class Bean {\n  @Value(\"${name}\")\n  String name;\n}\n```\n\n### Spring EL表达式\n\n- 使用\n\n```java\n@Component\npublic class Bean {\n  @Value(\"#{T(System).currentTimeMillis()}\")\n  long time;\n\n  public void run(){\n      System.out.println(time);\n  }\n}\n```\n\n## 循环依赖\n\n当一个对象依赖的对象间接或直接又依赖其本身时，就是循环依赖。\n\n针对于这种依赖情况，对于属性注入或者方法注入，Spring通过先创建对象实例，后填充其属性的方式来解决循环依赖，但对于通过构造器注入的情况，Spring则无法解决。\n\n![202153193741](/assets/202153193741.svg)\n\n![202153193815](/assets/202153193815.svg)\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}