{"content":"# JUint\n\n## 4\n\n- 白盒测试\n- 黑盒测试\n\n```java\n    @Test\n    public void test(){\n        Assert.assertEquals(1,1);\n    }\n```\n\n- @Before\n- @After\n\n## 5\n\n组成：\n\n- JUint Platform 用于在JVM上启动测试框架\n- JUint Jupiter 5版本的全新编程模型与扩展机制\n- JUint Vintage 兼容3和4\n\n注解                 | 释义\n------------------ | ----------------------------------------------------------------------------------------------------------------\n@Test              | 注明一个方法是测试方法，JUnit 框架会在测试阶段自动找出所有使用该注解标明的测试方法并运行。需要注意的是，在JUnit5版本中，取消了该注解的timeout参数的支持\n@TestFactory       | 注明一个方法是基于数据驱动的动态测试数据源\n@ParameterizedTest | 注明一个方法是测试方法，这一点同@Test注解作用一样。此外，该注解还可以让一个测试方法使用不同的入参运行多次\n@RepeatedTest      | 从字面意思就可以看出，这个注释可以让测试方法自定义重复运行次数\n@BeforeEach        | 与JUnit4中的@Before类似，可以在每一个测试方法运行前， 都运行个指定的方法。在JUnit5中，除了运行@Test注解的方法，还额外支持运行@ParameterizedTest和@RepeatedTest注解的方法\n@AfterEach         | 与JUnit4中的@Afer类似，可以在每一个测试方法运行后，都运行一个指定的方法。在JUnit5中，除了运行@Test注解的方法，还额外支持运行@ParameterizedTest 和@ RepeatedTest注解的方法\n@BeforeAll         | 与JUni4中的@BeforeClass 类似，可以在每一个测试类运行前，都运行一个指定的方法\n@AfterAll          | 与JUnit4中的@AfterClass 类似，可以在每一个测试类运行后， 都运行一个指定的方法\n@Disabled          | 与JUnit4中的@lgnore 类似，注明一个测试的类或方法不再运行\n@Nested            | 为测试添加嵌套层级，以便组织用例结构\n@Tag               | 为测试类或方法添加标签，以便有选择性地执行\n\n命名：\n\nshoud...when...\n\n流式断言：\n\nAssertJ\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}