{"content":"# Hibernate\n\n>Hibernate 是由 Gavin King 于 2001 年创建的开放源代码的对象关系框架。它强大且高效的构建具有关系对象持久性和查询服务的 Java 应用程序。\nHibernate 将 Java 类映射到数据库表中，从 Java 数据类型中映射到 SQL 数据类型中\n\n## 架构\n\n![202022916348](/assets/202022916348.jpg)\n\n## 配置\n\n### ORM元数据配置\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE hibernate-mapping PUBLIC\n        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n        \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\">\n<!-- 配置表与实体对象的关系 -->\n<!-- package属性:填写一个包名.在元素内部凡是需要书写完整类名的属性,可以直接写简答类名了. -->\n<hibernate-mapping package=\"wang.ismy.hibernate.entity\" >\n    <!--\n        class元素: 配置实体与表的对应关系的\n            name: 完整类名\n            table:数据库表名\n     -->\n    <class name=\"Book\" table=\"tb_book\" >\n        <!-- id元素:配置主键映射的属性\n                name: 填写主键对应属性名\n                column(可选): 填写表中的主键列名.默认值:列名会默认使用属性名\n                type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型.\n                        每个类型有三种填法: java类型|hibernate类型|数据库类型\n                not-null(可选):配置该属性(列)是否不能为空. 默认值:false\n                length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度\n         -->\n        <id name=\"bid\">\n            <!-- generator:主键生成策略 -->\n            <generator class=\"native\"/>\n        </id>\n        <!-- property元素:除id之外的普通属性映射\n                name: 填写属性名\n                column(可选): 填写列名\n                type(可选):填写列(属性)的类型.hibernate会自动检测实体的属性类型.\n                        每个类型有三种填法: java类型|hibernate类型|数据库类型\n                not-null(可选):配置该属性(列)是否不能为空. 默认值:false\n                length(可选):配置数据库中列的长度. 默认值:使用数据库类型的最大长度\n         -->\n        <property name=\"bname\" column=\"bname\" >\n            <!--  <column name=\"bname\" sql-type=\"varchar\" ></column> -->\n        </property>\n        <property name=\"bauthor\" column=\"bauthor\"/>\n\n    </class>\n</hibernate-mapping>\n```\n\n### 主配置\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE hibernate-configuration PUBLIC\n\t\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n\t\"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\">\n<hibernate-configuration>\n\t<session-factory>\n\n\t\t <!-- 数据库驱动 -->\n\t\t<property name=\"hibernate.connection.driver_class\">com.mysql.cj.jdbc.Driver</property>\n\t\t <!-- 数据库url -->\n\t\t<property name=\"hibernate.connection.url\">jdbc:mysql:///hibernate?characterEncoding=utf8</property>\n\t\t <!-- 数据库连接用户名 -->\n\t\t<property name=\"hibernate.connection.username\">root</property>\n\t\t <!-- 数据库连接密码 -->\n\t\t<property name=\"hibernate.connection.password\">123</property>\n\t\t<!-- 数据库方言\n\t\t\t不同的数据库中,sql语法略有区别. 指定方言可以让hibernate框架在生成sql语句时.针对数据库的方言生成.\n\t\t\tsql99标准: DDL 定义语言  库表的增删改查\n\t\t\t\t\t  DCL 控制语言  事务 权限\n\t\t\t\t\t  DML 操纵语言  增删改查\n\t\t\t注意: MYSQL在选择方言时,请选择最短的方言.\n\t\t -->\n\t\t<property name=\"hibernate.dialect\">org.hibernate.dialect.MySQLDialect</property>\n\t\t\n\t\t\n\t\t<!-- #hibernate.show_sql true \n\t\t\t #hibernate.format_sql true\n\t\t-->\n\t\t<!-- 将hibernate生成的sql语句打印到控制台 -->\n\t\t<property name=\"hibernate.show_sql\">true</property>\n\t\t<!-- 将hibernate生成的sql语句格式化(语法缩进) -->\n\t\t<property name=\"hibernate.format_sql\">true</property>\n\t\t<!-- \n\t\t## auto schema export  自动导出表结构. 自动建表\n\t\t#hibernate.hbm2ddl.auto create\t\t自动建表.每次框架运行都会创建新的表.以前表将会被覆盖,表数据会丢失.(开发环境中测试使用)\n\t\t#hibernate.hbm2ddl.auto create-drop 自动建表.每次框架运行结束都会将所有表删除.(开发环境中测试使用)\n\t\t#hibernate.hbm2ddl.auto update(推荐使用) 自动生成表.如果已经存在不会再生成.如果表有变动.自动更新表(不会删除任何数据).\n\t\t#hibernate.hbm2ddl.auto validate\t校验.不自动生成表.每次启动会校验数据库中表是否正确.校验失败.\n\t\t -->\n\t\t<property name=\"hibernate.hbm2ddl.auto\">update</property>\n\n\t\t<mapping resource=\"Book.hbm.xml\" />\n\t\t\n\t</session-factory>\n</hibernate-configuration>\n```\n\n### 使用\n\n```java\n// 加载配置文件\nConfiguration cfg = new Configuration().configure(\"hibernate.cfg.xml\");\n// 创建核心对象session的工厂\nSessionFactory factory = cfg.buildSessionFactory();\n// 获得session\nSession session = factory.openSession();\n// 开启事务\nTransaction tx = session.beginTransaction();\n\nBook book = new Book();\nbook.setBname(\"JAVASCRIPT hight level program\");\nbook.setBauthor(\"nigolas\");\n\n// 保存对象\nsession.save(book);\n// 提交事务\ntx.commit();\n// 关闭会话\nsession.close();\nfactory.close();\n```\n\n```java\n// 根据ID查询\nsession.get(Book.class, 6)\n\n// 根据ID修改\nBook book = session.get(Book.class, 6);\nbook.setBauthor(\"cxk\");\nsession.update(book);\n\n// 根据ID删除\nBook book = session.get(Book.class, 6);\nsession.delete(book);\n```\n\n```java\n// 回滚事务\ntx.rollback();\n```\n\n## 实体\n\n### 实体类注意事项\n\n- 持久类提供无参数构造方法\n- 成员变量私有,提供有get/set方法访问.需提供属性\n- 持久化类中的属性,应尽量使用包装类型\n- 持久化类需要提供id.与数据库中的主键列对应\n- 不要用final修饰class\n\n### 主键类型\n\n- 自然主键\n  - 表的业务列中,有某业务列符合,必须有,并且不重复的特征时,该列可以作为主键使用.\n- 代理主键\n  - 表的业务列中,没有某业务列符合,必须有,并且不重复的特征时,创建一个没有业务意义的列作为主键\n\n### 主键生成策略\n\n#### 代理主键\n\nidentity : 主键自增.由数据库来维护主键值.录入时不需要指定主键.\nsequence: Oracle中的主键生成策略.\nincrement(了解): 主键自增.由hibernate来维护.每次插入前会先查询表中id最大值.+1作为新主键值.\nhilo(了解): 高低位算法.主键自增.由hibernate来维护.开发时不使用.\nnative:hilo+sequence+identity 自动三选一策略.\nuuid: 产生随机字符串作为主键. 主键类型必须为string 类型.\n\n#### 自然主键\n\nassigned:自然主键生成策略. hibernate不会管理主键值.由开发人员自己录入.\n\n## 对象状态\n\n- 瞬时状态\n  - 没有ID，没有在session缓存中\n- 持久化状态\n  - 有id,在session缓存中\n  - 持久化对象的变化会同步到数据库中\n- 游离|托管状态\n  - 有id,没有在session缓存中\n\n```java\nBook book = new Book(); // 瞬时状态\nbook.setBauthor(\"unknown\"); // 瞬时状态\n\nsession.save(book); // 持久化状态\ntx.commit();\n// 关闭会话\nsession.close(); // 游离|托管状态\n```\n\n![批注 2020-03-02 102153](/assets/批注%202020-03-02%20102153.png)\n\n## 一级缓存\n\n```java\nBook book = session.get(Book.class, 1);\nBook book1 = session.get(Book.class, 1);\nSystem.out.println(book == book1); // true\n```\n\n### 快照\n\n```java\nBook book = session.get(Book.class, 1);\nbook.setBname(\"java learning\"); \ntx.commit(); // 与快照中对象进行对比，如果对象发生改变，则更新对象\n```\n\n## 事务\n\n### 设置事务隔离级别\n\n```xml\n<!--\t1|2|4|8\n\t0001 1 读未提交\n\t0010 2 读已提交\n\t0100 4 可重复读\n\t1000 8 串行化\n-->\n<property name=\"hibernate.connection.isolation\">4</property>\n```\n\n### 在项目中管理事务\n\n- 获取线程绑定session\n\n```xml\n<!-- 需要配置session上下文 -->\n<property name=\"current_session_context_class\">thread</property>\n```\n\n```java\n// 获取线程绑定session\n// 注意，线程绑定的session事务提交后会自动关闭\nSession session = factory.getCurrentSession();\n```\n\n## 其他方式查询\n\n### HQL查询\n\n```java\nString hql = \"FROM Book\";\nQuery<Book> query = session.createQuery(hql,Book.class);\nSystem.out.println(query.list());\n```\n\n```sql\n-- 条件查询\nFROM Book where bauthor='unknown'\n-- 排序\nFROM Book ORDER BY bid DESC\n-- 投影\nSELECT bname FROM Book\n-- 投影封装对象\nSELECT new Book(bname) FROM Book\n-- 连接Book与Author\nFROM Book b INNER JOIN fetch b.authors\n```\n\n```java\n// 聚合函数\nString hql = \"SELECT max(bid) FROM Book\";\nQuery query = session.createQuery(hql);\nNumber number = (Number) query.uniqueResult();\n```\n\n```java\n// 占位符\nString hql = \"FROM Book where bauthor=:name\";\nQuery<Book> query = session.createQuery(hql,Book.class);\nquery.setParameter(\"name\",\"unknown\");\n```\n\n```java\n// 分页 第一页，每页10条\nquery.setFirstResult(0);\nquery.setMaxResults(10);\n```\n\n### Criteria查询(单表条件查询)\n\n```java\nCriteria criteria = session.createCriteria(Book.class);\nSystem.out.println(criteria.list());\n```\n\n```java\n// 根据ID查询\ncriteria.add(Restrictions.idEq(2));\n// 条件查询\ncriteria.add(Restrictions.eq(\"bname\",\"clean code\"));\n// 排序\ncriteria.addOrder(Order.asc(\"bname\"));\n// 聚合函数\ncriteria.setProjection(Projections.max(\"bid\"));\n```\n\n#### 离线查询\n\n```java\nDetachedCriteria criteria = DetachedCriteria.forClass(Book.class);\ncriteria.add(Restrictions.eq(\"bname\",\"clean code\"));\nList list = criteria.getExecutableCriteria(session).list();\n```\n\n### 原生sql查询\n\n```java\nString sql = \"SELECT * FROM tb_book WHERE bid = ?\";\nNativeQuery<Book> query = session.createSQLQuery(sql).addEntity(Book.class);\nquery.setParameter(1,1);\n```\n\n## 多表查询\n\n### 一对多|多对一\n\n```xml\n<class name=\"Book\" table=\"tb_book\" >\n    <id name=\"bid\">\n        <generator class=\"native\"/>\n    </id>\n    <property name=\"bname\" column=\"bname\" />\n\t<!-- 一对多 -->\n    <set name=\"authors\">\n        <key column=\"book\"/>\n        <one-to-many class=\"Author\"/>\n    </set>\n</class>\n```\n```xml\n<class name=\"Author\" table=\"tb_author\" >\n    <id name=\"id\">\n        <generator class=\"native\"/>\n    </id>\n    <property name=\"name\" column=\"author_name\" />\n\t<!-- 多对一 -->\n    <many-to-one name=\"book\" column=\"book\" class=\"Book\"/>\n</class>\n```\n\n- 操作\n\n```java\n// 新增\nBook book = new Book();\nbook.setBname(\"java\");\n\nAuthor author1 = new Author();\nauthor1.setName(\"author1\");\nauthor1.setBook(book);\nAuthor author2 = new Author();\nauthor2.setName(\"author2\");\nauthor2.setBook(book);\nbook.setAuthors(Set.of(author1,author2));\n\nsession.save(book);\nsession.save(author1);\nsession.save(author2);\n\n// 追加一个多\nBook book = session.get(Book.class,1);\nAuthor author3 = new Author();\nauthor3.setName(\"author3\");\nauthor3.setBook(book);\nbook.getAuthors().add(author3);\nsession.save(author3);\n\n// 移除一个多\nBook book = session.get(Book.class,1);\nbook.getAuthors().removeIf(a-> \"author1\".equals(a.getName()));\n```\n\n- 级联操作\n\n```xml\n<!-- \n \t级联操作:\tcascade\n \t\tsave-update: 级联保存更新\n \t\tdelete:级联删除\n \t\tall:save-update+delete\n \t级联操作: 简化操作.目的就是为了少写两行代码.\n  -->\n  <!-- inverse属性: 配置关系是否维护. \n  \t\ttrue: book不维护关系\n  \t\tfalse(默认值): book维护关系\n  \t\t\n  \tinverse属性: 性能优化.提高关系维护的性能.\n  \t原则: 无论怎么放弃,总有一方必须要维护关系.\n  \t一对多关系中: 一的一方放弃.也只能一的一方放弃.多的一方不能放弃.\n  -->\n<set name=\"authors\" inverse=\"true\" cascade=\"save-update\">\n\n<many-to-one name=\"book\" column=\"book\" class=\"Book\" cascade=\"save-update\"/>\n```\n\n```java\nBook book = new Book();\nbook.setBname(\"python\");\n\nAuthor author1 = new Author();\nauthor1.setName(\"authorx\");\nauthor1.setBook(book);\n\nbook.setAuthors(Set.of(author1));\nsession.save(book);\n```\n\n### 多对多\n\n```xml\n<class name=\"Book\" table=\"tb_book\" >\n    <id name=\"bid\">\n        <generator class=\"native\"/>\n    </id>\n\t<!-- 多对多关系一方要放弃维护关系 -->\n    <property name=\"bname\" column=\"bname\" inverse=\"true\"/>\n\n    <set name=\"authors\" table=\"tb_book_author\">\n        <key column=\"bid\"/>\n        <many-to-many class=\"Author\" column=\"aid\"/>\n    </set>\n</class>\n\n<class name=\"Author\" table=\"tb_author\" >\n    <id name=\"aid\">\n        <generator class=\"native\"/>\n    </id>\n    <property name=\"name\" column=\"author_name\" />\n    <set name=\"book\" table=\"tb_book_author\">\n        <key column=\"aid\"/>\n        <many-to-many class=\"Book\" column=\"bid\"/>\n    </set>\n</class>\n```\n\n- 操作\n\n```java\nBook book1 = new Book();\nbook1.setBname(\"clean code\");\nBook book2 = new Book();\nbook2.setBname(\"clean coder\");\n\nAuthor author1 = new Author();\nauthor1.setName(\"martin flower\");\nAuthor author2 = new Author();\nauthor2.setName(\"robert c\");\n\nbook1.setAuthors(Set.of(author1,author2));\nbook2.setAuthors(Set.of(author1,author2));\nauthor1.setBook(Set.of(book1,book2));\nauthor2.setBook(Set.of(book1,book2));\n\nsession.save(book1);\nsession.save(book2);\nsession.save(author1);\nsession.save(author2);\n```\n\n## 加载策略\n\n### 类级别\n\n```java\n// 立即加载\nBook book = session.get(Book.class, 1);\n\n// 延迟加载 使用时才去数据库查询（动态代理）\n// 使用懒加载时要确保,调用属性加载数据时,session还是打开的.不然会抛出异常\nBook book = session.load(Book.class, 2);\n```\n\n```xml\n<class name=\"Book\" table=\"tb_book\" lazy=\"true\">\n```\n\n### 关联级别\n\n- 集合\n\n```xml\n<!-- \n\tlazy\n\t\ttrue:默认值，获取集合时才加载\n\t\tfalse:在get时，立即加载集合数据\n\t\textra:与懒加载效果一致，如果只获取集合size，那就只发起count语句\n\tfetch\n\t\tselect:默认值\n\t\tjoin：使用一条语句直接得到所有数据\n\t\tsubselect: 加载集合时，使用批量子查询\n -->\n<set name=\"authors\" table=\"tb_book_author\" inverse=\"true\" lazy=\"true\" fetch=\"select\">\n```\n\n- 关联属性\n\n为了提高效率.fetch的选择上应选择select. lazy的取值应选择 true. 全部使用默认值.\n\n### 批量抓取\n\n- batch-size","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}