{"content":"# 编解码器\n\n## 解码器\n\n- ByteToMessageDecoder\n\n```java\npublic class TimeDecoder extends ByteToMessageDecoder {\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n        // 如果缓冲区没有足够的数据，不进行处理，只有缓冲区累积一定的数据时，才将数据添加到out\n        if (in.readableBytes() < 4){\n            return;\n        }\n        // 添加到out后，代表解码器成功解码了一条消息\n        out.add(in.readBytes(4));\n    }\n}\n```\n\n- ReplayingDecoder\n\n使用了一个自定义的ByteBuf 支持更简单的操作\n\n- MessageToMessageDecoder\n\n## 编码器\n\n- 扩展了MessageToByteEncoder\n\n```java\npublic class ShortToByteEncoder extends MessageToByteEncoder<Short> {   ← --  扩展了MessageToByteEncoder\n　　@Override\n　　public void encode(ChannelHandlerContext ctx, Short msg, ByteBuf out)\n　　　　throws Exception {\n　　　　out.writeShort(msg);　 ← --  将Short 写入ByteBuf 中\n　　}\n}\n```\n\n- MessageToMessageEncoder\n\n## 编解码器\n\n- xxxCodec\n\n## netty 内置的 Handler 以及 编解码器\n\n- SslHandler\n  - SSL/TLS\n- Http\n  - HttpResponseDecoder\n  - HttpRequestEncoder\n  - HttpServerCodec\n  - `pipeline.addLast(\"aggregator\",new HttpObjectAggregator(512 * 1024));`\n  - 压缩:HttpContentCompressor\n- WebSocket\n\n```java\n　　@Override\n　　protected void initChannel(Channel ch) throws Exception {\n　　　　ch.pipeline().addLast(\n　　　　　　new HttpServerCodec(),\n　　　　　　new HttpObjectAggregator(65536),   ← --  为握手提供聚合的HttpRequest\n　　　　　  new WebSocketServerProtocolHandler(\"/websocket\"), ← --  如果被请求的端点是\"/websocket\"，则处理该升级握手　\n　　　　　　new TextFrameHandler(),　 ← --  TextFrameHandler 处理TextWebSocketFrame\n　　　　　  new BinaryFrameHandler(),　← -- BinaryFrameHandler 处理BinaryWebSocketFrame　\n　　　　　  new ContinuationFrameHandler());　← -- ContinuationFrameHandler 处理ContinuationWebSocketFrame　 \n　　}\n```\n\n- 检测空闲连接或超时\n  - IdleStateHandler\n  - ReadTimeoutHandler\n  - WriteTimeoutHandler\n- 根据分隔符分割字节流\n  - DelimiterBasedFrameDecoder\n  - LineBasedFrameDecoder\n- 根据长度分割字节流\n  - FixedLengthFrameDecoder\n  - LengthFieldBasedFrameDecoder\n- 写大型数据\n\n```java\nFileInputStream in = new FileInputStream(file);   ← -- 创建一个FileInputStream \nFileRegion region = new DefaultFileRegion(　 ← -- 以该文件的完整长度创建一个新的DefaultFileRegion\n　　in.getChannel(), 0, file.length());\nchannel.writeAndFlush(region);\n```\n\n```java\npipeline.addLast(new ChunkedWriteHandler());　 ← --  添加Chunked-WriteHandler以处理作为ChunkedInput传入的数据\n　　　　pipeline.addLast(new WriteStreamHandler());   ← --  一旦连接建立，WriteStreamHandler就开始写文件数据　 \n```\n\n### 序列化\n  \n- JDK\n\n<table border=\"1\" width=\"90%\"> \n <thead> \n  <tr> \n   <th> <p class=\"表头单元格\">名　　称</p> </th> \n   <th> <p class=\"表头单元格\">描　　述</p> </th> \n  </tr> \n </thead> \n <tbody> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>CompatibleObjectDecoder</code> <a href=\"#anchor119\" id=\"ac119\"><sup>[9]</sup></a></p> </td> \n   <td> <p class=\"表格单元格\">和使用JDK序列化的非基于Netty的远程节点进行互操作的解码器</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>CompatibleObjectEncoder</code></p> </td> \n   <td> <p class=\"表格单元格\">和使用JDK序列化的非基于Netty的远程节点进行互操作的编码器</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>ObjectDecoder</code></p> </td> \n   <td> <p class=\"表格单元格\">构建于JDK序列化之上的使用自定义的序列化来解码的解码器；当没有其他的外部依赖时，它提供了速度上的改进。否则其他的序列化实现更加可取</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>ObjectEncoder</code></p> </td> \n   <td> <p class=\"表格单元格\">构建于JDK序列化之上的使用自定义的序列化来编码的编码器；当没有其他的外部依赖时，它提供了速度上的改进。否则其他的序列化实现更加可取</p> </td> \n  </tr> \n </tbody> \n</table>\n\n- JBoss Marshalling\n\n<table border=\"1\" width=\"90%\"> \n <thead> \n  <tr> \n   <th> <p class=\"表头单元格\">名　　称</p> </th> \n   <th> <p class=\"表头单元格\">描　　述</p> </th> \n  </tr> \n </thead> \n <tbody> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>CompatibleMarshallingDecoder</code><br> <code>CompatibleMarshallingEncoder</code></p> </td> \n   <td> <p class=\"表格单元格\">与只使用JDK序列化的远程节点兼容</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>MarshallingDecoder</code><br> <code>MarshallingEncoder</code></p> </td> \n   <td> <p class=\"表格单元格\">适用于使用JBoss Marshalling的节点。这些类必须一起使用</p> </td> \n  </tr> \n </tbody> \n</table>\n\n- Protocol Buffers\n\n<table border=\"1\" width=\"90%\"> \n <thead> \n  <tr> \n   <th> <p class=\"表头单元格\">名　　称</p> </th> \n   <th> <p class=\"表头单元格\">描　　述</p> </th> \n  </tr> \n </thead> \n <tbody> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>ProtobufDecoder</code></p> </td> \n   <td> <p class=\"表格单元格\">使用protobuf对消息进行解码</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>ProtobufEncoder</code></p> </td> \n   <td> <p class=\"表格单元格\">使用protobuf对消息进行编码</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>ProtobufVarint32FrameDecoder</code></p> </td> \n   <td> <p class=\"表格单元格\">根据消息中的Google Protocol Buffers的“Base 128 Varints”a整型长度字段值动态地分割所接收到的<code>ByteBuf</code></p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>ProtobufVarint32LengthFieldPrepender</code></p> </td> \n   <td> <p class=\"表格单元格\">向<code>ByteBuf</code>前追加一个Google Protocal Buffers的“Base 128 Varints”整型的长度字段值</p> </td> \n  </tr> \n </tbody> \n</table>","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}