{"content":"## 传\n\n## API\n\n核心是 **Channel**\n\n![批注 2020-07-06 123702](/assets/批注%202020-07-06%20123702.png)\n\nChannel的方法\n\n<table border=\"1\" width=\"90%\"> \n <thead> \n  <tr> \n   <th> <p class=\"表头单元格\">方　法　名</p> </th> \n   <th> <p class=\"表头单元格\">描　　述</p> </th> \n  </tr> \n </thead> \n <tbody> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>eventLoop</code></p> </td> \n   <td> <p class=\"表格单元格\">返回分配给<code>Channel</code>的<code>EventLoop</code></p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>pipeline</code></p> </td> \n   <td> <p class=\"表格单元格\">返回分配给<code>Channel</code>的<code>ChannelPipeline</code></p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>isActive</code></p> </td> \n   <td> <p class=\"表格单元格\">如果<code>Channel</code>是活动的，则返回<code>true</code>。活动的意义可能依赖于底层的传输。例如，一个<code>Socket</code>传输一旦连接到了远程节点便是活动的，而一个<code>Datagram</code>传输一旦被打开便是活动的</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>localAddress</code></p> </td> \n   <td> <p class=\"表格单元格\">返回本地的<code>SocketAddress</code></p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>remoteAddress</code></p> </td> \n   <td> <p class=\"表格单元格\">返回远程的<code>SocketAddress</code></p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>write</code></p> </td> \n   <td> <p class=\"表格单元格\">将数据写到远程节点。这个数据将被传递给<code>ChannelPipeline</code>，并且排队直到它被flush</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>flush</code></p> </td> \n   <td> <p class=\"表格单元格\">将之前已写的数据刷新到底层传输，如一个<code>Socket</code></p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>writeAndFlush</code></p> </td> \n   <td> <p class=\"表格单元格\">一个简便的方法，等同于调用<code>write()</code>并接着调用<code>flush()</code></p> </td> \n  </tr> \n </tbody> \n</table>\n\nChannel 是线程安全的\n\n## 内置的传输\n\n<table width=\"90%\"> \n <thead> \n  <tr> \n   <th> <p class=\"表头单元格\">名　　称</p> </th> \n   <th> <p class=\"表头单元格\">包</p> </th> \n   <th> <p class=\"表头单元格\">描　　述</p> </th> \n  </tr> \n </thead> \n <tbody> \n  <tr> \n   <td> <p class=\"表格单元格\">NIO</p> </td> \n   <td> <p class=\"表格单元格\"><code>io.netty.channel.socket.nio</code></p> </td> \n   <td> <p class=\"表格单元格\">使用<code>java.nio.channels</code>包作为基础——基于选择器的方式</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\">Epoll<a href=\"#anchor42\" id=\"ac42\"><sup>[1]</sup></a></p> </td> \n   <td> <p class=\"表格单元格\"><code>io.netty.channel.epoll</code></p> </td> \n   <td> <p class=\"表格单元格\">由JNI驱动的<code>epoll()</code>和非阻塞IO。这个传输支持只有在Linux上可用的多种特性，如<code>SO_REUSEPORT</code>，比NIO传输更快，而且是完全非阻塞的</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\">OIO</p> </td> \n   <td> <p class=\"表格单元格\"><code>io.netty.channel.socket.oio</code></p> </td> \n   <td> <p class=\"表格单元格\">使用<code>java.net</code>包作为基础——使用阻塞流</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\">Local</p> </td> \n   <td> <p class=\"表格单元格\"><code>io.netty.channel.local</code></p> </td> \n   <td> <p class=\"表格单元格\">可以在VM内部通过管道进行通信的本地传输</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\">Embedded</p> </td> \n   <td> <p class=\"表格单元格\"><code>io.netty.channel.embedded</code></p> </td> \n   <td> <p class=\"表格单元格\">Embedded传输，允许使用<code>ChannelHandler</code>而又不需要一个真正的基于网络的传输。这在测试你的<code>ChannelHandler</code>实现时非常有用</p> </td> \n  </tr> \n </tbody> \n</table>\n\n- NIO\n\n![批注 2020-07-06 124813](/assets/批注%202020-07-06%20124813.png)\n\n- Epoll\n\n该传输的语义同NIO 如果要使用该传输 只需要将 EventLoop 中的 NioServerSocketChannel 替换为 EpollServerSocketChannel即可\n\n- OIO\n\n![批注 2020-07-06 125423](/assets/批注%202020-07-06%20125423.png)\n\n- Local\n\n没有绑定物理网络地址\n\n- Embedded\n\n可以将一组ChannelHandler 嵌入到 其他 ChannelHandler内部\n\n## 场景\n\n<table border=\"1\" width=\"90%\"> \n <thead> \n  <tr> \n   <th> <p class=\"表头单元格\">应用程序的需求</p> </th> \n   <th> <p class=\"表头单元格\">推荐的传输</p> </th> \n  </tr> \n </thead> \n <tbody> \n  <tr> \n   <td> <p class=\"表格单元格\">非阻塞代码库或者一个常规的起点</p> </td> \n   <td> <p class=\"表格单元格\">NIO（或者在Linux上使用epoll）</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\">阻塞代码库</p> </td> \n   <td> <p class=\"表格单元格\">OIO</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\">在同一个JVM内部的通信</p> </td> \n   <td> <p class=\"表格单元格\">Local</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\">测试<code>ChannelHandler</code>的实现</p> </td> \n   <td> <p class=\"表格单元格\">Embedded</p> </td> \n  </tr> \n </tbody> \n</table>","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}