{"content":"# ByteBuf\n\n数据容器\n\n- 可以进行扩展\n- 零拷贝\n- 容量按需增长\n- 读写切换不需要调用flip\n- 读写使用不同索引\n- 方法链式调用\n- 引用计数\n- 池化\n\n![批注 2020-07-07 105759](/assets/批注%202020-07-07%20105759.png)\n\n## 使用模式\n\n- 堆缓冲区\n\nByteBuf将数据存储在JVM的堆空间中\n\n```java\nByteBuf heapBuf = ...;\nif (heapBuf.hasArray()) {  ← --  检查ByteBuf 是否有一个支撑数组\n　　byte[] array = heapBuf.array();  ← --  如果有，则获取对该数组的引用　\n　　int offset = heapBuf.arrayOffset() + heapBuf.readerIndex();  ← --  计算第一个字节的偏移量。\n　　int length = heapBuf.readableBytes();　 ← --  获得可读字节数\n　　handleArray(array, offset, length);　 ← --  使用数组、偏移量和长度作为参数调用你的方法\n}\n```\n\n- 直接缓冲区\n\n这种模式下的ByteBuf支持通过本地调用分配内存\n\n所以直接缓冲区的数据在堆外，不会被GC处理\n\n```java\nByteBuf directBuf = ...; \nif (!directBuf.hasArray()) {  ← --  检查ByteBuf 是否由数组支撑。如果不是，则这是一个直接缓冲区\n　　int length = directBuf.readableBytes();  ← --  获取可读字节数\n　　byte[] array = new byte[length];　 ← --  分配一个新的数组来保存具有该长度的字节数据　　\n　　directBuf.getBytes(directBuf.readerIndex(), array);  ← --  将字节复制到该数组\n　　handleArray(array, 0, length);  ← --  使用数组、偏移量和长度作为参数调用你的方法\n}\n```\n\n- 复合缓冲区\n\n这种模式下允许多个ByteBuf聚合起来，提供一个ByteBuf整体视图来进行操作\n\n## 字节级操作\n\n- 随机访问\n\n```java\nByteBuf buffer = ...;\nfor (int i = 0; i < buffer.capacity(); i++) {\n　　byte b = buffer.getByte(i);\n　　System.out.println((char)b);\n}\n```\n\n不会改变索引的值\n\n- 顺序访问\n\n![批注 2020-07-07 110658](/assets/批注%202020-07-07%20110658.png)\n\n调用discardReadBytes()可以回收可丢弃字节的空间\n\n读取所有数据\n\n```java\nByteBuf buffer = ...;\nwhile (buffer.isReadable()) {\n　　System.out.println(buffer.readByte());\n}\n```\n\n写入数据\n\n```java\nByteBuf buffer = ...;\nwhile (buffer.writableBytes() >= 4) {\n　　buffer.writeInt(random.nextInt());\n}\n```\n\n- 索引管理\n  - readerIndex(int)：设置读索引位置\n  - writerIndex(int)： 设置写索引位置\n  - clear()：将读索引写索引重置为0\n\n- 查找\n\n```java\n// 查找回车符(\\r)\nByteBuf buffer = ...;\nint index = buffer.forEachByte(ByteBufProcessor.FIND_CR);\n```\n\n- 派生缓冲区\n\n  - duplicate()\n  - slice()\n  - slice(int, int)\n  - Unpooled.unmodifiableBuffer(…)\n  - order(ByteOrder)\n  - readSlice(int)\n  - copy()\n\n这些方法都会返回一个新的ByteBuf实例\n\n- 读/写\n  - get和set操作，从给定的索引开始，并且保持索引不变；\n  - read和write操作，从给定的索引开始，并且会根据已经访问过的字节数对索引进行调整。\n- 其他操作\n\n<table border=\"1\" width=\"90%\"> \n <thead> \n  <tr> \n   <th> <p class=\"表头单元格\">名　　称</p> </th> \n   <th> <p class=\"表头单元格\">描　　述</p> </th> \n  </tr> \n </thead> \n <tbody> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>isReadable()</code></p> </td> \n   <td> <p class=\"表格单元格\">如果至少有一个字节可供读取，则返回<code>true</code></p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>isWritable()</code></p> </td> \n   <td> <p class=\"表格单元格\">如果至少有一个字节可被写入，则返回<code>true</code></p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>readableBytes()</code></p> </td> \n   <td> <p class=\"表格单元格\">返回可被读取的字节数</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>writableBytes()</code></p> </td> \n   <td> <p class=\"表格单元格\">返回可被写入的字节数</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>capacity()</code></p> </td> \n   <td> <p class=\"表格单元格\">返回<code>ByteBuf</code>可容纳的字节数。在此之后，它会尝试再次扩展直 到达到<code>maxCapacity()</code></p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>maxCapacity()</code></p> </td> \n   <td> <p class=\"表格单元格\">返回<code>ByteBuf</code>可以容纳的最大字节数</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>hasArray()</code></p> </td> \n   <td> <p class=\"表格单元格\">如果<code>ByteBuf</code>由一个字节数组支撑，则返回<code>true</code></p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>array()</code></p> </td> \n   <td> <p class=\"表格单元格\">如果 <code>ByteBuf</code>由一个字节数组支撑则返回该数组；否则，它将抛出一个<code>UnsupportedOperationException</code>异常</p> </td> \n  </tr> \n </tbody> \n</table>\n\n## ByteBufHolder\n\n- 支持缓冲区池化\n  - 从池中复用ByteBuf\n\n<table border=\"1\" width=\"90%\"> \n <thead> \n  <tr> \n   <th> <p class=\"表头单元格\">名　　称</p> </th> \n   <th> <p class=\"表头单元格\">描　　述</p> </th> \n  </tr> \n </thead> \n <tbody> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>content()</code></p> </td> \n   <td> <p class=\"表格单元格\">返回由这个<code>ByteBufHolder</code>所持有的<code>ByteBuf</code></p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>copy()</code></p> </td> \n   <td> <p class=\"表格单元格\">返回这个<code>ByteBufHolder</code>的一个深拷贝，包括一个其所包含的<code>ByteBuf</code>的非共享副本</p> </td> \n  </tr> \n  <tr> \n   <td> <p class=\"表格单元格\"><code>duplicate()</code></p> </td> \n   <td> <p class=\"表格单元格\">返回这个<code>ByteBufHolder</code>的一个浅拷贝，包括一个其所包含的<code>ByteBuf</code>的共享副本</p> </td> \n  </tr> \n </tbody> \n</table>\n\n## ByteBuf分配\n\n**ByteBufAllocator**\n\n- 池化\n- buffer 返回基于对或者直接缓存存储\n- headBuffer 返回基于堆内存\n- directBuffer 返回基于直接内存\n- compositeBuffer\n- ioBuffer 返回套接字的IO操作buffer\n\n实现：\n\n- PooledByteBufAllocator\n  - 池化\n- UnpooledByteBufAllocator\n  - 每次调用都会返回一个新实例\n\n**Unpooled缓冲区**\n\n提供了一些静态方法来创建ByteBuf实例\n\n**ByteBufUtils**\n\n- hexdump 以16进制打印缓冲区\n- equals 比较两个ByteBuf\n\n## 引用计数\n\nByteBuf 与 ByteBufHolder 都实现了引用计数\n\n```java\nboolean released = buffer.release();  ← --  减少到该对象的活动引用。当减少到0 时，该对象被释放，并且该方法返回true\n```\n\n访问一个引用计数被释放的对象 会抛出异常","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}