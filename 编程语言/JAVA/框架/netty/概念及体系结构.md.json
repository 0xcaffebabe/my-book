{"content":"# 概念及体系结构\n\n## JAVA网络编程\n\n- BIO\n  - 同步阻塞IO\n\n![批注 2020-07-04 091237](/assets/批注%202020-07-04%20091237.png)\n\n- 伪异步IO\n- NIO\n  - 同步非阻塞IO\n\n![批注 2020-07-04 091304](/assets/批注%202020-07-04%20091304.png)\n\n- AIO\n  - 异步非阻塞IO\n\n## 特性\n\n![批注 2020-07-04 091702](/assets/批注%202020-07-04%20091702.png)\n\n- 非阻塞网络调用使得我们可以不必等待一个操作的完成。完全异步的I/O正是基于这个特性构建的，并且更进一步：异步方法会立即返回，并且在它完成时，会直接或者在稍后的某个时间点通知用户。\n\n- 选择器使得我们能够通过较少的线程便可监视许多连接上的事件。\n\n### 阻塞与非阻塞\n\n阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态\n\n阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。\n非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程\n\n### 同步与异步\n\n同步和异步关注的是消息通信机制 \n\n所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由*调用者*主动等待这个*调用*的结果。\n\n而异步则是相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用\n\n## 核心组件\n\n- 回调\n  - netty使用回调来将事件处理交给程序\n- Future\n  - netty的实现：ChannelFuture\n  - ChannelFutureListener\n    - 回调的更精细版本\n- 事件与ChannelHandler\n\n![批注 2020-07-04 092924](/assets/批注%202020-07-04%20092924.png)\n\n## 组件和设计\n\n### Channel\n\n它代表一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的I/O操作的程序组件）的开放连接，如读操作和写操作\n\n- EmbeddedChannel；\n- LocalServerChannel；\n- NioDatagramChannel；\n- NioSctpChannel；\n- NioSocketChannel。\n\n### EventLoop\n\n![批注 2020-07-05 094441](/assets/批注%202020-07-05%20094441.png)\n\n一个EventLoop在它的生命周期内只和一个Thread绑定 这个Thread会处理EventLoop所有的IO事件\n\n一个Channel对应一个EventLoop 一个EventLoop有一个或多个Channel\n\n### ChannelFuture\n\n提供了另一种在操作完成时通知应用程序的方式。这个对象可以看作是一个异步操作的结果的占位符；它将在未来的某个时刻完成，并提供对其结果的访问。\n\n属于同一个Channel的操作都能保证按调用的顺序执行\n\n### ChannelHandler\n\nChannelHandler 为 Netty 中最核心的组件，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等\n\n![](https://img2018.cnblogs.com/blog/1322310/201812/1322310-20181220211548971-1386097414.png)\n\n- ChannelInboundHandler\n\n### ChannelPipeline\n\nChannelPipeline 为 ChannelHandler 链提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API\n\n![](https://img-blog.csdn.net/20160504161903129?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)\n\n在netty中，有两种消息发送方式\n\n- Channel: 消息会从头开始传递\n- ChannelHandlerContext 消息会从某一个Handler开始传递\n\n### 编码器解码器\n\n- xxxDecoder\n- xxxEncoder\n\n### ServerBootStrap\n\n- 使用服务器的ServerBootStrap，用于接受客户端的连接以及为已接受的连接创建子通道。\n- 用于客户端的BootStrap，不接受新的连接，并且是在父通道类完成一些操作。\n\nServer端需要两组EventLoop\n\n![批注 2020-07-05 100502](/assets/批注%202020-07-05%20100502.png)\n\n## 异常处理\n\n- 入站异常\n  - ChannelHnadler.exceptionCaught\n- 出站异常\n  - ChannelFutureListener\n  - ChannelFuture\n\n## 线程模型\n\n线程模型确定了代码的执行方式\n\n### 线程池模型\n\n![批注 2020-07-08 111409](/assets/批注%202020-07-08%20111409.png)\n\n不能消除由上下文切换所带来的开销\n\n### EventLoop\n\n```java\nfor (;;) {\n    Runnable task = takeTask();\n    if (task != null) {\n        task.run();\n        updateLastExecutionTime();\n    }\n\n    if (confirmShutdown()) {\n        break;\n    }\n}\n```\n\n一个EventLoop 由 永远都不会变动的一个 Thread 驱动 \n\n### 任务调度\n\n- JDK自带的ScheduleExecutorService\n- netty 自带的调度\n\n```java\nChannel ch = ...\nScheduledFuture<?> future = ch.eventLoop().schedule(  ← --  创建一个Runnable以供调度稍后执行\n　　new Runnable() { \n　　@Override\n　　public void run() {  ← --  要执行的代码\n　　　　System.out.println(\"60 seconds later\");　\n　　}\n}, 60, TimeUnit.SECONDS);　 ← --  调度任务在从现在开始的60 秒之后执行\n```\n\n### 线程管理\n\n![批注 2020-07-08 112901](/assets/批注%202020-07-08%20112901.png)\n\n所以一定不能将一个长时间运行的任务放入到执行队列中 否则EventLoop会被阻塞\n\n### 线程分配\n\n- 异步传输\n\n![批注 2020-07-08 113146](/assets/批注%202020-07-08%20113146.png)\n\n- 阻塞传输\n\n![批注 2020-07-08 113208](/assets/批注%202020-07-08%20113208.png)\n\n## 单元测试\n\n### EmbeddedChannel\n\n![批注 2020-07-10 105859](/assets/批注%202020-07-10%20105859.png)\n\n```java\nEmbeddedChannel channel = new EmbeddedChannel(new EchoServerHandler());\n\nchannel.writeInbound(\"hello\"); // 入站数据\nassertTrue(channel.finish()); // 标记为完成\nString outData = channel.readOutbound(); // 出站数据\nassertEquals(\"hello\",outData);\n```","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}