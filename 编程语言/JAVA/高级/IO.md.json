{"content":"# IO\n\n![批注 2020-05-27 140149](/assets/批注%202020-05-27%20140149.png)\n\n![批注 2020-05-27 140937](/assets/批注%202020-05-27%20140937.png)\n\n- BIO (Blocking I/O): 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成\n- NIO (Non-blocking/New I/O): NIO 是一种同步非阻塞的 I/O 模型,支持面向缓冲的，基于通道的 I/O 操作方法\n- AIO (Asynchronous I/O):异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作\n\n网络IO模型：\n\n![屏幕截图 2020-09-27 192708](/assets/屏幕截图%202020-09-27%20192708.png)\n\n网络框架设计模式：\n\n- Reactor模式：主动模式 应用程序不断轮询 询问底层IO是否准备就绪\n- Proactor模式：被动模式 read write都交给底层 通过回调完成操作\n\n服务器网络编程 1 + N + M 模型\n\n1个监听线程 N个IO线程 M个worker线程\n\n## 架构\n\n![2020527165937](/assets/2020527165937.png)\n![20205271703](/assets/20205271703.png)\n\n大体分为两类：\n\n- 字节操作流 InputStream 与 OutputStream等 \n- 字符操作流 Writer 与 Reader\n- 磁盘IO File\n- 网络操作 Socekt等\n\n字节到字符的转换十分耗时 非常容易出现乱码问题 这是字符流的用处\n\nInputStreamReader 与 OutputStreamWriter 是字节流与字符流之间的桥梁\n\n## File类\n\nFile并不代表一个真实存在的真实对象\n\nFileDescriptor才是代表一个真实文件对象\n\n从磁盘读取文件：\n\n![屏幕截图 2020-09-28 133112](/assets/屏幕截图%202020-09-28%20133112.png)\n\n构造方法\n\n- public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。\n- public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。\n- public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例\n\n静态成员变量\n\n![批注 2019-08-03 083724](/assets/批注%202019-08-03%20083724.png)\n\n### 获取\n\n- public String getAbsolutePath() ：返回此File的绝对路径名字符串。\n- public String getPath() ：将此File转换为路径名字符串。\n- public String getName() ：返回由此File表示的文件或目录的名称。\n- public long length() ：返回由此File表示的文件的长度。\n\n### 判断\n\n- public boolean exists() ：此File表示的文件或目录是否实际存在。\n- public boolean isDirectory() ：此File表示的是否为目录。\n- public boolean isFile() ：此File表示的是否为文件。\n\n### 创建删除\n\n- public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。\n- public boolean delete() ：删除由此File表示的文件或目录。\n- public boolean mkdir() ：创建由此File表示的目录。\n- public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。\n\n### 目录遍历\n\n- public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。\n- public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。\n\n### 文件过滤器\n\n- FileFilter\n- FileNameFilter\n\n## IO\n\n### 顶级父类\n\n-   | 输入流               | 输出流\n--- | ----------------- | ------------------\n字节流 | 字节输入流 InputStream | 字节输出流 OutputStream\n字符流 | 字符输入流 Reader      | 字符输出流 Writer\n\n### 字节输出流【OutputStream】\n\n- public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。\n- public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。\n- public void write(byte[] b) ：将 b.length字节从指定的字节数组写入此输出流。\n- public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 oﬀ开始输 出到此输出流。\n- public abstract void write(int b) ：将指定的字节输出流。\n\n### FileOutputStream\n\n```java\nFileOutputStream fos = new FileOutputStream(\"fos.txt\");\n\n        for (int i =0;i<100;i++){\n            fos.write((\"hello\"+i+\"\\n\").getBytes());\n\n        }\n        fos.flush();\n        fos.close();\n```\n\n- 数据追加续写\n\n```java\nFileOutputStream fos = new FileOutputStream(\"fos.txt\",true);\n```\n\n### 字节输入流【InputStream】\n\n- public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。\n- public abstract int read() ： 从输入流读取数据的下一个字节。\n- public int read(byte[] b) ： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。\n\n### FileInputStream\n\n构造方法\n\n- FileInputStream(File file) ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系 统中的 File对象 ﬁle命名。\n- FileInputStream(String name) ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件 系统中的路径名 name命名。\n\n```java\nFileInputStream fis = new FileInputStream(\"fos.txt\");\n        int c = -1;\n        while ((c = fis.read()) != -1) {\n            System.out.print((char)c);\n        }\n        fis.close();\n```\n\n### 字符流\n\nReader\n\n- public void close() ：关闭此流并释放与此流相关联的任何系统资源。\n- public int read() ： 从输入流读取一个字符。\n- public int read(char[] cbuf) ： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。\n\nFileReader\n\n```java\nFileReader reader = new FileReader(\"fos.txt\");\nint c = -1;\nwhile ((c = reader.read()) != -1){\n    System.out.print((char)c);\n}\n```\n\nWriter\n\n- void write(int c) 写入单个字符。\n- void write(char[] cbuf) 写入字符数组。\n- abstract void write(char[] cbuf, int off, int len) 写入字符数组的某一部分,oﬀ数组的开始索引,len 写的字符个数。\n- void write(String str) 写入字符串。\n- void write(String str, int off, int len) 写入字符串的某一部分,oﬀ字符串的开始索引,len写的字符个 数。\n- void flush() 刷新该流的缓冲。\n- void close() 关闭此流，但要先刷新它。\n\nFileWriter\n\n```java\n        FileWriter writer = new FileWriter(\"fos.txt\");\n\n        writer.append(\"hh种\");\n        writer.flush();\n        writer.close();\n```\n\n- flush与close的区别\n\n## JDK7中IO的异常处理\n\n```java\n// JDK7\ntry (FileWriter writer = new FileWriter(\"fos.txt\")) {\n    writer.append(\"hh种\");\n    writer.flush();\n    \n} catch (IOException e) {\n    e.printStackTrace();\n}\n// JDK9\nFileWriter writer = new FileWriter(\"fos.txt\");\ntry (writer) {\n    writer.append(\"hh种\");\n    writer.flush();\n\n} catch (IOException e) {\n    e.printStackTrace();\n}\n```\n\n## Properties\n\n- public Object setProperty(String key, String value) ： 保存一对属性。 \n- public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。 \n- `public Set<String> stringPropertyNames()` ：所有键的名称的集合。\n\n### 与流相关的方法\n\n- store\n- load\n\n## 缓冲流\n\n- 字节缓冲流： BufferedInputStream ， BufferedOutputStream \n- 字符缓冲流： BufferedReader ， BufferedWriter\n\n## 编码\n\n>字符编码 Character Encoding : 就是一套自然语言的字符与二进制数之间的对应规则。 \n\n- 字符集 Charset ：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符 号、数字等。\n\n![02_转换流的原理](/assets/02_转换流的原理.bmp)\n\n### 常用编码\n\n- ASCII 码 使用7bit来表示 范围从0-127\n- ISO-8859-1 单字节编码 总共能表示256字符\n- GB2312 双字节编码\n- GBK 扩展了GB2312 增加了更多的汉字\n- UTF-16 两个字节表示一个字符 大大简化了字符串操作 是Java内存的存储格式\n- UTF-8 使用变长存储 不同的字符可以由1~6个字符组成\n\nGBK与GB2312对比：GBK范围更大\n\nUTF8与UTF16对比：16编码效率高 但不适合网络传输 8的容错性比16强\n\n### IO 操作中的编解码\n\n```java\nInputStreamReader reader = new InputStreamReader(new FileInputStream(\"gbk.txt\"),\"gbk\");\n\nOutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(\"utf8.txt\"), StandardCharsets.UTF_8);\nint c = -1;\nwhile ((c= reader.read()) != -1){\n    writer.write(c);\n}\nwriter.close();\n```\n\n### 内存编解码\n\n```java\n\"蔡徐坤\".getBytes(\"gbk\");\nnew String(new byte[]{ -78, -52, -48, -20, -64, -92 },\"gbk\");\n```\n\nString 编码时序图：\n\n![屏幕截图 2020-09-29 112623](/assets/屏幕截图%202020-09-29%20112623.png)\n\n### Web 中的编解码\n\n![屏幕截图 2020-09-29 113656](/assets/屏幕截图%202020-09-29%20113656.png)\n\n#### URL编解码\n\n`/页面?name=页面`\n\n这个URL被编码成`%2f%e9%a1%b5%e9%9d%a2%3fname%3d%e9%a1%b5%e9%9d%a2`\n\n不同浏览器的编码可能并不一致 那么服务端是如何解析的？\n\ntomcat中有一个配置：\n\n```xml\n<Connector URLEncoding=\"UTF-8\"> \n```\n\n这个配置就是用来对路径部分进行解码的\n\n至于queryString 要不是body中的charset 要不就是ISO-8859-1\n\n并且如果使用要body的charset的话 需要配置\n\n```xml\n<Connector useBodyEncodingForURI=\"true\"/>\n```\n\n#### HTTP header 编解码\n\n对于request.getHeader() 默认是使用的ISO-8859-1编码 且无法指定编码 不要再Header中传递非ASCII 字符\n\n#### 表单编解码\n\n浏览器会根据ContentType的Charset对表单参数进行编码\n\n服务端可以在Servlet容器中获取参数之前调用request.setCharacterEncoding()来指定服务器解码方式 如果没有调用此方法 那么会按照系统默认的编码方式解析\n\n#### Body 编解码\n\n服务端通过response.setCharacterEncoding来设置 这个方法的本质是设置响应头ContentType\n\n浏览器端按照以下顺序进行解码：\n\n- ContentType的charset\n- html meta标签的charset属性\n- 浏览器默认方式\n\n#### js文件编码问题\n\n如果外部引入的js文件与当前html不一致 需要\n\n```html\n<script charset=\"utf8\" src=\"xxx\"></script>\n```\n\n#### 常见编码问题\n\n![屏幕截图 2020-09-29 131724](/assets/屏幕截图%202020-09-29%20131724.png)\n![屏幕截图 2020-09-29 131741](/assets/屏幕截图%202020-09-29%20131741.png)\n![屏幕截图 2020-09-29 131801](/assets/屏幕截图%202020-09-29%20131801.png)\n\n## 序列化\n\n- ObjectOutputStream\n- ObjectInputStream\n\n```java\nObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"object\"));\noos.writeObject(new Person(\"jav\",15));\n\nObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"object\"));\nPerson p = (Person)ois.readObject();\n```\n\n序列化的类需要实现 `Serializable` 接口\n\n最好手动设置 serialVersionUID 的值, 类修改时根据是否兼容来调整这个值\n\n**transient关键字**修饰的变量不会被序列化\n\n其他方式的序列化：\n\n- Hessian 效率很高 跨语言\n- JSON\n\n序列化一些复杂对象：\n\n- 父类继承Serializable接口 所有子类都可以序列化\n- 子类实现Serializable接口 序列化后父类的属性会丢失\n- 成员变量如果要被序列化 需要实现Serializable接口 否则会报错\n- 反序列化时 成员如果发生修改 则发生修改的这些成员变量数据会丢失\n- 如果 serialVersionUID 被修改 反序列化会失败\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}