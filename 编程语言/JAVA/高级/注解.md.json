{"content":"# 注解\n\n- 编写文档：通过代码里标识的注解生成文档【生成文档doc文档】\n- 代码分析：通过代码里标识的注解对代码进行分析【使用反射】\n- 编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】\n\n## JAVA提供的基本注解\n\n- **@Override**\n\n  - 限定重写父类方法。对于子类中被@Override 修饰的方法，如果存在对应的被重写的父类方法，则正确；如果不存在，则报错。@Override 只能作用于方法，不能作用于其他程序元素\n\n- **@Deprecated**\n\n  - 用于表示某个程序元素（类、方法等）已过时。如果使用了被@Deprecated修饰的类或方法等，编译器会发出警告\n\n- **@SuppressWarnings**\n\n  - 抑制编译器警告\n\n- **@SafeVarargs**\n\n  - 是JDK 7 专门为抑制\"堆污染\"警告提供的\n\n    堆污染：简单的说就是当一个泛型类型变量赋值给不是泛型类型变量，这种错误在编译期间能被编译器警告，但是可以忽略，直到运行时报错\n\n- **@FunctionalIterface**\n\n  - @FunctionalInterface就是用来指定某个接口必须是函数式接口，否则就会编译出错\n\n## 自定义注解\n\n```java\n元注解\npublic @interface 注解名称{\n    属性列表;\n}\n```\n\n属性的返回值类型有下列取值:\n\n- 基本数据类型\n- String\n- 枚举\n- 注解\n- 以上类型的数组\n\n## 元注解\n\n> 用于注解的注解\n\n- @Target：描述注解能够作用的位置\n\n  - ElementType取值：\n\n    - TYPE：可以作用于类上\n    - METHOD：可以作用于方法上\n    - FIELD：可以作用于成员变量上\n    - ...\n\n- @Retention：描述注解被保留的阶段\n\n```java\npublic enum RetentionPolicy {\n    // 保留在源码级别上\n    SOURCE,\n\n    //保留在class文件中，jvm无法读取到\n    CLASS,\n\n    //会保留到class字节码文件中，并被JVM读取到\n    RUNTIME\n}\n```\n\n- @Documented：描述注解是否被抽取到api文档中\n- @Inherited：描述注解是否被子类继承\n  - 父类的注解将会传递到子类上\n- @Repeatable：描述是否能重复注解（JDK8之后新增的功能）\n  - 实现细节：通过一个注解容器\n\n## 注解的解析\n\n- RetentionPolicy.RUNTIME ：注解在class文件中，被JVM加载，可用反射解析注解\n- RetentionPolicy.CLASS:注解在class文件中，但JVM没有加载，只能采用字节码工具进行特殊处理\n- RetentionPolicy.SOURCE ：注解在java文件中，不在class文件中，也不会被JVM加载\n  - 只有在源码级别进行注解处理\n  - Java提供注解处理器来解析带注解的源码，产生新的文件\n\n## RUNTIME注解本质\n\n- 继承Annotation接口的一个接口\n- 实际使用中有一个代理对象实现了此接口\n- 代理对象使用AnnotationInvocationHandler处理方法调用\n- AnnotationInvocationHandler使用一个map存储属性\n\n## 应用\n\n- Servlet3.0\n- Junit\n- Spring & Spring boot\n- Lombok\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}