{"content":"# Lambda 表达式\n\n```java\n(参数列表) ‐> { 代码语句 }\n```\n\n```java\n// Lambda表达式的书写形式\nRunnable run = () -> System.out.println(\"Hello World\");// 1\nActionListener listener = event -> System.out.println(\"button clicked\");// 2\nRunnable multiLine = () -> {// 3 代码块\n    System.out.print(\"Hello\");\n    System.out.println(\" Hoolee\");\n};\nBinaryOperator<Long> add = (Long x, Long y) -> x + y;// 4\nBinaryOperator<Long> addImplicit = (x, y) -> x + y;// 5 类型推断\n```\n\n- 类似于匿名方法，一个没有名字的方法\n- 可以忽略写参数类型\n- 坚决不声明返回值类型\n- 没有修饰符\n- 单句表达式，将直接返回值，不用大括号\n- 带return语句， 算多句，必须用大括号\n- 无参数，仅保留括号\n- 一个参数，可省略括号\n\n## 使用前提\n\n- 使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法(称之为函数式接口)。 无论是JDK内置的 Runnable 、 Comparator 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一 时，才可以使用Lambda。\n- 使用Lambda必须具有上下文推断。 也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为该接口的实例。\n\n> 有且仅有一个抽象方法的接口，称为\"函数式接口\"。\n\n## 函数式接口\n\n- 是一个接口，符合Java接口的定义\n- 只包含一个抽象方法的接口\n- 可以包括其他的default方法、static方法、private方法\n- 由于只有一个未实现的方法，所以Lambda表达式可以自动填上这个尚未实现的方法\n- 采用Lambda表达式，可以自动创建出一个(伪)嵌套类的对象(没有实际的嵌套类class文件产生)，然后使用，比真正嵌套类更加轻量，更加简洁高效\n\n- @FunctionalInterface注解\n\n> 一旦使用该注解来标记接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则编译将会报错。\n\n\n```java\n@FunctionalInterface\npublic interface SuperRunnable {\n    void superRun();\n}\n```\n\n```java\npublic static void main(String[] args) {\n    superRun(()-> System.out.println(\"hello world\"));\n}\nprivate static void superRun(SuperRunnable sr){\n    sr.superRun();\n}\n```\n\n- 尽量使用系统自带的函数式接口，不要自己定义\n\n接口               | 参数   | 返回值     | 示例\n---------------- | ---- | ------- | --------------\n`Predicate<T>`   | T    | Boolean | 接收一个参数，返回一个布尔值\n`Consumer<T>`    | T    | void    | 接受一个参数，无返回\n`Function<T, R>` | T    | R       | 接受一个参数，返回一个值\n`Supplier<T>`    | None | T       | 无参数 返回一个值\n\n## Lambda JVM层实现\n\nJava编译器将Lambda表达式编译成使用表达式的类的一个私有方法，然后通过invokedynamic指令调用该方法。所以在Lambda表达式内，this引用指向的仍是使用表达式的类。\n\n## 方法引用\n\n- Class::staticMethod，如 Math::abs方法\n  - Math::abs 等价于 x -> Math.abs(x)\n- Class::instanceMethod，如String::compareToIgnoreCase方法\n  - String::compareToIgnoreCase等价于(x,y)->x.compareToIgnoreCase(y)\n- object::instanceMethod，如System.out::println方法\n  - System.out::println等价于x->System.out.println(x)\n  - 支持this::instanceMethod 调用\n  - 支持super::instanceMethod 调用\n- Class::new，调用某类构造函数，支持单个对象构建\n  - `Supplier<Object> ` sp = Object::new\n- Class[]::new，调用某类构造函数，支持数组对象构建\n  - `Function<Integer,Object> ` f = Object[]::new\n\n## 应用\n\n- 类型信息\n  - 被赋值后，可以看作是一个函数式接口的实例(对象)\n  - 但是Lambda表达式没有存储目标类型(target type)的信息\n  - 重载调用，依据重载的规则和类型参数推理\n- 变量遮蔽\n  - Lambda表达式可以访问外部嵌套块的变量\n    - 但是变量要求是final或者是effectively final的\n  - 在Lambda表达式中，不可以声明与(外部嵌套块)局部变量同名的参数或者局部变量\n- 表达式中的this，就是创建这个表达式的方法的this参数\n- 优先级比嵌套类要高\n  - 无法创建命名实例，无法获取自身的引用(this)\n- 方法引用比自定义Lambda表达式的优先级高\n  - 系统自带的方法引用更简洁高效\n  - 对于复杂的Lambda表达式，采用方法引用比内嵌Lambda表达式更清晰，更容易维护\n- 坚持使用标准的函数式接口","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}