{"content":"# 集合\n\n> 集合是java中提供的一种容器，可以用来存储多个数据\n\n## 类层次结构\n\n![批注 2020-07-02 091825](/assets/批注%202020-07-02%20091825.png)\n![202002201606](/assets/202002201606.jfif)\n\n- List 存储一组不唯一（可以有多个元素引用相同的对象），有序的对象\n- Set 不允许重复的集合。不会有多个元素引用相同的对象\n- Queue 被设计用来可以以某种优先级处理元素的集合\n- Map 使用键值对存储。Map会维护与Key有关联的值\n\n可以学习人家的接口是怎么划分的，这个类虽然接口众多，但是职责却很清晰\n\n以及人家是如何复用已有的代码来实现新功能\n\n## Iterator迭代器\n\n```java\nIterator<String> it = coll.iterator();\nwhile(it.hasNext()){ //判断是否有迭代元素\n    String s = it.next();//获取迭代出的元素\n    System.out.println(s);\n}\n```\n\n## List\n\nList 集合的遍历结果是稳定的\n\n- ArrayList\n    - 非线程安全\n    - 内部使用数组\n    - 快速随机访问 插入删除慢\n- LinkedList\n    - 本质双向链表\n    - 插入删除快 随机访问慢\n    - 内存利用率较高\n\n### 常用方法\n\n- public void add(int index, E element) : 将指定的元素，添加到该集合中的指定位置上。 -\n- public E get(int index) :返回集合中指定位置的元素。\n- public E remove(int index) : 移除列表中指定位置的元素, 返回的是被移除的元素。\n- public E set(int index, E element) :用指定元素替换集合中指定位置的元素,返回值的更新前的元素\n\n## Queue\n\n- FIFO\n- 阻塞队列阻塞的特性与FIFO结合 适合做Buffer\n\n## Map集合\n\n![批注 2019-08-02 100926](/assets/批注%202019-08-02%20100926.png)\n\n### 常用子类\n\nMap集合类            | Key          | Value        | Super       | JDK | 说明\n----------------- | ------------ | ------------ | ----------- | --- | ------------------\nHashtable         | **不允许为null** | **不允许为null** | Dictionary  | 1.0 | 线程安全（过时）\nConcurrentHashMap | **不允许为null** | **不允许为null** | AbstractMap | 1.5 | 锁分段技术或CAS(JDK8及以上)\nTreeMap           | **不允许为null** | 允许为null      | AbstractMap | 1.2 | 线程不安全(有序)\nHashMap           | 允许为null      | 允许为null      | AbstractMap | 1.2 | 线程不安全( resize死链问题)\n\n在任何Map中 都要避免KV设置为null\n\n- HashMap\n\n并发场景下 数据丢失 \n\n死链问题：并发情况下链表修改导致的不一致问题\n\n- ConcurrentHashMap\n\nJDK11后取消了分段锁机制 引入了红黑树结构 put remove size等操作都是用了CAS\n\n- LinkedHashMap \n- TreeMap key有序 基于红黑树实现\n\n并非一定要覆写hashCode与equals 其内部元素时通过Comparable与Comparator来实现key去重排序的\n\n### 常用方法\n\n- public V put(K key, V value) :  把指定的键与指定的值添加到Map集合中。 \n- public V remove(Object key) : 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的 值。 \n- public V get(Object key) 根据指定的键，在Map集合中获取对应的值。 \n- public Set<K> keySet() : 获取Map集合中所有的键，存储到Set集合中。 \n- public Set<Map.Entry<K,V>> entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。\n\n## Set集合\n\n- 不允许出现重复\n\n### HashSet\n\n> 底层使用hashmap\n\n![批注 2019-08-02 095407](/assets/批注%202019-08-02%20095407.png)\n\n存储自定义类型元素时，需要重写对象中的hashCode和equals方法\n\n### TreeSet\n\n底层使用TreeMap 保证Key有序\n\n### LinkedHashSet \n\n> 有序的哈希集合\n\n## Collections 工具类\n\n- public static <T> boolean addAll(Collection<T> c, T... elements) :往集合中添加一些元素。 \n- public static void shuffle(List<?> list) 打乱顺序 :打乱集合顺序。 \n- public static <T> void sort(List<T> list) :将集合中元素按照默认规则排序。 \n- public static <T> void sort(List<T> list，Comparator<? super T> ) :将集合中元素按照指定规则排序\n\n## 集合初始化\n\n- ArrayList的初始值为10 每次扩容以1.5倍的速度进行扩容\n- HashMap的初始值为16 每次扩容以2的幂进行扩容\n\n这样如果存放在集合的元素比较多 就会造成不断扩容 影响性能\n\n所以集合初始化时应该指定好默认值\n\n## 数组与集合\n\n```java\nnew int[-1]; // 运行时异常：NegativeArraySizeException：-1\n```\n\n数组遍历优先使用foreach方式\n\n### 数组转集合\n\n注意转集合的过程中是否使用了视图的方式：\n\nArrays.asList(...)这个方法返回了一个不可变的ArrayList（Arrays的内部类）,不能进行修改操作 否则会抛出异常\n\n### 集合转数组\n\n```java\nObject[] objects = list.toArray();// 泛型丢失\n\nString[] arr1 = new String[2];\nlist.toArray(arr1); // arr1为[null,null]\n\nString[] arr2 = new String[3];\nlist.toArray(arr2); // arr2为[1,2,3]\n```\n\n当toArray传入的数组容量比size小时 该方法就会弃用这个数组 而是自己创建一个数组返回\n\n当数组容量等于size时 运行时最快的,空间效率也是最高的\n\n## 集合与泛型\n\n```java\n//第一段:泛型出现之前的集合定义方式\nList al = new ArrayList();\nal.add (new Object());\nal.add (new Integer(111));\nal.add(new String(\"hello alal\"));\n\n//第二段:把a1引用赋值给a2，注意a2与al的区别是增加了泛型限制<object>\nList<Object> a2 = al;\na2.add (new Object());\na2.add (new Integer(222));\na2.add(new String(\"hello a2a2\")）;\n\n//第三段:把a1引用赋值给a3，注意a3与al的区别是增加了泛型<Integer>\nList<Integer> a3 = al;\na3.add(new Integer (333)）;\n下方两行编译出错，不允许增加非Integer类型进入集合\na3.add(new object());\na3.add(new String(\"hello a3a3\"));\n\n//第四段:把a1引用赋值给a4，al与a4的区别是增加了通配符\nList<?>a4 = al;\n//允许副除和清除元素\nal.remove(O);\na4.clear();\n// 编译出错。不允许增加任何元素\na4.add (new Object());\n```\n\n`<? extends T>` put功能受限 ?只能是T及T的子类型\n\n`<? super T>` get 功能受限 ?只能是T及T的父类型\n\n## 元素的比较\n\nComparable和Comparator两个接口的区别：\n- Comparable：自己与别人比较\n- Comparator：第三方比较两个对象\n\n### hashCode 与 equals\n\n通过哈希将数据分散开来\n\n- equals相等 则hashCode必须相等\n- 覆写equals 必须覆写hashCode\n\n```java\n// HashMap 判断两个key是否相等\nif (e.hash == hash &&\n    ((k = e.key) == key || (key != null && key.equals(k))))\n```\n\n## 快速失败机制\n\n当前线程维护一个expectedModCount 遍历之前这个值等于modCount\n\n如果在遍历的过程中发现 expectedModCount != modCount 就代表集合被别的线程修改了 这时候会跑出一个ConcurrentModificationException\n\n这个时候得使用迭代器来实现在遍历中修改集合的功能\n\n并发集合都是使用快速失败机制实现的 集合修改与遍历没有任何关系 但这种机制会导致读取不到最新的数据 也是CAP理论中 A与P的矛盾\n\n## 注意事项\n\n### 线程安全\n\nCollections 帮我们实现了 List、Set、Map 对应的线程安全的方法\n\nsynchronized打头的方法可以将指定的集合包装成线程安全的集合\n\n### 集合性能\n\n- 批量新增\n\n在 List 和 Map 大量数据新增的时候，我们不要使用 for 循环 + add/put 方法新增，这样子会有很大的扩容成本，我们应该尽量使用 addAll 和 putAll 方法进行新增\n\n- 批量删除\n\nArrayList的remove方法，删除之后都会对被删除位置的元素进行移动，如果进行循环remove，会造成性能问题，可以采用removeAll方法，这个批量删除接口只会对数组的元素移动一次\n\n### 集合的坑\n\n- Arrays.asList(array),当array被修改时，会造成list也被修改\n- toArray 方法如果声明的数组小于list长度，会得到一个空数组\n\n## JAVA7到JAVA8集合的升级\n\n- 所有集合都新增了forEach 方法\n- JAVA7中ArrayList无参初始化是直接初始化10，JAVA8无参初始化则是一个空数组\n- JAVA7中的HashMap无参初始化的大小是16，JAVA8无参初始化则是一个空数组，并且引入了红黑树，并且增加了xxIfAbsent等方法\n- Arrays 提供了很多 parallel 开头的方法，这些方法支持并行计算\n\n## Guava\n\n### 工厂模式初始化\n\n```java\nHashMap<Object, Object> map = Maps.newHashMap();\n```\n\n### Lists\n\n```java\nArrayList<String> list = Lists.newArrayList();\nArrayList<Object> objects = Lists.newArrayListWithCapacity(10);\n// 不知道精确值，给出一个模糊值\nArrayList<Object> objects1 = Lists.newArrayListWithExpectedSize(20);\n// 反转一个list，并非物理反转，而是通过对传入index的处理实现的\nvar list = Lists.reverse(list)\n// list拆分\nvar list = Lists.partition(list,3)\n```\n\n### Maps","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}