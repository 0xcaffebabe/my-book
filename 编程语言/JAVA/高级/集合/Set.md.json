{"content":"# Set源码解析\n\nHashSet、TreeSet 两个类是在 Map 的基础上组装起来的类\n\n## HashSet\n\nHashSet 使用的就是组合方式来内置 HashMap\n\n**多用组合，少用继承**\n\n### 操作\n\n- 初始化\n\n```java\n// 当根据传入的集合进行初始化时，会根据集合的数量计算HashMap大小\npublic HashSet(Collection<? extends E> c) {\n    map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));\n    addAll(c);\n}\n```\n\n### 值得借鉴的地方\n\n- 使用组合还是继承\n- 包装复杂逻辑，暴露易用api\n- 组合使用其他api时，要多了解组合的api\n\n## TreeSet\n\nTreeSet底层组合的是 TreeMap，迭代的时候，也可以按照 key 的排序顺序进行迭代\n\n### TreeSet如何复用TreeMap的\n\n第一种方式：直接使用\n\n```java\npublic boolean add(E e) {\n    return m.put(e, PRESENT)==null;\n}\n```\n\n第二种方式：定义接口，交给服务提供者实现\n\nTreeMap内部实现了NavigableSet接口来提供一些比较复杂的功能\n\n## 问题\n\n### TreeSet的使用场景\n\n一般都是在需要把元素进行排序的时候使用 TreeSet，使用时需要注意元素最好实现 Comparable 接口\n\n### 如何根据 key 的新增顺序进行遍历\n\n选择使用 LinkedHashSet\n\n### 如何对 key 进行去重\n\n使用TreeSet，TreeSet 底层使用的是 TreeMap，TreeMap 在 put 的时候，如果发现 key 是相同的，会把 value 值进行覆盖，所有不会产生重复的 key","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}