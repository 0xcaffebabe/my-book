{"content":"# 异常\n\n>指的是程序在执行过程中，出现的非正常的情况，终会导致JVM的非正常停止\n\n## 异常体系\n\n![批注 2020-05-27 165048](/assets/批注%202020-05-27%20165048.png)\n\n- Error（错误）:是程序无法处理的错误，表示运行应用程序中较严重问题\n- Exception（异常）:是程序本身可以处理的异常\n\n**分类**\n\n- 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) \n    - 无能为力,引起注意类型的异常 此类异常需要完整保存异常现场 供事后排查\n    - 可以处理的异常 如未授权异常\n- 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常)\n    - 可预测异常 应在编码时注意边界条件 空指针判断等来避免\n    - 需要捕获的异常 如超时异常 可以进行降级或者重试\n    - 可忽略异常 对于某些异常 框架或者系统会自行处理 这类异常可以不用管\n\n\n## 使用\n\n```java\ntry{\n    // do something\n}catch (Throwable t){\n    t.printStackTrace();\n    throw new RuntimeException(t);\n}finally {\n    // resource recycle\n    /*以下情况finally不会执行\n        前面的代码中用了 System.exit(int)已退出程序\n        try代码块出现了死循环或者死锁\n        CPU关闭\n    */\n}\n```\n\n## 注意事项\n\n- 多个异常一次捕获多次处理\n- 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 \n- 如果ﬁnally有return语句,永远返回ﬁnally中的结果,避免该情况、\n- 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异 常。 \n- 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不 能声明抛出 \n\n## 关于系统设计中的异常\n\n远程服务调用应该使用result对象来封装错误码与描述 主要是因为：\n\n1. 防止调用方没有捕获\n2. 异常对调用方的帮助不会很大\n\n基于防御式编程, 服务提供方可以返回null, 调用方要进行事先判断 防止NPE\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}