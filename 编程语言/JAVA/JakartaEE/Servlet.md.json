{"content":"# Servlets\n\n> server applet 运行在服务器端的小程序\n\n## WebServlet\n\n### 使用\n\n- 实现Servlet接口\n\n```java\npublic class MyServlet implements Servlet{\n   ...\n    @Override\n    public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {\n        servletResponse.getWriter().println(\"hello world\");\n    }\n    ...\n}\n```\n\n- 在web.xml配置\n\n```xml\n<servlet>\n    <servlet-name>MyServlet</servlet-name>\n    <servlet-class>wang.ismy.web.MyServlet</servlet-class>\n</servlet>\n<servlet-mapping>\n    <servlet-name>MyServlet</servlet-name>\n    <url-pattern>/*</url-pattern>\n</servlet-mapping>\n```\n\n### 原理\n\n- 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径\n- 查找web.xml文件，是否有对应的`<url-pattern>`标签体内容。\n- 如果有，则在找到对应的`<servlet-class>`全类名\n- tomcat会将字节码文件加载进内存，并且创建其对象\n- 调用其方法\n\n## 生命周期方法\n\n被创建：执行init方法，只执行一次\n\n```\n* Servlet什么时候被创建？\n            * 默认情况下，第一次被访问时，Servlet被创建\n            * 可以配置执行Servlet的创建时机。\n                * 在<servlet>标签下配置\n                    1\\. 第一次被访问时，创建\n                        * <load-on-startup>的值为负数\n                    2\\. 在服务器启动时，创建\n                        * <load-on-startup>的值为0或正整数\n\n        * Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的\n            * 多个用户同时访问时，可能存在线程安全问题。\n            * 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值\n```\n\n提供服务：执行service方法，执行多次\n\n```\n* 每次访问Servlet时，Service方法都会被调用一次。\n```\n\n被销毁：执行destroy方法，只执行一次\n\n```\n* Servlet被销毁时执行。服务器关闭时，Servlet被销毁\n        * 只有服务器正常关闭时，才会执行destroy方法。\n        * destroy方法在Servlet被销毁之前执行，一般用于释放资源\n```\n\n![](http://static.oschina.net/uploads/space/2015/0403/112707_yOnu_120166.jpg)\n\n### Servlet3.0\n\n- 加上注解后不用配置web.xml\n\n```java\n@WebServlet(\"/*\")\n```\n\n## 体系结构\n\n![批注 2019-08-09 093125](/assets/批注%202019-08-09%20093125.png)\n\n## 配置\n\n路径定义规则：\n\n- /xxx：路径匹配\n- /xxx/xxx:多层路径，目录结构\n- *.do：扩展名匹配\n\n## Request\n\n### 体系结构\n\n```\nrequest对象继承体系结构：    \n        ServletRequest        --    接口\n            |    继承\n        HttpServletRequest    -- 接口\n            |    实现\n        org.apache.catalina.connector.RequestFacade 类(tomcat)\n```\n\n### 方法\n\n- 获取请求行数据\n\n  - String getMethod()\n  - String getContextPath()\n  - String getServletPath()\n  - String getQueryString()\n  - String getRequestURI()\n  - String getProtocol()\n  - String getRemoteAddr()\n\n- 获取请求头数据\n\n  - String getHeader(String name)\n  - Enumeration\n\n    `string getHeaderNames()`\n\n- 获取请求体数据\n\n  - BufferedReader getReader()\n  - ServletInputStream getInputStream()\n\n- 其他\n\n  - String getParameter(String name)\n  - String[] getParameterValues(String name)\n  - `Map<string,string[]> getParameterMap()</string,string[]>`\n\n### 请求转发\n\n```java\nreq.getRequestDispatcher(\"/404\")\n                .forward(req,resp);\n```\n\n- 浏览器地址栏路径不发生变化\n- 只能转发到当前服务器内部资源中。\n- 转发是一次请求\n\n### 共享数据\n\n_request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据_\n\n- void setAttribute(String name,Object obj):存储数据\n- Object getAttitude(String name):通过键获取值\n- void removeAttribute(String name):通过键移除键值对\n\n## Response\n\n### 方法\n\n- 设置状态码：setStatus(int sc)\n- 字符输出流：PrintWriter getWriter()\n- 字节输出流：ServletOutputStream getOutputStream()\n\n```\n* 重定向的特点:redirect\n                1\\. 地址栏发生变化\n                2\\. 重定向可以访问其他站点(服务器)的资源\n                3\\. 重定向是两次请求。不能使用request对象来共享数据\n            * 转发的特点：forward\n                1\\. 转发地址栏路径不变\n                2\\. 转发只能访问当前服务器下的资源\n                3\\. 转发是一次请求，可以使用request对象来共享数据\n```\n\n### 乱码问题\n\n`PrintWriter pw = response.getWriter();`获取的流的默认编码是ISO-8859-1\n\n```java\n//设置编码，是在获取流之前设置\nresponse.setContentType(\"text/html;charset=utf-8\");\n```\n\n## **ServletContext**\n\n获取：\n\n- 通过request对象获取 `request.getServletContext();`\n- 通过HttpServlet获取 `this.getServletContext();`\n\n### 获取MIME类型\n\n```java\nSystem.out.println(getServletContext().getMimeType(\"a.jpg\"));\n```\n\n### 域对象：共享数据\n\n- setAttribute(String name,Object value)\n- getAttribute(String name)\n- removeAttribute(String name)\n\n### 获取文件真实路径\n\n- String getRealPath(String path)\n\n## Servlet 过滤器(Filter)\n\n> 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤\n\n```java\n@WebFilter\npublic class LoggingFilter implements Filter {\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        //...\n    }\n}\n```\n\n也可以不适用注解使用如下xml配置\n\n```xml\n<filter>\n    <filter-name>demo1</filter-name>\n    <filter-class>wang.ismy.javaee.LoggingFilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>demo1</filter-name>\n    <!-- 拦截路径 -->\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n```\n\n### 执行流程\n\n- 执行过滤器\n- 执行放行后的资源\n- 回来执行过滤器放行代码下边的代码\n\n### 生命周期方法\n\n- init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源\n- doFilter:每一次请求被拦截资源时，会执行。执行多次\n- destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源\n\n### 拦截方式配置：资源被访问的方式\n\n- REQUEST：默认值。浏览器直接请求资源\n- FORWARD：转发访问资源\n- INCLUDE：包含访问资源\n- ERROR：错误跳转资源\n- ASYNC：异步访问资源\n\n```java\n@WebFilter(value = \"/*\",dispatcherTypes = DispatcherType.ERROR)\n```\n\n### 过滤器链\n\n- 注解配置\n\n  - 按照类名字符串排序\n\n- web.xml配置\n\n  - 按照filter-mapping排序\n\n## 事件监听器(Listener)\n\n- ServletContextListener\n- HttpSessionListener\n- ServletRequestListener\n\n## 异步支持\n\n```java\n@WebServlet(urlPatterns = \"/hello\",asyncSupported = true)\npublic class MyServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        AsyncContext async = req.startAsync();\n        async.addListener(new AsyncListener() {\n            @Override\n            public void onComplete(AsyncEvent asyncEvent) throws IOException {\n                asyncEvent.getSuppliedResponse().getWriter().write(\"jntm\");\n            }\n            //...\n        });\n        new Thread(()->{\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            async.complete();\n        }).start();\n    }\n}\n```\n\n## 非阻塞IO\n\n```java\nAsyncContext async = req.startAsync();\nServletInputStream inputStream = req.getInputStream();\ninputStream.setReadListener(new ReadListener() {\n    @Override\n    public void onDataAvailable() throws IOException {\n        byte[] bytes = new byte[1024];\n        while (inputStream.isReady() && inputStream.read(bytes)!=-1){\n            System.out.println(new String(bytes));\n        }\n        async.complete();\n    }\n    @Override\n    public void onAllDataRead() throws IOException {\n        async.complete();\n    }\n    @Override\n    public void onError(Throwable throwable) {\n        throwable.printStackTrace();\n        async.complete();\n    }\n});\n```\n\n## WebFragment\n\n可以对XML配置进行分区\n\n## 安全\n\n- @ServletSecurity\n\n## 错误映射\n\n```xml\n<error-page>\n    <error-code>404</error-code>\n    <location>/404.html</location>\n</error-page>\n<error-page>\n    <exception-type>java.lang.RuntimeException</exception-type>\n    <location>/500.html</location>\n</error-page>\n```\n\n## 文件上传\n\n- @MultiPartConfig\n\n## 工作原理\n\n### Servlet\n\n体系结构：\n\n![屏幕截图 2020-10-06 105912](/assets/屏幕截图%202020-10-06%20105912.png)\n\nServletContexnt：贯穿请求的上下文\n\nServletConfig：传递参数集合\n\n- 创建\n\nStandardWrapper.loadServlet() 方法创建Servlet实例\n\n```java\nInstanceManager instanceManager = ((StandardContext)getParent()).getInstanceManager();\ntry {\n    servlet = (Servlet) instanceManager.newInstance(servletClass;\n...\n```\n\n- 初始化\n\nStandardWrapper.initServlet() 调用Servlet.init()\n\n```java\nservlet.init(facade);\n```","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}