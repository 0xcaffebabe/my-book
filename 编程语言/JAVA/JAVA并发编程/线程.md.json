{"content":"# 线程\n\n## 进程与线程\n\n进程是所有线程的集合，每一个线程是进程中的一条执行路径\n\n## 线程API之间的关系\n\n![202022320208](/assets/202022320208.jfif)\n\n## 线程分类\n\n- 用户线程\n  - 主线程\n  - 子线程\n- 守护线程\n  - *守护线程当进程不存在或主线程停止，守护线程也会被停止*\n  - GC线程\n\nHotSpot的每一个Java线程都是直接映射到一个操作系统原生线程来实现的\n\n## 创建线程\n\n### 继承Thread类\n\n```java\nclass MyThread extends Thread{\n    @Override\n    public void run() {}\n}\n```\n\n多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。进行方法的压栈和弹栈\n\n![批注 2019-08-02 115159](/assets/批注%202019-08-02%20115159.png)\n\nThread类\n\n- public String getName() :获取当前线程名称。\n- public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。\n- public void run() :此线程要执行的任务在此处定义代码。\n- public void yield():让出CPU，返回到就绪状态\n- join：等待被调用join的线程执行完毕再继续运行\n- public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。\n- public static Thread currentThread() :返回对当前正在执行的线程对象的引用\n\n**InterruptedException**\n\n调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞(sleep)、限期等待或者无限期等待(wait)状态，那么就会抛出 InterruptedException，从而提前结束该线程\n\n**interrupted()**\n\n在自定义线程执行任务使，可以使用这个方法作为一个flag，作为是否继续运行的依据\n\n```java\nwhile(interrupted()){\n    // do\n}\n// end\n```\n\n### 实现Runnable接口\n\n**实现Runnable接口比继承Thread类所具有的优势：**\n\n- 适合多个相同的程序代码的线程去共享同一个资源。\n- 可以避免java中的单继承的局限性。\n- 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。\n- 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。\n\n## Thread相关源码\n\n### 初始化\n\n```java\nprivate Thread(ThreadGroup g , Runnable target, String name,\n                   long stackSize, AccessControlContext acc,\n                   boolean inheritThreadLocals) {\n        if (name == null) {\n            throw new NullPointerException(\"name cannot be null\");\n        }\n\n        this.name = name;\n        // 当前线程作为这条线程的父线程\n        Thread parent = currentThread();\n        // 一些安全检查\n        SecurityManager security = System.getSecurityManager();\n        if (g == null) {\n           \n            if (security != null) {\n                g = security.getThreadGroup();\n            }\n\n            if (g == null) {\n                g = parent.getThreadGroup();\n            }\n        }\n\n        g.checkAccess();\n        // 权限检查\n        if (security != null) {\n            if (isCCLOverridden(getClass())) {\n                security.checkPermission(\n                        SecurityConstants.SUBCLASS_IMPLEMENTATION_PERMISSION);\n            }\n        }\n\n        g.addUnstarted();\n        // 设置线程组\n        this.group = g;\n        // 继承父线程的一些属性，包括是否是守护线程、线程优先级等\n        this.daemon = parent.isDaemon();\n        this.priority = parent.getPriority();\n        if (security == null || isCCLOverridden(parent.getClass()))\n            this.contextClassLoader = parent.getContextClassLoader();\n        else\n            this.contextClassLoader = parent.contextClassLoader;\n        this.inheritedAccessControlContext =\n                acc != null ? acc : AccessController.getContext();\n        this.target = target;\n        // 设置线程优先级\n        setPriority(priority);\n        if (inheritThreadLocals && parent.inheritableThreadLocals != null)\n            this.inheritableThreadLocals =\n                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);\n        // 设置线程栈大小\n        this.stackSize = stackSize;\n\n        /* Set thread ID */\n        this.tid = nextThreadID();\n    }\n```\n\n### 启动\n\n```java\npublic synchronized void start() {\n    // 线程并非NEW状态\n    if (threadStatus != 0)\n        throw new IllegalThreadStateException();\n    // 通知线程组加入自身\n    group.add(this);\n            \n    boolean started = false;\n    try {\n        // 调用native方法启动线程\n        start0();\n        started = true;\n    } finally {\n        try {\n            // 如果启动失败，通知线程组启动失败\n            if (!started) {\n                group.threadStartFailed(this);\n            }\n        } catch (Throwable ignore) {\n            /* do nothing. If start0 threw a Throwable then\n              it will be passed up the call stack */\n        }\n    }\n}\n```\n\n### join\n\njoin 的意思就是当前线程(currentThread)等待另一个线程(调用join的那个线程)执行完成之后，才能继续操作\n\n```java\npublic final synchronized void join(final long millis)\nthrows InterruptedException {\n    if (millis > 0) {\n        // 判断自身是否已执行完毕，\n        if (isAlive()) {\n            // 如果还未完毕等待一定的时间\n            final long startTime = System.nanoTime();\n            long delay = millis;\n            do {\n                wait(delay);\n            } while (isAlive() && (delay = millis -\n                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) > 0);\n        }\n    // 无限等待\n    } else if (millis == 0) {\n        // 原理就是自旋判断自身是否已经执行完毕\n        while (isAlive()) {\n            // 如果还未执行完毕，则进入wait\n            wait(0);\n        }\n    } else {\n        throw new IllegalArgumentException(\"timeout value is negative\");\n    }\n}\n```\n\n## 线程调度\n\n- Java 使用的抢占式调度多线程系统\n\n可以通过Thread实例setPriority来调整优先级，不过此举总体而言不是一个文档的调节手段\n\n## 线程状态\n\n![批注 2020-06-17 111804](/assets/批注%202020-06-17%20111804.png)\n\n线程状态                | 导致状态发生条件\n------------------- | -------------------------------------------------------------------------------------------------------------\nNEW(新建)             | 线程刚被创建，但是并未启动。还没调用start方法。\nRunnable(可运行)       | 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操 作系统处理器。\nBlocked(锁阻塞)        | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状 态；当该线程持有锁时，该线程将变成Runnable状态。\nWaiting(无限等待)       | 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个 状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。\nTimed Waiting(计时等待) | 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态 将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、 Object.wait。\nTeminated(被终止)      | 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}