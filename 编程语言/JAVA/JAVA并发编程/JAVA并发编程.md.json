{"content":"# 并发编程\n\n- 并发：指两个或多个事件在同一个时间段内发生。\n- 并行：指两个或多个事件在同一时刻发生（同时发生）。\n\n超线程：一个ALU对应多个PC\n\n并发程序的特点：\n\n- 线程之间相互制约的关系\n- 线程执行过程需要上下文切换　断断续续的\n- 并发数设置合理时(以CPU)　才会提高并发程序的性能\n\n## 线程安全\n\n线程安全性：当多个线程访问某个类时，这个类始终都能表现出正确的行为，则称这个类是线程安全的\n\n线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步， 否则的话就可能影响线程安全。\n\n无状态对象一定是线程安全的。\n\nJAVA API中的线程安全问题\n\n- StringBuffer\n- Vector\n\n### 原子性\n\n```java\nif (condition){\n    a++; // 当此段代码运行在多线程的环境时，则会产生线程安全问题\n}\n```\n\n观察结果的失效就是大多数竞态条件的本质\n\n一种常见的竞态条件发生在单例构造模式中：\n\n```java\npublic static Object get(){\n\n    if (instance == null){\n        instance = new Object();\n    }\n    return instance;\n}\n```\n\n为了解决观察失效这个问题，也就是为了避免静态条件，就需要对一组操作进行原子化，即不可分割。要不全做，要不就不做。这组操作称之为复合操作。\n\n- 复合操作：由一系列原子操作构成\n\n## 锁\n\n### 非阻塞同步\n\n互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步\n\n悲观的并发策略：认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁\n\n乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施\n\n### 悲观锁 乐观锁\n\n- 乐观锁\n\n总是认为不会产生并发问题，每次去取数据的时候总认为不会有其他线程对数据进行修改，因此不会上锁，但是在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现\n\n```sql\nupdate table set x=x+1, version=version+1 where id=${id} and version=${version};\n```\n\n- 悲观锁\n\n总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以都会加锁（读锁、写锁、行锁等），当其他线程想要访问数据时，都需要阻塞挂起\n\nsynchronized是悲观锁\n\n### 自旋锁\n\n>线程反复检查锁变量是否可用。由于线程在这一过程中保持执行，因此是一种忙等待\n\n### 分布式锁\n\n- zookeeper与redis实现\n\n## 线程间通信\n\n- 等待-唤醒机制\n\n![06_等待唤醒案例分析](/assets/06_等待唤醒案例分析.bmp)\n\n要注意，wait() notify() notifyAll()都需要在synchronized中\n\nwait() 会释放锁，sleep() 不会\n\n```java\nObject object = new Object();\n\nnew Thread(){\n    @Override\n    public void run() {\n        synchronized (object){\n            System.out.println(\"要5个包子\");\n            // 进入等待，这时候锁会被释放\n            try {\n                object.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(\"得到了5个包子\");\n        }\n    }\n}.start();\n\nnew Thread(){\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        synchronized (object){\n            System.out.println(\"包子生产完毕，告诉顾客\");\n            // 通知等待线程中的任意一个\n            object.notify();\n        }\n    }\n}.start();\n```\n\n- wait与notify一定要在线程同步中使用,并且是同一个锁的资源\n- 在调用sleep()方法的过程中，线程不会释放对象锁\n\n## 对象的共享\n\n发布:\n\n> 使对象能在当前代码作用域之外使用\n\n逸出:\n\n> 某个不该发布的对象被发布了\n\n### 线程封闭\n\n> 某个对象只能在线程之内使用\n\n- Ad-hoc线程封闭\n\n  - 完全由程序承担，很脆弱\n\n- 栈封闭\n\n  - 对象只能在局部（方法内）使用\n\n### 不变性\n\n> 不可变对象一定是线程安全的\n\n- 对象创建后其状态就不能修改\n- 对象的所有域都是final\n- 在对象创建的过程中this引用没有逸出\n\n### 安全发布\n\n- 在静态初始化函数中初始化一个对象的引用\n- 将对象的引用保存到volatile类型的域或者 Reference对象\n- 将对象的引用保存到正确初始化的对象的final域\n- 将对象的引用保存到由锁保护的域\n\n## 对象的组合\n\n**依赖状态的操作**：某个操作包含有基于状态的先验操作\n\n```java\nif (a== 1){\n    a++;\n}\n```\n\n### 实例封闭\n\n> 将线程不安全的对象封装在某个进行良好并发控制的对象内\n\n- 客户端加锁\n\n```java\nprivate Object obj = new Object();\n...\nsynchronized(obj){\n    obj.xxx();\n}\n```\n\n## 基础构建模块\n\n> JAVA5后自带了很多有关并发编程的类库\n\n### 同步容器类\n\n- 迭代器与ConcurrentModificationException\n  - 当在迭代的时候，容器元素发生了修改，则会抛出这个异常\n\n### 执行策略\n\n- 什么线程\n- 什么顺序\n- 多少任务执行\n- 多少任务等待\n- 如何放弃以及通知放弃\n- 任务执行前操作\n\n## 取消与关闭\n\n- 取消策略\n\n通常，使用中断来取消是最合理的方式\n\n```java\nclass MyThread extends  Thread{\n\n    @Override\n    public void run() {\n        while(!isInterrupted()){\n            System.out.println(\"running\");\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n        System.out.println(\"my thread done\");\n    }\n}\n```\n\n### 使用Future取消\n\n```java\nFuture<Double> future = service.submit(() -> {\n    try {\n        Thread.sleep(2000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    return Math.random();\n});\ntry {\n    Double ret = future.get(3, TimeUnit.SECONDS);\n    System.out.println(\"result\"+ret);\n} catch (ExecutionException | TimeoutException e) {\n    e.printStackTrace();\n}finally {\n    future.cancel(true);\n    System.out.println(\"task cancel\");\n}\n```\n\n### 处理不可中断的阻塞\n\n由于如IO等的资源一旦阻塞就无法进行中断，所以可对其做关闭处理来模拟中断\n\n## 停止基于线程的服务\n\n- 使用生命周期管理ExecutorService\n- 毒药对象\n  - 本质上就是一个flag，当队列读取到这个毒药时，就会停止相关操作\n\n## 处理非正常的线程终止\n\n```java\nhread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n    @Override\n    public void uncaughtException(Thread t, Throwable e) {\n        System.out.println(t + \"something happen\" + e);\n    }\n});\n\nnew Thread(){\n    @Override\n    public void run() {\n        throw new RuntimeException(\"aaaa\");\n    }\n}.start();\n```\n\n## JVM关闭钩子\n\n```java\nRuntime.getRuntime().addShutdownHook(new Thread(){\n    @Override\n    public void run() {\n        System.out.println(\"jvm shutdown\");\n    }\n});\n```\n\n## 活跃性危险\n\n- 死锁\n    - 静态顺序死锁\n    - 动态顺序死锁\n    - 资源死锁\n>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。\n\n### 诊断与避免\n\n- 定时锁\n  - 获取-超时-退出\n\n### 其他活跃性危险\n\n- 饥饿\n  - 无法获取到需要的资源\n- 响应性慢\n- 活锁\n  - 线程不断重复某个操作\n\n## 性能与伸缩性\n\n- 引入线程的开销\n  - 上下文切换\n  - 内存同步\n  - 阻塞\n\n## 如何减少锁的竞争\n\n- 缩小锁的范围\n  - 缩小synchronized关键字包围的代码块\n- 减小锁的粒度\n  - 不同的操作使用不同的锁\n- 分段锁\n- 替代独占锁\n  - 采取读写锁\n\n## 并发程序测试\n\n- 正确性测试\n- 安全性测试\n- 性能测试\n\n### 性能测试陷阱\n\n- 垃圾回收\n- 动态编译（JIT）\n- 编译优化\n- 竞争程度\n\n## 锁优化\n\n### 自旋锁与自适应自旋\n\n是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态\n\n自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，如果等待时间比较短，自旋还是很划算的\n\n自旋超过一定的阈值就不会再继续重试，自适应自旋则代表这个阈值不是固定的，会根据性能监控情况动态调整\n\n### 锁消除\n\n对于被检测出不可能存在竞争的共享数据的锁进行消除\n\n### 锁细化\n\n经历缩小锁的作用范围\n\n### 锁粗化\n\n如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗\n\n如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部\n\n```java\nsynchronized(obj){\n    //...\n}\nsynchronized(obj){\n    //...\n}\nsynchronized(obj){\n    //...\n}\n```\n\n```java\nsynchronized(obj){\n    //...\n    //..\n    //...\n}\n```\n\n### 轻量级锁\n\n轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销\n\n### 偏向锁\n\n偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要\n\n## 并发编程良好实践\n\n- 给线程起名字\n- 缩小同步范围\n- 多用同步工具少用原始的wait,notify\n- 使用阻塞队列\n- 多用 ConcurrentHashMap 而不是 Hashtable\n- 使用栈封闭以及不变性保证线程安全\n- 使用线程池\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}