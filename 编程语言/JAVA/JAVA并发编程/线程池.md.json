{"content":"# 线程池\n\n作用：\n\n- 线程复用　控制最大并发数\n- 实现任务缓存策略以及拒绝策略\n- 定期执行　周期执行\n- 隔离不同业务的线程执行环境\n\n解决了两个问题：\n\n1：通过减少任务间的调度开销 (主要是通过线程池中的线程被重复使用的方式)，来提高大量任务时的执行性能；\n2：提供了一种方式来管理线程和消费，维护基本数据统计等工作\n\n## Executor框架\n\n```java\npublic interface Executor {\n  void execute(Runnable command);\n}\n```\n\nExecutorService继承了Executor，增加了一些方法\n\n```java\npublic interface ExecutorService extends Executor {\n    // 平缓关闭\n    void shutdown();\n\n    // 粗暴关闭\n    List<Runnable> shutdownNow();\n\n    boolean isShutdown();\n\n    boolean isTerminated();\n\n    boolean awaitTermination(long timeout, TimeUnit unit)\n        throws InterruptedException;\n\n    <T> Future<T> submit(Callable<T> task);\n\n    <T> Future<T> submit(Runnable task, T result);\n\n    Future<?> submit(Runnable task);\n\n    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException;\n\n    <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException, ExecutionException;\n}\n```\n\n### excute&submit\n\n使用这两个方法一定要注意，execute会将runnable交给worker去执行，出现异常会打印异常栈。\n\n而submit方法则会将runnable包装成一个ScheduledFutureTask 这个类会将异常吞掉，不会打印异常栈。\n\n## Callable\n\n- 拥有返回值\n\n## Future\n\n>用来执行一些较长时间的计算，通过get来获取结果（阻塞或者超时）\n\n用于异步获取执行结果或取消执行任务的场景\n\n```java\nFutureTask<Integer> futureTask = new FutureTask<>(() -> {\n    int result = 0;\n    for (int i = 0; i < 100; i++) {\n        Thread.sleep(10);\n        result += i;\n    }\n    return result;\n});\nnew Thread(futureTask).start();\nSystem.out.println(futureTask.get());\n```\n\n```java\nFuture<String> future = pool.submit(() -> {\n    Thread.sleep(3000);\n    return \"java\";\n});\nString s = future.get();\n```\n\n### Future模式\n\n```java\npublic class Main {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        MyFuture myFuture = new MyFuture();\n        // 在这里 main thread 可以做其他事情\n        // 下一行代码将阻塞直到结果可用\n        System.out.println(myFuture.getData());\n    }\n}\n\nclass MyFuture{\n    private volatile boolean FLAG = false;\n    private String data;\n\n    public MyFuture() {\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"future 任务开始 睡眠 3000ms\");\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(\"future 任务结束\");\n                setData(\"jntm\");\n            }\n        }).start();\n    }\n\n    private synchronized void setData(String data){\n        if (FLAG){\n            return;\n        }\n        this.data = data;\n        FLAG = true;\n        notify();\n    }\n\n    public synchronized String getData(){\n        while (!FLAG){\n            try {\n                wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        return data;\n    }\n}\n```\n\n### 初始化\n\n```java\npublic FutureTask(Callable<V> callable) {\n    if (callable == null)\n        throw new NullPointerException();\n    this.callable = callable;\n    this.state = NEW;       // ensure visibility of callable\n}\n\npublic FutureTask(Runnable runnable, V result) {\n    // 将runnable包装成callable，内部是通过适配器的方式来实现的\n    this.callable = Executors.callable(runnable, result);\n    this.state = NEW;       // ensure visibility of callable\n}\n```\n\n```java\nRunnableAdapter(Runnable task, T result) {\n            this.task = task;\n            this.result = result;\n        }\npublic T call() {\n    task.run();\n    return result;\n}\n```\n\n### get\n\n```java\npublic V get() throws InterruptedException, ExecutionException {\n    int s = state;\n    if (s <= COMPLETING)\n        // 这里会一直阻塞到任务完成\n        s = awaitDone(false, 0L);\n    return report(s);\n}\nprivate int awaitDone(boolean timed, long nanos)\n    throws InterruptedException {\n    \n    long startTime = 0L;    // Special value 0L means not yet parked\n    WaitNode q = null;\n    boolean queued = false;\n    // 无限循环\n    for (;;) {\n        int s = state;\n        // 如果任务已经完成，返回\n        if (s > COMPLETING) {\n            if (q != null)\n                q.thread = null;\n            return s;\n        }\n        // 还未完成，让线程调度器重新调度，防止占着不放\n        else if (s == COMPLETING)\n            Thread.yield();\n        // 线程被打断，抛出异常\n        else if (Thread.interrupted()) {\n            removeWaiter(q);\n            throw new InterruptedException();\n        }\n        // 第一次运行，创建一些信息\n        else if (q == null) {\n            if (timed && nanos <= 0L)\n                return s;\n            q = new WaitNode();\n        }\n        else if (!queued)\n            queued = WAITERS.weakCompareAndSet(this, q.next = waiters, q);\n        else if (timed) {\n            final long parkNanos;\n            if (startTime == 0L) { // first time\n                startTime = System.nanoTime();\n                if (startTime == 0L)\n                    startTime = 1L;\n                parkNanos = nanos;\n            } else {\n                long elapsed = System.nanoTime() - startTime;\n                if (elapsed >= nanos) {\n                    removeWaiter(q);\n                    return state;\n                }\n                parkNanos = nanos - elapsed;\n            }\n            // nanoTime may be slow; recheck before parking\n            if (state < COMPLETING)\n                LockSupport.parkNanos(this, parkNanos);\n        }\n        else\n            LockSupport.park(this);\n    }\n}\n```\n\n### run\n\n```java\npublic void run() {\n    // 状态不对\n    if (state != NEW ||\n        !RUNNER.compareAndSet(this, null, Thread.currentThread()))\n        return;\n    try {\n        Callable<V> c = callable;\n        // 状态正确时进入\n        if (c != null && state == NEW) {\n            V result;\n            boolean ran;\n            try {\n                // 执行主体\n                result = c.call();\n                // 标记执行完成\n                ran = true;\n            } catch (Throwable ex) {\n                // 标记失败\n                result = null;\n                ran = false;\n                setException(ex);\n            }\n            if (ran)\n                set(result);\n        }\n    } finally {\n        runner = null;\n        int s = state;\n        if (s >= INTERRUPTING)\n            handlePossibleCancellationInterrupt(s);\n    }\n}\n```\n\n### cancel\n\n```java\npublic boolean cancel(boolean mayInterruptIfRunning) {\n    // 状态不对\n    if (!(state == NEW && STATE.compareAndSet\n          (this, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))\n        return false;\n    try {    // in case call to interrupt throws exception\n        if (mayInterruptIfRunning) {\n            try {\n                // 通过设置中断位来停止线程\n                Thread t = runner;\n                if (t != null)\n                    t.interrupt();\n            } finally { // final state\n                STATE.setRelease(this, INTERRUPTED);\n            }\n        }\n    } finally {\n        finishCompletion();\n    }\n    return true;\n}\n```\n\n## 线程池分类\n\n- ThreadPollExecutor\n- ForkJoinPool\n  - 分解汇总的任务\n  - 用很少的线程可以执行很多的任务(子任务) TPE做不到先执行子任务\n  - CPU密集型\n\n### ThreadPollExecutor\n\nExecutors：线程池工厂（**不推荐使用**）\n\n- newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。这个线程池的最大线程数能达到整数的最大值\n- newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。\n- newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。同样　线程最大数也是整数最大值\n- newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行\n- newWorkSealingPool jdk8引入　使用多个队列来减少竞争\n\n这个线程工厂大部分都使用了无界队列　如果瞬间请求量大　很有可能造成oom\n\n队列在线程池中起的作用：\n\n请求数大于 coreSize 时，可以让任务在队列中排队，让线程池中的线程慢慢的消费请求，当线程消费完所有的线程后，会阻塞的从队列中拿数据，通过队列阻塞的功能，使线程不消亡\n\n#### 原理\n\n![批注 2020-07-07 131242](/assets/批注%202020-07-07%20131242.png)\n![2020227152611](/assets/2020227152611.jfif)\n\n- 运行状态图\n\n![2020227153022](/assets/2020227153022.jfif)\n\n#### 自定义\n\n```java\nThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(\n  2/*实际运行线程数 （不管它们创建以后是不是空闲的。线程池需要保持 corePoolSize 数量的线程）*/,\n  3/*最多允许创建的线程数*/,\n  0L /* 让线程存活的时间 0为永久 */,\n  TimeUnit.SECONDS,\n  new ArrayBlockingQueue<>(4)/*  线程池的内部队列 */,\n  Executors.defaultThreadFactory()/* 产生线程的方式 */,\n  new ThreadPoolExecutor.DiscardOldestPolicy() /* 线程池满时的拒绝策略 */\n  );\n```\n\n参数：\n\n1. corePoolSize 如果等于0 则任务执行结束后就会销毁所有线程　如果大于0　任务执行后这些线程不会被销毁\n2. maximumPoolSize 能最大同时容纳的线程数　如果任务数量大于这个数　那么剩下的任务就要被缓存在一个阻塞队列中\n3. keepAliveTime 表示线程池中的线程空闲时间　多于corePoolSize数量的部分线程会被销毁\n4. 时间单位\n5. workQUeue 缓存队列\n6. threadFactory 定义线程池线程的产生方式\n7. handler 任务拒绝策略\n\n值得注意的是，上述参数除了缓存队列，其他参数都是可以在运行时动态调整的。\n\n为了能达到动态调整队列长度的目的：可以通过实现自己的阻塞队列来实现。\n\n如何配置：\n\n- CPU密集型\n- IO密集型\n\n自定义线程工厂　为线程指定有意义的名称和相应的序列号　方便出错排查\n\n定义好拒绝策略　宁愿抛出异常　也不要使用DiscardPolicy 这个策略会静悄悄的抛弃任务\n\n线程池预热：\n\n- prestartCoreThread\n- prestartAllCoreThreads\n\n设置回收核心线程：\n\n- allowCoreThreadTimeOut\n\n##### 线程池的大小\n\nN<sub>cpu</sub> = CPU数量\nU<sub>cpu</sub> = 预期CPU使用率\nW/C = 等待时间/计算时间\n\n最优大小等于 N<sub>cpu</sub> * U<sub>cpu</sub> * (1 + W/C)\n\n但这个公式过于学术，在生产环境中，这些时间很难计算 更多地是靠场景根据经验来设置各个参数 或是根据监控来动态调整参数以观察效果\n\n##### 应用场景\n\n- coreSize == maxSize\n\n让线程一下子增加到 maxSize，并且不要回收线程，防止线程回收，避免不断增加回收的损耗\n\n- maxSize 无界 + SynchronousQueue\n\n当任务被消费时，才会返回，这样请求就能够知道当前请求是已经在被消费了，如果是其他的队列的话，我们只知道任务已经被提交成功了，但无法知道当前任务是在被消费中，还是正在队列中堆积\n\n比较消耗资源，大量请求到来时，我们会新建大量的线程来处理请求\n\n- maxSize 有界 + Queue 无界\n\n对实时性要求不大，但流量忽高忽低的场景下，可以使用这种方式\n\n当流量高峰时，大量的请求被阻塞在队列中，对于请求的实时性难以保证\n\n- maxSize 有界 + Queue 有界\n\n把队列从无界修改成有界，只要排队的任务在要求的时间内，能够完成任务即可\n\n- keepAliveTime 设置无穷大\n\n想要空闲的线程不被回收，我们可以设置 keepAliveTime 为无穷大值\n\n##### 线程池的公用和独立\n\n查询和写入不公用线程池，如果公用的话，当查询量很大时，写入的请求可能会到队列中去排队，无法及时被处理\n\n原则上来说，每个写入业务场景都独自使用自己的线程池，绝不共用，这样在业务治理、限流、熔断方面都比较容易\n多个查询业务场景是可以公用线程池的\n\n#### Wroker\n\n在线程池中，最小的执行单位就是 Worker\n\n```java\nprivate final class Worker\n        extends AbstractQueuedSynchronizer\n        implements Runnable\n{\n      \n\n        // 运行任务的线程\n        final Thread thread;\n        // 任务代码块\n        Runnable firstTask;\n        /** Per-thread task counter */\n        volatile long completedTasks;\n\n        Worker(Runnable firstTask) {\n            // 把自己作为一个代码块穿给线程\n            setState(-1); // inhibit interrupts until runWorker\n            this.firstTask = firstTask;\n            // 线程是通过线程工程创建的\n            this.thread = getThreadFactory().newThread(this);\n        }\n\n        public void run() {\n            // 这里就将任务的执行交给线程池了\n            runWorker(this);\n        }\n        ...\n}\n```\n\n#### 任务提交\n\n```java\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n    int c = ctl.get();\n    // 如果工作线程数小于coreSize\n    if (workerCountOf(c) < corePoolSize) {\n        // 则直接创建worker执行\n        if (addWorker(command, true))\n            return;\n        c = ctl.get();\n    }\n    // 如果线程池状态正常，并且工作队列还能入队\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        // 线程池状态异常，尝试从队列移除任务\n        if (! isRunning(recheck) && remove(command))\n            // 移除成功就拒绝任务\n            reject(command);\n        // 工作线程为0\n        else if (workerCountOf(recheck) == 0)\n            // 直接创建worker执行\n            addWorker(null, false);\n    }\n    // 队列满了，如果线程数超过maxSize，拒绝任务\n    else if (!addWorker(command, false))\n        reject(command);\n}\n```\n\naddWorker 方法首先是执行了一堆校验，然后使用 new Worker (firstTask) 新建了 Worker，最后使用 t.start () 执行 Worker，所以 t.start () 会执行到 Worker 的 run 方法上,到runWorker 方法里\n\n```java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    // 校验各种状态\n    for (int c = ctl.get();;) {\n        // Check if queue empty only if necessary.\n        if (runStateAtLeast(c, SHUTDOWN)\n            && (runStateAtLeast(c, STOP)\n                || firstTask != null\n                || workQueue.isEmpty()))\n            return false;\n        for (;;) {\n            if (workerCountOf(c)\n                >= ((core ? corePoolSize : maximumPoolSize) & COUNT_MASK))\n                return false;\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            c = ctl.get();  // Re-read ctl\n            if (runStateAtLeast(c, SHUTDOWN))\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        // 把任务交给worker，此时要执行的任务就已经传入给worker里面的thread了\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                // Recheck while holding lock.\n                // Back out on ThreadFactory failure or if\n                // shut down before lock acquired.\n                int c = ctl.get();\n                // 检查线程池状态\n                if (isRunning(c) ||\n                    (runStateLessThan(c, STOP) && firstTask == null)) {\n                    if (t.getState() != Thread.State.NEW)\n                        throw new IllegalThreadStateException();\n                    workers.add(w);\n                    workerAdded = true;\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                // 启动线程，执行worker\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n```\n\n```java\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        // 所以说在这里，在不断地取任务执行\n        // 如果要执行的task为空，则会去取一个task，取不到就阻塞\n        while (task != null || (task = getTask()) != null) {\n            // 锁住worker，防止一个任务多个线程执行\n            w.lock();\n            // 线程池stop了，让线程中断\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                // 执行前钩子函数\n                beforeExecute(wt, task);\n                try {\n                    // 执行真正的任务\n                    // 而执行这个任务的线程就是worker里面的thread\n                    task.run();\n                    // 执行后钩子函数\n                    afterExecute(task, null);\n                } catch (Throwable ex) {\n                    // 异常钩子函数\n                    afterExecute(task, ex);\n                    throw ex;\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n\n```java\nprivate Runnable getTask() {\n    // 如果设置了线程超时时间，超过一定时间没有任务，超出coreSize部分的线程会被回收\n    boolean timedOut = false; // Did the last poll() time out?\n    for (;;) {\n        int c = ctl.get();\n        // 检查线程池状态\n        if (runStateAtLeast(c, SHUTDOWN)\n            && (runStateAtLeast(c, STOP) || workQueue.isEmpty())) {\n            decrementWorkerCount();\n            return null;\n        }\n        int wc = workerCountOf(c);\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n        // 如果线程数大于maxSize但是存活时间还没超过keepalive，则跳过后面取任务的部分\n        if ((wc > maximumPoolSize || (timed && timedOut))\n            && (wc > 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n        try {\n            // 超过keepAliveTime时间取不到数据就返回，此时线程不再运行，结束了，JVM会回收掉\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n\n### ForkJoinPool\n\nFork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架\n\n![202199163034](/assets/202199163034.png)\n\n- 工作窃取（work-stealing）：指某个线程从其他队列里窃取任务来执行\n\n#### 构造器\n\n```java\npublic ForkJoinPool() {...} // 创建一个拥有处理器数量的线程池\npublic ForkJoinPool(int parallelism){...} // 自定义并行度\n```\n\n#### 使用\n\n```java\nForkJoinPool pool = new ForkJoinPool();\npool.execute(...);\n```\n\nexecute 方法传递的任务有两个抽象子类：\n\n- RecursiveAction 无返回值任务\n- RecursiveTask 有返回值任务\n\n```java\nclass RaskDemo extends RecursiveAction {\n    /**\n     *  每个\"小任务\"最多只打印20个数\n     */\n    private static final int MAX = 20;\n\n    private int start;\n    private int end;\n\n    public RaskDemo(int start, int end) {\n        this.start = start;\n        this.end = end;\n    }\n\n    @Override\n    protected void compute() {\n        //当end-start的值小于MAX时，开始打印\n        if((end-start) < MAX) {\n            for(int i= start; i<end;i++) {\n                System.out.println(Thread.currentThread().getName()+\"i的值\"+i);\n            }\n        }else {\n            // 将大任务分解成两个小任务\n            int middle = (start + end) / 2;\n            RaskDemo left = new RaskDemo(start, middle);\n            RaskDemo right = new RaskDemo(middle, end);\n            left.fork();\n            right.fork();\n        }\n    }\n}\n```\n\n两个抽象子类的区别在于有返回值的任务在调用compute后最终会返回计算结果 无论是自己计算的 还是对子任务的合并\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}