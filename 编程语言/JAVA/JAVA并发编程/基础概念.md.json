{"content":"# 基础概念\n\n## 线程安全\n\n>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的\n\n### 不可变\n\n不可变的对象一定是线程安全的\n\n这种对象的接口一般需要精心设计 最简单的方式是所有成员变量设置为final\n\n### 绝对线程安全\n\n不管运行时环境如何，调用者都不需要任何额外的同步措施\n\n### 相对线程安全\n\n要保证对这个对象单次的操作是线程安全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性\n\n### 线程兼容\n\n对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用\n\n### 线程对立\n\n指不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码\n\n## 线程安全的实现\n\n### 互斥同步\n\n- synchronized\n- Lock\n\n### 非阻塞同步\n\n- CAS\n\n### 无同步方案\n\n- 可重入代码：类似于函数式编程\n- 线程本地存储\n\n## synchronized\n\n使用了锁对象，这个锁对象一瞬间只能被一个线程所持有\n\n```java\nsynchronized(this){ // 可以是任意一个对象\n  // 需要同步操作的代码\n}\n```\n```java\npublic synchronized void method(){ // 也可以同步静态方法，等同于上面的synchronize(this)\n  // 可能会产生线程安全问题的代码   \n}\n```\n\nsynchronized是可重入锁\n\n> 重入：某个线程试图获得一个已经由它持有的锁\n\n程序执行过程中发生异常，锁会被释放\n\n不能使用String常量，以及int long等原始类型\n\n**synchronized底层**\n\nJDK早期的 使用的重量级实现 也就说在 OS 层面\n后来的进行了改进\n\nsynchronized实现过程\n\n- java代码：synchronized\n- 字节码： monitorenter monitorexit\n- 执行过程中会进行锁升级\n- lock comxchg\n\n锁升级：\n\n在 markword 中记录记录获取锁的这个线程ID 此时是偏向锁。线程通过判断这个ID是否为自身来判断自己是不是获得了偏向锁。偏向锁在资源无竞争情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能\n\n但如果应用程序里所有的锁通常处于竞争状态，那么偏向锁就会是一种累赘\n\n```\n-XX:UseBiasedLocking=false\n```\n\n可以关闭偏向锁\n\n如果发现markword的不是自己的线程ID 则升级为 自旋锁\n\n在自旋一定次数以后，不能获得锁，则升级为OS层面的重量级锁\n\n执行时间短（加锁代码），线程数少，用自旋\n执行时间长，线程数多，用系统锁\n\n锁降级：锁降级发生的条件会比较苛刻，锁降级发生在Stop The World期间，当JVM进入安全点的时候，会检查是否有闲置的锁，然后进行降级\n\n## volatile\n\n任何对被volatile关键字修饰的变量都会在主内存操作　不会操作副本\n\nvolatile变量操作时需要同步给内存变量　所以一定会使线程的执行速度变慢\n\n而锁机制通过读入副本　释放锁写入主内存来包装可见性\n\n- 保证线程可见性\n  - MESI 缓存一致性协议\n- 禁止指令重排序\n  - DCL(double check lock) 单例\n\n重排序的3种类型：\n\n1. 编译器重排\n2. 指令并行重排\n3. 内存系统重排\n\n### 可见性\n\n在没有同步的情况下，编译器或者处理器都会对一些上下文无关的指令进行**重排序**，这可能会导致一个线程修改了某一个数值，而另一个线程无法马上读取到修改后的数值\n\n- 失效数据\n- 非原子的64位操作\n\n  > 在java当中，一个64位大小的数值可以被分为2个32位的操作\n\n在Java内存结构中，既然堆是共享的，为什么在堆中会有内存不可见问题。现在计算机CPU为了高效，往往会在高速缓存区中缓存共享变量\n\n为什么要重排序？还是为了性能，流水线技术的原理是指令1还没有执行完，就可以开始执行指令2，而不用等到指令1执行结束之后再执行指令2\n\n### 加锁与可见性\n\n![](https://wiki.jikexueyuan.com/project/java-concurrency/images/synchronous.jpg)\n\n之所以要在访问某个共享的可变变量时要求所有线程在锁上同步，就是为了确保读写可见性。 加锁的含义不局限与互斥行为，还包括内存可见性\n\nvolatile是比synchronized更为轻量级的同步机制，它无法进行互斥操作，但能保证内存可见性\n\n- 典型用法\n\n```java\nvoatile boolean f;\n\nwhile (f){\n    // do something\n}\n```\n\n## CAS\n\n- AtomicInteger 等原子类的实现\n\n![批注 2020-05-12 135356](/assets/批注%202020-05-12%20135356.png)\n\n它包含三个参数CAS(V,E,N): V表示要更新的变量，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程进行自旋重复上述操作或者什么都不做。最后，CAS返回当前V的真实值\n\nCAS是CPU原语支持 Java 通过native方法调用汇编指令来实现\n\n### ABA问题\n\n如果在这段期间曾经被改成B，然后又改回A，那CAS操作就会误认为它从来没有被修改过\n\n解决方法：版本号\n\n在大多数情况下 ABA问题并不会影响到程序的正确性\n\n使用**AtomicStampedReference**实现\n\n### 自旋开销\n\nCAS多与自旋结合。如果自旋CAS长时间不成功，会占用大量的CPU资源。\n\n让JVM支持处理器的pause指令可以解决这个问题。\n\n在Java层，也可以通过手动yield线程或者sleep来解决\n\n## unsafe类\n\n直接操作JVM里的内存\n\n**JDK9之后无法使用了**\n\n- allocateMemory 直接分配内存\n- freeMemory  释放内存\n- compareAndSet CAS操作\n\n## Java 与协程\n\n- Java 内核线程的局限性\n\n内核线程1:1映射到Java上，当面对大量请求时，线程切换的成本开销远远大于计算本身的开销\n\n协程的主要优势是轻量，一个协程的实现特例被称之为纤程\n\n新并发模型下，一段使用纤程并发的代码会被分为两部分——执行过程（Continuation）和调度器（Scheduler）。执行过程主要用于维护执行现场，保护、恢复上下文状态，而调度器则负责编排所有要执行的代码的顺序\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}