{"content":"# 并发集合\n\n## 基本不用\n\nVector, HashTable 都是JDK1.0时期提供的集合类，这两个类所有方法都加了synchronized，所以性能都很差，在新版本的JDK中都将逐渐被废弃移除\n\n## ConcurrentHashMap\n\n效率主要体现在读上面\n\n### 操作\n\n- put\n\n```java\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    if (key == null || value == null) throw new NullPointerException();\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh; K fk; V fv;\n        // table为空，初始化\n        if (tab == null || (n = tab.length) == 0)\n            tab = initTable();\n        // 当前索引位置为空，直接存放到这里\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n            if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value)))\n                break;                   // no lock when adding to empty bin\n        }\n        // 当前节点是在扩容，等待扩容完成\n        else if ((fh = f.hash) == MOVED)\n            tab = helpTransfer(tab, f);\n        else if (onlyIfAbsent // check first node without acquiring lock\n                 && fh == hash\n                 && ((fk = f.key) == key || (fk != null && key.equals(fk)))\n                 && (fv = f.val) != null)\n            return fv;\n        else {\n            V oldVal = null;\n            // 锁住当前节点\n            synchronized (f) {\n                // 其他的跟HashMap差不多\n                if (tabAt(tab, i) == f) {\n                    // 链表添加\n                    if (fh >= 0) {\n                        binCount = 1;\n                        for (Node<K,V> e = f;; ++binCount) {\n                            K ek;\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            Node<K,V> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new Node<K,V>(hash, key, value);\n                                break;\n                            }\n                        }\n                    }\n                    // 红黑树添加\n                    else if (f instanceof TreeBin) {\n                        Node<K,V> p;\n                        binCount = 2;\n                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                       value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                    else if (f instanceof ReservationNode)\n                        throw new IllegalStateException(\"Recursive update\");\n                }\n            }\n            // 新增成功\n            if (binCount != 0) {\n                // 是否需要转为红黑树\n                if (binCount >= TREEIFY_THRESHOLD)\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    addCount(1L, binCount);\n    return null;\n}\n```\n\n数组初始化，如何保证只有一个线程初始化并且能初始化成功？\n\n```java\nprivate final Node<K,V>[] initTable() {\n    Node<K,V>[] tab; int sc;\n    // 自旋\n    while ((tab = table) == null || tab.length == 0) {\n        // 代表当前有线程在初始化，让线程调度器重新调度线程\n        if ((sc = sizeCtl) < 0)\n            Thread.yield(); // lost initialization race; just spin\n        // 保证只有一个线程能初始化\n        else if (U.compareAndSetInt(this, SIZECTL, sc, -1)) {\n            try {\n                // 双重检查\n                if ((tab = table) == null || tab.length == 0) {\n                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;\n                    @SuppressWarnings(\"unchecked\")\n                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                    table = tab = nt;\n                    sc = n - (n >>> 2);\n                }\n            } finally {\n                sizeCtl = sc;\n            }\n            break;\n        }\n    }\n    return tab;\n}\n```\n\n新增槽点，通过自旋死循环保证一定可以新增成功。\n\n如果当前槽点为空，通过CAS新增\n\n槽点如果有值，会锁住当前槽点\n\n红黑树旋转时，锁住红黑树的根节点，保证同一时刻，当前红黑树只能被一个线程旋转\n\n- 扩容\n\n- 首先需要把老数组的值全部拷贝到扩容之后的新数组上，先从数组的队尾开始拷贝；\n- 拷贝数组的槽点时，先把原数组槽点锁住，保证原数组槽点不能操作，成功拷贝到新数组时，把原数组槽点赋值为转移节点；\n- 这时如果有新数据正好需要 put 到此槽点时，发现槽点为转移节点，就会一直等待，所以在扩容完成之前，该槽点对应的数据是不会发生变化的；\n- 从数组的尾部拷贝到头部，每拷贝成功一次，就把原数组中的节点设置成转移节点；\n- 直到所有数组数据都拷贝到新数组时，直接把新数组整个赋值给数组容器，拷贝完成\n\n- get\n\nget跟HashMap很像\n\n\n## ConcurrentLinkedQueue\n\nCAS实现\n\n## ConcurrentSkipListMap\n\nTreeMap使用的红黑树\n\n树的CAS操作很难实现\n\nTreeMap的并发版本\n\n## CopyOnWriteArrayList\n\n通过锁 + 数组拷贝 + volatile 关键字保证了线程安全，每次数组操作，都会把数组拷贝一份出来，在新数组上进行操作，操作成功之后再赋值回去\n\n### 架构\n\n在对数组进行操作的时候，基本会分四步走：\n\n- 加锁；\n- 从原数组中拷贝出新数组；\n- 在新数组上进行操作，并把新数组赋值给数组容器；\n- 解锁。\n\n### 操作\n\n- 新增\n\n```java\npublic boolean add(E e) {\n    synchronized (lock) {\n        // 获取真实数组\n        Object[] es = getArray();\n        int len = es.length;\n        // 根据真实数组复制出一个数组\n        es = Arrays.copyOf(es, len + 1);\n        // 在新数组上做操作\n        es[len] = e;\n        // 把新数组作为真实数组\n        setArray(es);\n        return true;\n    }\n}\n```\n\n都已经加锁了，为什么需要拷贝数组？\n\n- volatile 关键字修饰的是数组，如果我们简单的在原来数组上修改其中某几个元素的值，是无法触发可见性的，我们必须通过修改数组的内存地址才行\n- 第二个原因是get并没有加锁，通过复制一个新数组进行操作，可以防止get访问到一些数据的中间组合\n\n- 在指定位置新增\n\n```java\npublic void add(int index, E element) {\n    synchronized (lock) {\n        Object[] es = getArray();\n        int len = es.length;\n        if (index > len || index < 0)\n            throw new IndexOutOfBoundsException(outOfBounds(index, len));\n        Object[] newElements;\n        // numMoved指定是后半部分数组的长度\n        int numMoved = len - index;\n        // 如果删除的是最后一个，直接创建一个比原来数组小1的数组复制数据\n        if (numMoved == 0)\n            newElements = Arrays.copyOf(es, len + 1);\n        else {\n            // 这里会根据计算，通过两次复制分别将原数组的前半部分以及后半部分复制到新数组里\n            newElements = new Object[len + 1];\n            System.arraycopy(es, 0, newElements, 0, index);\n            System.arraycopy(es, index, newElements, index + 1,\n                             numMoved);\n        }\n        newElements[index] = element;\n        setArray(newElements);\n    }\n}\n```\n\n- 删除\n\n```java\npublic E remove(int index) {\n    synchronized (lock) {\n        Object[] es = getArray();\n        int len = es.length;\n        E oldValue = elementAt(es, index);\n        int numMoved = len - index - 1;\n        Object[] newElements;\n        if (numMoved == 0)\n            newElements = Arrays.copyOf(es, len - 1);\n        else {\n            // 复制前半部分数组同上\n            newElements = new Object[len - 1];\n            System.arraycopy(es, 0, newElements, 0, index);\n            // 复制后半部分数组需要位置向左偏移1个单位\n            System.arraycopy(es, index + 1, newElements, index,\n                             numMoved);\n        }\n        setArray(newElements);\n        return oldValue;\n    }\n}\n```\n\n- indexOf\n\n```java\nprivate static int indexOfRange(Object o, Object[] es, int from, int to) {\n    if (o == null) {\n        // 返回第一个为null的下标\n        for (int i = from; i < to; i++)\n            if (es[i] == null)\n                return i;\n    } else {\n        // 返回equals的对象\n        for (int i = from; i < to; i++)\n            if (o.equals(es[i]))\n                return i;\n    }\n    return -1;\n}\n```\n\n- 迭代\n\n由于CopyOnWriteArrayList的迭代器需要持有一个数组引用，所以即使在迭代的过程中对CopyOnWriteArrayList进行修改也不会抛异常\n\n![202002211513](/assets/202002211513.jfif)\n\n## 阻塞队列\n\n### 设计思想\n\n![202002231406](/assets/202002231406.jfif)\n\n- 数据结构\n- 入队出队方式\n- 通信机制\n  - 强关联：take与put要互相等待\n  - 无关联：只要队列容器不满，生产者就能放成功，生产者就可以直接返回，和有无消费者一点关系都没有，生产者和消费者完全解耦\n\n- BlockingQueue\n    - 该类型的队列执行take时如果没有元素则会一直阻塞，put如果超过了界限也会一直阻塞，直至有可用空间\n    - 实现类:ArrayBlockingQueue与LinkedBlockingDeque等\n\n### ArrayBlockingQueue\n\n这个队列一个重要的特点是有界的阻塞数组，容量一旦创建，后续大小无法修改\n\n#### 操作\n\n- 初始化\n\n```java\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n    if (capacity <= 0)\n        throw new IllegalArgumentException();\n    this.items = new Object[capacity];\n    //第二个参数是否公平，主要用于读写锁是否公平，如果是公平锁，那么在锁竞争时，就会按照先来先到的顺序，如果是非公平锁，锁竞争时随机的\n    lock = new ReentrantLock(fair);\n    // 在put成功之后通知其他等待take的线程\n    notEmpty = lock.newCondition();\n    // 在take成功之后通知其他等待put的线程\n    notFull =  lock.newCondition();\n}\n```\n\n- put\n\n```java\npublic void put(E e) throws InterruptedException {\n    Objects.requireNonNull(e);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        // 当队列满时，进行等待\n        while (count == items.length)\n            notFull.await();\n        // 被唤醒，入队\n        enqueue(e);\n    } finally {\n        lock.unlock();\n    }\n}\nprivate void enqueue(E e) {\n    final Object[] items = this.items;\n    // 从这里可以看出，putIndex就是当入队的时候，元素放置的位置\n    items[putIndex] = e;\n    // 当下次的putInex超过数组大小时，则下次放置的位置就是0，也就说队头\n    if (++putIndex == items.length) putIndex = 0;\n    count++;\n    // 唤醒等待take的线程\n    notEmpty.signal();\n}\n```\n\n- take\n\n```java\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        // 队列为空，进行等待\n        while (count == 0)\n            notEmpty.await();\n        // 被唤醒，出队\n        return dequeue();\n    } finally {\n        lock.unlock();\n    }\n}\nprivate E dequeue() {\n    final Object[] items = this.items;\n    @SuppressWarnings(\"unchecked\")\n    // // 从这里可以看出，takeIndex就是当出队的时候，元素的位置\n    E e = (E) items[takeIndex];\n    items[takeIndex] = null;\n    // 同样，当下一次takeIndex超过数组容量时，就从头开始\n    if (++takeIndex == items.length) takeIndex = 0;\n    count--;\n    if (itrs != null)\n        itrs.elementDequeued();\n    // 唤醒等待put的线程\n    notFull.signal();\n    return e;\n}\n```\n\n- remove\n\n```java\nvoid removeAt(final int removeIndex) {\n    final Object[] items = this.items;\n    // 删除的位置等于下一次take的位置\n    if (removeIndex == takeIndex) {\n        // removing front item; just advance\n        items[takeIndex] = null;\n        // takeIndex往后移动一位\n        if (++takeIndex == items.length) takeIndex = 0;\n        count--;\n        if (itrs != null)\n            itrs.elementDequeued();\n    } else {\n        // 删除的位置非takeIndex\n        // 从删除的位置开始遍历\n        for (int i = removeIndex, putIndex = this.putIndex;;) {\n            int pred = i;\n            if (++i == items.length) i = 0;\n            // 如果遍历到putIndex的位置，删除这个位置的元素\n            if (i == putIndex) {\n                items[pred] = null;\n                this.putIndex = pred;\n                break;\n            }\n            // 将removeIndex后的元素全部往前移动一位\n            items[pred] = items[i];\n        }\n        count--;\n        if (itrs != null)\n            itrs.removedAt(removeIndex);\n    }\n    // 通知等待put的线程\n    notFull.signal();\n}\n```\n\n#### 使用场景\n\n一般用于生产数据固定的场景\n\n### LinkedBlockingQueue \n\n#### 类结构层次\n\n![202002220959](/assets/202002220959.jfif)\n\n#### 架构\n\n- 使用链表来维护先进先出队列\n- 分成三个部分：链表存储 + 锁 + 迭代器\n\n#### 操作\n\n- 初始化\n\n```java\n// 直接根据大小初始化\npublic LinkedBlockingQueue(int capacity) {\n    if (capacity <= 0) throw new IllegalArgumentException();\n    this.capacity = capacity;\n    // 将链表头尾节点置为同一空节点\n    last = head = new Node<E>(null);\n}\n// 根据给定集合初始化\npublic LinkedBlockingQueue(Collection<? extends E> c) {\n    // 初始化近乎无限的队列\n    this(Integer.MAX_VALUE);\n    // put锁\n    final ReentrantLock putLock = this.putLock;\n    putLock.lock(); // Never contended, but necessary for visibility\n    try {\n        int n = 0;\n        // 通过循环以此对集合内的元素入列\n        for (E e : c) {\n            if (e == null)\n                throw new NullPointerException();\n            if (n == capacity)\n                throw new IllegalStateException(\"Queue full\");\n            enqueue(new Node<E>(e));\n            ++n;\n        }\n        // 维护队列状态信息\n        count.set(n);\n    } finally {\n        putLock.unlock();\n    }\n}\n```\n\n- 阻塞新增\n\n```java\npublic void put(E e) throws InterruptedException {\n    if (e == null) throw new NullPointerException();\n    final int c;\n    final Node<E> node = new Node<E>(e);\n    final ReentrantLock putLock = this.putLock;\n    final AtomicInteger count = this.count;\n    // 可中断锁\n    putLock.lockInterruptibly();\n    try {\n        // 当前队列满，等待\n        while (count.get() == capacity) {\n            notFull.await();\n        }\n        // 等待结束（此时是队列从满变为没满，被唤醒），入队\n        enqueue(node);\n        // 获得上一刻队列大小\n        c = count.getAndIncrement();\n        // 如果当前队列大小仍然小于最大容量，唤醒一个put的等待线程\n        if (c + 1 < capacity)\n            notFull.signal();\n    } finally {\n        putLock.unlock();\n    }\n    // 此时，队列实际大小为1，唤醒一个等待put的线程\n    if (c == 0)\n        signalNotEmpty();\n}\n```\n\n- 阻塞删除\n\n```java\npublic E take() throws InterruptedException {\n    final E x;\n    final int c;\n    final AtomicInteger count = this.count;\n    final ReentrantLock takeLock = this.takeLock;\n    takeLock.lockInterruptibly();\n    try {\n        // 当队列为空时，进行等待\n        while (count.get() == 0) {\n            notEmpty.await();\n        }\n        // 被唤醒，代表队列有数据了，出队\n        x = dequeue();\n        // 上一刻的队列大小\n        c = count.getAndDecrement();\n        // 代表队列还有数据，再唤醒一个等待take的线程\n        if (c > 1)\n            notEmpty.signal();\n    } finally {\n        takeLock.unlock();\n    }\n    // 队列还剩一个空位，唤醒一个等待put的线程\n    if (c == capacity)\n        signalNotFull();\n    return x;\n}\n```\n\n\n#### 使用场景\n\n适合对生产的数据大小不定（时高时低），数据量较大的场景\n\n### DelayQueue \n\nDelayQueue 中的元素必须是 Delayed 的子类，Delayed 是表达延迟能力的关键接口，其继承了 Comparable 接口，并定义了还剩多久过期的方法\n\n```java\npublic interface Delayed extends Comparable<Delayed> {\n    long getDelay(TimeUnit unit);\n}\n```\n\n#### 操作\n\n- put\n\n```java\npublic boolean offer(E e) {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        // 利用优先队列进行排序\n        q.offer(e);\n        // 如果刚放进去的元素在队头\n        if (q.peek() == e) {\n            leader = null;\n            // 则会唤醒在等待可用元素的线程\n            available.signal();\n        }\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n```\n\n- take\n\n```java\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n        // 自旋\n        for (;;) {\n            // 获取队头数据\n            E first = q.peek();\n            // 队头没数据，进行等待\n            if (first == null)\n                available.await();\n            else {\n                // 获取队头数据的过期时间\n                long delay = first.getDelay(NANOSECONDS);\n                // 以及过期了\n                if (delay <= 0L)\n                    // 直接返回\n                    return q.poll();\n                first = null; // don't retain ref while waiting\n                // leader不为null，代表当前元素以及被设置阻塞时间了\n                if (leader != null)\n                    available.await();\n                else {\n                    Thread thisThread = Thread.currentThread();\n                    leader = thisThread;\n                    // 对当前线程阻塞队头元素的阻塞时间\n                    try {\n                        available.awaitNanos(delay);\n                    } finally {\n                        if (leader == thisThread)\n                            leader = null;\n                    }\n                }\n            }\n        }\n    } finally {\n        if (leader == null && q.peek() != null)\n            available.signal();\n        lock.unlock();\n    }\n}\n```\n\n#### 使用场景\n\n用于任务不想立马执行，想等待一段时间才执行的场景\n\n## PriorityQueue\n\n取出的顺序是会根据添加的元素进行排序\n\n### SynchronousQueue \n\n其本身是没有容量大小，比如我放一个数据到队列中，我是不能够立马返回的，我必须等待别人把我放进去的数据消费掉了，才能够返回\n\n#### 架构\n\n```java\n// 堆栈和队列共同的接口\n// 负责执行 put or take\nabstract static class Transferer<E> {\n    // e 为空的，会直接返回特殊值，不为空会传递给消费者\n    // timed 为 true，说明会有超时时间\n    abstract E transfer(E e, boolean timed, long nanos);\n}\n// 堆栈 后入先出 非公平\n// Scherer-Scott 算法\nstatic final class TransferStack<E> extends Transferer<E> {}\n    \n// 队列 先入先出 公平\nstatic final class TransferQueue<E> extends Transferer<E> {}\n```\n\n- transfer\n\n该方法比较复杂，总而言之，如果传进来的e是null，并且当前有一个put线程阻塞，则会返回这个put的e，并且put线程解除阻塞。否则就一直阻塞到有数据为止\n\n反之，如果传进来的e不是null，并且有一个take线程阻塞，则将e通过节点传给take线程\n\n### TransferQueue\n\n拥有普通阻塞队列的put-poll功能与SynchronousQueue的阻塞数据交换功能\n\n- transfer\n\n### 问题\n\n#### 对队列的理解\n\n首先队列本身也是个容器，底层也会有不同的数据结构，列把生产数据的一方和消费数据的一方进行解耦，生产者只管生产，消费者只管消费，队列还可以对消费者和生产者进行管理，当队列满时或者空时，会阻塞住生产者或者消费者\n\n#### 队列和集合的区别\n\n队列（部分例外）和集合都提供了数据存储的功能，底层的储存数据结构是有些相似的\n\n但两者为了完成不同的事情，提供的 API 和其底层的操作实现是不同的， 队列提供了阻塞的功能，解耦了生产者和消费者\n\n####  哪些队列具有阻塞的功能，大概是如何阻塞的\n\nLinkedBlockingQueue 链表阻塞队列和 ArrayBlockingQueue 数组阻塞队列是一类，两个阻塞队列都可以指定容量大小，当队列满时，如果有线程 put 数据，线程会阻塞住，直到有其他线程进行消费数据后，才会唤醒阻塞线程继续 put，当队列空时，如果有线程 take 数据，线程会阻塞到队列不空时，继续 take\n\nSynchronousQueue 同步队列，当线程 put 时，必须有对应线程把数据消费掉，put 线程才能返回，当线程 take 时，需要有对应线程进行 put 数据时，take 才能返回\n\n#### 底层是如何实现阻塞的\n\n利用 Condition 的等待唤醒机制\n\n#### 经常使用队列的 put、take 方法有什么危害，如何避免\n\n两个方法都是无限（永远、没有超时时间的意思）阻塞的方法\n\n使用 offer 和 poll 方法来代替两者，可以设置超时阻塞时间\n\n### 队列在JDK中的其他运用\n\n- 线程池\n\n![202002231353](/assets/202002231353.jfif)\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n```\n\n> 参考JAVA编程规范中的不要用Executors创建线程池，而要手动创建\n\n### 锁\n\n同步队列\n\n![202002231404](/assets/202002231404.jfif)\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}