{"content":"# Java 谜题\n\n## 表达式\n\n- 奇数性\n\n```java\nx % 2 == 1 // 用来判断x是否为奇数\n```\n\n当 x 为负数时, 该表达式永不成立\n\n当取余操作返回一个非零结果时 与左操作数拥有相同的正负符号\n\n```java\n-1 % 2 == -1\n```\n\n- 找零时刻\n\n浮点数问题\n\n```java\n2.00 - 1.10 != 0.9 // true\n2.00 - 1.10 == 0.8999999999999999 // true\n```\n\n- 长整除\n\n```java\nlong a = 24*60*60*1000*1000\nlong b = 24*60*60*1000\na / b == 5 // true\n```\n\n原因在于a的表达式计算时溢出了 它以int的方式计算最后才存入a\n\n```java\na = 24L*60*60*1000*1000\na / b == 1000 // true\n```\n\n- 初级问题\n\n```java\n12345 + 5432l == 17777 // true\n```\n\n主要小写l 与数字1的区别\n\n- 多重转型\n\n```java\n(int)(char)(byte)-1 == 65535 // true\n```\n\n1.从int的-1转为byte的-1\n2.从byte的-1转为char 发生了符号扩展（char是无符号的 -1会被转为65535）\n3.从char转为int\n\n**如果通过观察不能确定成行将要做什么 那么它做的很有可能就不是你想要的**\n\n- 互换内容\n\n```java\nx ^= y^= x^= y // 什么垃圾代码?\n```\n\n在单个表达式中不要对相同的变量赋值两次\n\n- Dos\n\n```java\nint i = 0\ntrue ? 'X' : 0 // 'X'\ntrue ? 'X' : i // 88\n```\n\n三元表达式的如果第二个操作数与第三个操作数类型相同 则这个类型就是表达式的类型\n\n否则如果类型不同 较小的类型会被提升为范围较大的那个类型\n\n**条件表达式的操作数类型应该相同**\n\n- 半斤\n\n```java\nshort x = 0\nint i =123456\nx = x+i // 编译错误\nx+=i // 会自动转型-7616\n```\n\n不要将复合赋值操作用于int类型以下的\n\n用在int类型上 确保右侧类型不比int类型大\n\n## 字符串\n\n- 最后的笑声\n\n```java\nSystem.out.println('H' + 'A'); // 137\n```\n\n加号运算符在两个操作数都不是字符串的情况下, 执行的将会是加法 而非字符串连接, 两个char变量被提升为int了\n\n- 转义字符的溃败\n\n```java\nSystem.out.println(\"a\\u0022.length()) // 正常运行\n```\n\n\\u0022 等同于 \"\n\n选择转义字符 而非转义unicode\n\n- 可恶的unicode\n\n```java\n/**\n * F:\\user\\data 下存放了xxx\n * @author MY\n * @date 2020/9/15 10:38\n */\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"hello\");\n    }\n}\n```\n\n这段代码无法通过编译 原因在第一行路径的\\u 编译器会认为其是一个unicode编码 找不到\\uxxx这个编码 编译就会出错\n\n- 字符串奶酪\n\n```java\nbyte[] bytes = new byte[256];\nfor(int i=0;i<256;i++)bytes[i]= (byte) i;\nString str = new String(bytes);\nfor(int i=0;i<str.length();i++) System.out.print(str.charAt(i) + \" \");\n```\n\n这段代码所产生出的字符串是在不停的平台上是不确定的, 主要是编码的问题\n\n**即在使用比特数组生成字符串时要显式指定编码**\n\n- 斜杠的受害者\n\n```java\n\"note.ismy.wang\".replaceAll(\".\",\"/\") // 输出结果：//////////////\n```\n\n问题在于replaceAll 传递的第一个参数是一个正则表达式\n\n- 正则表达式的受害者\n\n```java\nString.class.getName().replaceAll(\"\\\\.\",File.separator)\n```\n\n上面的代码会抛出异常：IllegalArgumentException：character to be escaped is missing\n\n原因在于replaceAll第二个参数会对字符串进行转义, 如果输入\\ 就代表字符串未结束\n\n解决方法是使用replace方法：\n\n```java\nString.class.getName().replace(\".\",File.separator)\n```\n\n- URL的愚弄\n\n```java\nhttps://javascript\nSystem.out.println(\"hello world\");\n```\n\n上面这段代码编译 运行没问题 原因在与https:被识别为一个标签\n\n后面的// 则被识别为注释\n\n**某些东西看起来过于奇怪 以至于不想对的 那么极有可能是错的**\n\n- 不劳而获\n\n```java\nRandom rnd = new Random();\nStringBuffer word = null;\nswitch(rnd.nextInt(2)){\n    case 1:word = new StringBuffer('P');\n    case 2: word = new StringBuffer('G');\n    default:word = new StringBuffer('M');\n        word.append('a');\n        word.append('i');\n        word.append('n');\n        System.out.println(word);\n}\nSystem.out.println(word);\n```\n\n最终只会打印出ain\n\n三个bug:\n\n1. nextInt最终的取值范围是0-1\n2. 创建StringBuffer传入char时会变成int 导致变成创建char大小的缓冲区\n3. case不加break\n\n## 循环\n\n- 尽情享受循环\n\n```java\nfor(byte b = Byte.MIN_VALUE;b<Byte.MAX_VALUE;b++)\n    if (b  == 0x90) System.out.println(\"hello\");\n```\n\n这段代码什么也不会打印 主要是因为0x90 是十六机制 代表的是十进制的144 这已经超出了byte的表示范围（-128 - 127）\n\n- 无情的++\n\n```java\nint j = 0;\nfor (int i = 0; i < 100; i++) j = j++;\nSystem.out.println(j);\n```\n\nj的最终结果为0, j = j++等同于：\n\n```java\nint t = j;\nj = j + 1;\nj = t;\n```\n\n- 在循环中\n\n```java\nint count = 0;\nfor (int i = 0; i <= Integer.MAX_VALUE; i++) count++;\n```\n\n循环结束时 count等于多少？\n\n答案是这个循环永远不会停止, 循环继续条件永远为真, 因为i溢出了\n\n- 变幻莫测的值\n\n```java\nint i=0;\nwhile(0xffffffff << i != 0 ) i++;\nSystem.out.println(i);\n```\n\n这个循环也会无限循环, **移位操作符只会用其右操作数的低五位做移位操作,对于long变量 是低六位** 所以不论i多大, 这里i能做移位操作的最大只能达到32\n\n**如果可能的话 移位长度应该是常量**\n\n- 循环者\n\n```java\ndouble i = Double.POSITIVE_INFINITY;\nwhile(i == i + 1); // 无限循环\n```\n\n无穷大+1还是无穷大\n\n一个浮点数值越大, 它和其后继数值间隔越大 浮点数使用了固定的有效位来表示, 所以一个很大的数+1不会改变它的值\n\n- 循环者的新娘\n\n```java\ndouble i = Double.NaN;\nwhile (i != i); // 无限循环\n```\n\nNah != Nah\n\n- 循环者的爱子\n\n```java\nString i = \"cccc\";\nwhile (i != i + 0); // 无限循环\n```\n\n- 循环者的鬼魂\n\n```java\nshort i = -1;\nwhile (i != 0){\n    i >>>=1;\n} // 无限循环\n```\n\nshort会被提升为int 0xffffffff\n\n右移之后 变成int的0x7fffffff 后又变成short 被砍掉高4为 变成 0xffff 回到了-1 死循环\n\n- 循环者的诅咒\n\n```java\nInteger i = 129;\nInteger j = 129;\nwhile (i<=j && j<=i && j!=i); // 死循环\n```\n\n**当两个数都是包装类型时 比较操作符执行的是值比较 判等操作符执行的是引用比较**\n\n- 循环者遇到了狼人\n\n```java\nInteger i = Integer.MIN_VALUE;\nwhile (i != 0 && i == -i); // 死循环\n```\n\n还是整数溢出搞的鬼\n\n- 被计数击倒了\n\n```java\nint count = 0;\nfor(float f = Integer.MAX_VALUE; f< Integer.MAX_VALUE+50;f++) count++;\nSystem.out.println(count); // 0\n```\n\nf的值太大了 以至于+50 还是等于f\n\n**不要使用浮点数作为循环索引**\n\n- 分分钟\n\n```java\nint count = 0;\nfor (int i=0;i<60*1000*1000;i++){\n    if (i % 60*1000 == 0) count ++;\n}\nSystem.out.println(count); // 1000000\n```\n\n运算符优先级问题：取模与乘法优先级相同\n\n## 异常\n\n- 优柔寡断\n\n```java\nboolean f(){\n    try {\n        return true;\n    }finally {\n        return false;\n    }\n}\n```\n\n这段代码返回false **finally语句总是在离开try后执行**\n\n**finally不要使用 return break continue throw**\n\n- 极端不可思议\n\n```java\ntry {\n    System.out.println(\"hw\");\n} catch (IOException e){} // 1.编译错误\ntry { }catch (Exception e){} // 2. 正常编译\n\n// 3.正常编译\ninterface i1{\n    void f() throws ClassNotFoundException,InterruptedException;\n}\ninterface i2 {\n    void f() throws IOException,InterruptedException;\n}\ninterface i3 extends i1,i2{ }\nnew i3(){\n    @Override\n    public void f() throws InterruptedException {}\n};\n```\n\n1. 对于受检异常, 如果catch到的异常没有在try代码块声明, 则无法编译\n2. 但是JLS规定Exception与Throwable除外, 这些异常可以没有在try中声明\n3. **一个方法可以抛出的异常是其所有父类/父接口声明的异常类型的交集**\n\n- 不受欢迎的i\n\n```java\nprivate static final int i;\n\nstatic {\n    try {\n        f();\n    }catch (Exception e){\n        i=-1;\n    }\n    \n}\n\nstatic void f() throws Exception{\n    throw new Exception(\"eee\");\n}\n```\n\n这段代码会因为编译器无法确定i是否只被赋值一次而编译失败\n\n- 不辞而别\n\n```java\ntry {\n    System.out.println(\"hello\");\n    System.exit(-1);\n}finally {\n    System.out.println(\"world\");\n}\n```\n\nSystem.exit会立即停止所有的程序线程 try代码块压根就不会完成 也就不会执行finally了\n\n- 不情愿的对象\n\n```java\nclass Object{\n    private Object obj = new Object();\n\n    public Object() {}\n}\n```\n\n这个对象new的时候会抛出栈溢出异常\n\n- 繁琐的流关闭\n\n```java\nFileInputStream in1 = null;\nFileInputStream in2 = null;\ntry {\n    in1 = new FileInputStream(\"xxx\");\n    in2 = new FileInputStream(\"xxx\");\n}finally {\n    if (in1 != null) in1.close();\n    if (in2 != null) in1.close();\n}\n```\n\n这个程序的问题在于in1 close抛出异常就会导致in2不会关闭\n\n解决方法使用JDK7 的自动关闭特性\n\n- 循环中抛出异常\n\n使用异常来控制循环 不仅代码难以阅读 并且速度十分慢\n\n- 可怕的递归\n\n```java\npublic static void main(String[] args){\n    work();\n    System.out.println(\"done\");\n}\nstatic void work(){\n    try {\n        work();\n    }finally {\n        work();\n    }\n}\n```\n\n这个程序会的调用会从根节点生成一颗完全二叉树 树的深度为虚拟机的栈深度 这个递归虽然不是无限的 但对人类的生命而言也近乎无穷了\n\n## 类\n\n- 迷惑的重载\n\n```java\npublic static void main(String[] args){\n    new Main().confusing(null);\n}\npublic void confusing(Object obj){\n    System.out.println(\"obj\");\n}\npublic void confusing(double[] doubles){\n    System.out.println(\"doubles\");\n}\n```\n\n最终会打印出doubles 方法的选择是从窄到宽的\n\n- 狸猫换狗子\n\n```java\nclass Animal{\n    private static int count;\n    public void incr(){count++;}\n}\nclass Dog extends Animal{\n    public Dog() { incr();}\n}\nclass Cat extends Animal{\n    public Cat() { incr();}\n}\n```\n\n这段程序dog与cat的count会相互影响\n\n- 会飞的复读鸭\n\n```java\nclass Duck{\n    public static void fly(){ System.out.println(\"i fly!\"); }\n}\nclass RepeatDuck extends Duck{\n    public static void fly(){}\n}\n\nDuck duck = new RepeatDuck();\nduck.fly(); // print i fly!\n```\n\n静态方法的调用不存在多态\n\n**或许静态方法之所以叫静态就是因为不存在动态的分派机制**\n\n- 错误的时间\n\n```java\npublic class Main {\n    private static final Main instance= new Main();\n    private static final long i = System.currentTimeMillis();\n    private final long initTime;\n    public Main() {\n        initTime = i;\n        System.out.println(initTime);\n    }\n}\n```\n\n这个类会循环初始化 导致initTime第一次是为0\n\n**当心这种情况**\n\n- 不是你的类型\n\n```java\nString s = null;\ns instanceof Object; // false 左操作符为null就会返回false\n\nnew Date() instanceof String; // 编译错误 如果两个操作数都是类 其中一个必须是另外一个的子类型\n\n(String)new Object(); // 抛出运行时异常\n```\n\n- 发育不良\n\n```java\nclass Father{\n    private final String name;\n\n    public Father() { name = makeName(); }\n\n    protected String makeName(){ return \"i am your father\"; }\n\n    @Override\n    public String toString() { return name; }\n}\n\nclass Son extends Father{\n    String pname;\n    public Son(String name) {\n        this.pname = name;\n    }\n\n    @Override\n    protected String makeName() {\n        return \"i am \" + pname;\n    }\n\n}\n```\n\n创建一个Son对象 最终会打印出 i am null ,关键在于子类还没初始化完全 name就已经完成初始化\n\n- null\n\n```java\nclass Null{\n    public static void print(){ System.out.println(\"hello world\"); }\n}\n\n((Null)null).print(); // 可以打印\n```\n\n静态方法的调用只与类型相关 这或许是Java的设计缺陷 静态方法压根就不能通过对象实例调用\n\n- 创建对象\n\n```java\nfor (int i = 0; i < 100; i++) Object object = new Object();\n```\n\n这段代码无法通过编译 一个本地变量声明作为一条语句只能出现在语句块中\n\n## 库\n\n- 大问题\n\n```java\nBigInteger one = new BigInteger(\"1\");\nBigInteger two = new BigInteger(\"2\");\none.add(two);\nSystem.out.println(one); // print 1\n```\n\nBigInteger的实例是不可变的 算术操作只会返回新实例而非直接修改对象\n\n- 分不清人\n\n```java\nclass Person {\n    public final String name;\n\n    public Person(String name) { this.name = name; }\n\n    @Override\n    public boolean equals(Object o){\n        if (o instanceof Person p) return  p.name.equals(this.name);\n        return false;\n    }\n}\n\nSet<Person> personSet = new HashSet<>();\npersonSet.add(new Person(\"cxk\"));\nSystem.out.println(personSet.contains(new Person(\"cxk\"))); // false\n```\n\n任何时候 只要重写了equals方法 就必须重写hashCode方法 equals相等的对象hashCode必须相等 但hashCode相等不代表equals相等\n\n- 六亲不认\n\n```java\nclass Person {\n    public final String name;\n\n    public Person(String name) { this.name = name; }\n\n    public int hashCode(){ return name.hashCode();}\n\n    public boolean equals(Person p){\n        return  p.name.equals(this.name);\n    }\n}\n```\n\n这个类声明虽然声明了hashCode 但是还是和上面一例一样 返回false\n\n原因在与我们重载了equals方法 而非重写\n\n**重载为错误和混乱提供了机会**\n\n为避免犯这种错误 加上@Override\n\n- 混乱的代价\n\n```java\n766 - 066 == 712 // true\n```\n\n以0开头的整型字面常量会被解释为八进制 不要这么做！！！\n\n- 一行代码解决\n\n```java\n// 去除list中的重复元素并保持顺序\nreturn new ArrayList<>(new LinkedHashSet<>(originList));\n\n// 以,后面跟随者0-n个空格分割文本\nstr.split(\",\\\\S*\");\n\n// 以字符串形式展示数组\nArrays.toString(...);\n\n// 判断一个整数的二进制表示有多少1\nInteger.bitCount(xxx);\n```\n\n了解类库可以节省大量时间与精力\n\n- 可怕的日期API\n\n```java\nCalendar cal = Calendar.getInstance();\ncal.set(2019,12,31);\nSystem.out.println(cal.get(Calendar.YEAR));//2020\n```\n\nCalendar 或 Date 使用时一定要注意文档\n\n- 名字游戏\n\n```java\nMap<String,String> map1 = new IdentityHashMap<>();\nmap1.put(new String(\"111\"),\"kk\");\nmap1.put(new String(\"111\"),\"dd\");\nSystem.out.println(map1.size()); // 2\n\nMap<String,String> map2 = new IdentityHashMap<>();\nmap2.put(\"111\",\"kk\");\nmap2.put(\"111\",\"dd\");\nSystem.out.println(map2.size()); // 1\n```\n\nIdentityHashMap 是基于引用判断两个key是否相等的\n\nJava 语言规范规定了字符串常量会进行复用 会有相同的引用\n\n- 不生效的绝对值\n\n```java\nMath.abs(Integer.MIN_VALUE) < 0 // true\n```\n\n     * <p>Note that if the argument is equal to the value of\n     * {@link Integer#MIN_VALUE}, the most negative representable\n     * {@code int} value, the result is that same value, which is\n     * negative.\n\n- 奇葩的排序\n\n```java\nInteger[] a = new Integer[100];\nRandom rnd = new Random();\n for (int i = 0; i < 100; i++) {\n     a[i] = rnd.nextInt();\n }\n Arrays.sort(a, new Comparator<Integer>(){\n     @Override\n     public int compare(Integer o1, Integer o2) {\n         return o1-o2;\n     }\n });\n System.out.println(Arrays.toString(a));\n```\n\n打印出来的数组基本是无序的(有序的可能性非常小) 原因在于使用的这个比较器 这个比较器通过减法来实现\n\n在数值比较小的情况下没有 但一旦数组元素极大或极小则会发生溢出 导致结果不正确\n\n## 类(升级版)\n\n- 私人领域\n\n```java\nclass Base { public String name = \"cxk\";}\nclass D extends Base {private String name = \"jntm\";}\n\nSystem.out.println(new D().name); // 无法编译\n```\n\n对于成员变量 通过这种子类权限比父类更小的方式来隐藏\n\n但对于成员方法 这种写法是非法的\n\n违反了LSP\n\n**隐藏会带来混乱** \n\n- 李鬼替代了李逵\n\n```java\npublic class Main {\n    public static void main(String[] args) { }\n}\n\nclass String{}\n```\n\n这个程序将无法启动 报错：在类 Main 中找不到 main 方法\n\n原因就是因为这个自定义的 String \n\n**避免重用平台类的名字 并且不要复用java.lang中的类名**\n\n- 阴影中的类\n\n```java\nclass X{\n    static class Y { String Z = \"Z1\";}\n    static C Y = new C();\n}\nclass C {String Z = \"Z2\";}\n\nSystem.out.println(X.Y.Z); // print Z2\n```\n\n**当一个变量和一个类型具有相同名字 变量名的优先级更高**\n\n- 无法覆写的方法\n\n```java\npackage p1;\npublic class Click {\n    public void click(){print();}\n    void print(){ System.out.println(\"print\"); }\n}\n\npackage p2;\npublic class Main {\n    public static void main(String[] args) {\n        new Click(){\n            void click() { System.out.println(\"click\"); } // 无法覆写\n        }.click();\n    }\n}\n```\n\n**一个包内私有的方法不能被位于另一个包的某个方法直接覆写**\n\n- 方法遮蔽\n\n```java\nimport static java.util.Arrays.toString;\npublic class Main {\n    static void print(){System.out.println(toString(new int[]{1,2,3}));} // 编译错误 找不到这样的toString方法\n}\n```\n\n编译失败的原因在于本身就属于某个范围的成员的优先级比静态导入的优先级更高\n\n**静态导致使用应该十分克制**\n\n### 名字重用\n\n- 覆写\n\n```java\nclass Base {public void f(){}}\nclass D {public void f(){}} // 覆写Base.f\n```\n\n- 隐藏\n\n```java\nclass Base {public static void f(){}}\nclass D {public static void f(){}} // 隐藏Base.f\n```\n\n- 重写\n\n```java\nclass Base {\n    public void f(){}\n    public void f(int i){} // 重载f\n}\n```\n\n- 遮蔽\n\n```java\nclass Base {\n    static String name = \"cxk\";\n    static void f(){\n        String name = \"jntm\"; // 变量遮蔽\n    }\n}\n\n// 经常使用的遮蔽:\nclass Main {\n    private String name;\n    public Main(String name){\n        this.name = name;\n    }\n}\n```\n\n- 遮掩\n\n```java\nclass Main {\n    static String System; // 遮掩 java.lang.System\n}\n```\n\n## 库(升级版)\n\n- 乒乓\n\n```java\npublic static synchronized void main(String[] args) {\n    new Thread(()->{\n        pong();\n    }).start();\n    System.out.println(\"ping\");\n}\nstatic synchronized void pong(){\n    System.out.println(\"pong\");\n}\n```\n\n这段程序ping pong总会按照顺序打印出来 重点就在于main与pong都是同步方法 不会并发执行\n\n- 反射的污染\n\n```java\nIterator<Object> iterator = new HashSet<>().iterator();\nMethod method = iteraor.getClass().getMethod(\"hasNext\");\nSystem.out.println(method.invoke(iterator)); // IllegalAccessException\n```\n\n原因在于这个迭代器的实际实现类是某个内部类 Java语言规范规定**访问位于其他包中的非公共类型的成员是不合法的**\n\n这个问题在使用了反射之后 就更加难以发现\n\n- 吃饭睡觉打豆豆\n\n```java\nclass Cat {\n    void eat(){\n        System.out.println(\"eat\");\n    }\n    void sleep(){\n        System.out.println(\"sleep\");\n    }\n    void live(){\n        new Thread(){\n            @Override\n            public void run() {\n                while (true){\n                    eat();\n                    sleep(); // 编译错误\n                }\n            }\n        }.start();\n    }\n}\n```\n\n这个类无法通过编译 原因在于Cat的sleep被Thread.sleep 遮蔽了\n\n**事实证明 使用Runnable创建线程比继承Thread要更方便**\n\n- 丢失的构造器\n\n```java\nclass Outer {\n    public class Inner{}\n}\n\nOuter.Inner.class.newInstance(); // NoSuchMethodException: Outer$Inner.<init>()\n```\n\n如果一个类为非静态内部类 那么它的默认构造函数就会变成变成一个携带着隐藏参数的构造器 这个参数就是外围的对象实例\n\n**同时 newInstance这个方法现在也已经被废弃了 不推荐使用**\n\n应该优先使用静态成员类\n\n- hello 不 world\n\n```java\nString str = \"hello world\";\nfor (int i = 0; i < str.length(); i++) {\n     System.out.write(str.charAt(i)); // 什么也不会输出\n}\n```\n\n这里在write的时候 char被转为int了 write(int) 这个方法只有在遇到\\n的byte表示时才会自动flush\n\n- 线程中断\n\n```java\nThread.currentThread().interrupt();\nSystem.out.println(Thread.interrupted()); // true\nSystem.out.println(Thread.interrupted()); // false\n```\n\nThread.interrupted 会清除中断状态\n\n- 复杂的初始化\n\n```java\npublic class Main {\n    private static boolean init = false;\n    static {\n        var t = new Thread(){\n            @Override\n            public void run() {\n                init = true;\n            }\n        };\n        t.start();\n        try {\n            t.join();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n    }\n    public static synchronized void main(String[] args) {\n        System.out.println(init);\n    }\n}\n```\n\n这段代码会造成死锁\n\n主线程使用的时候 会对类进行初始化\n\n初始化时 启动了新线程 新线程也会检查类的初始化 接着就卡死在了这里\n\n**要让类的初始化尽可能简单**\n\n## 高级\n\n- 有害的括号\n\n```java\nint i = -(2147483648); // 错误：整数太大\n```\n\n2147483648 只能作为一元操作符的右操作数使用\n\n- 奇怪的关系\n\n```java\nlong x = Long.MAX_VALUE;\ndouble y = (double) Long.MAX_VALUE;\nlong z = Long.MAX_VALUE - 1;\n\nx == y; // true\ny == z; // true\nx == z; // false\n```\n\n== 运算符会进行二进制数据类型提升 也就说如果两个类型不相同 则较低的那个类型会被转换到较高的类型\n\n- 原生类型的锅\n\n```java\nclass List<T>{\n    java.util.List<T> iterator(){\n        return new ArrayList<T>();\n    }\n}\n\nList list = new List<String>();\nfor(String s: list.iterator()){ // 编译错误：不兼容的类型\n    System.out.println(s);\n}\n```\n\n原生类型：支持泛型但是没有使用泛型\n\n原因在于原生类型的泛型丢失了 这个时候iterator返回的是`ArrayList<Object>()`\n\n**避免编写原生类型**\n\n- 泛型遮蔽\n\n内部类中也可以访问到外部类中的泛型参数 避免这个问题\n\n- 序列化杀手\n\nHashSet 或者 HashMap 在反序列化的时候会调用对象自身的方法\n\n所以使用这些集合的时候 注意不要让这些集合的元素内部又指向这些集合 否则就会发生一些非预期结果\n\n- 剪不断理还乱\n\n```java\npublic class Main {\n    private String name = \"\";\n\n    public Main(String name) { this.name = name; }\n\n    private String name(){return name;}\n    private void run(){\n        new Main(\"cxk\"){\n            void print(){\n                System.out.println(name());\n            }\n        }.print();\n    }\n\n    public static void main(String[] args) {\n        new Main(\"main\").run();\n    }\n}\n```\n\n这个程序乍一看会由于调用了Main不存在的print方法无法通过编译 但其实发现他可以访问print方法\n\n重点在于最终打印的出来是main 而非cxk 原因在于私有成员变量是无法被继承的 所以这里调用name方法打印的是main方法里Main传递的main\n\n- 类常量的编译处理\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        System.out.println(Server.one);\n        System.out.println(Server.two);\n        System.out.println(Server.three);\n    }\n}\n\npublic class Server {\n    public static final String one = \"1\";\n    public static final String two = \"2\";\n    public static final String three = \"3\";\n}\n```\n\n这里如果Server被重新编译 会打印出什么？\n\n答案还是和原来一样 Java 语言规范规定常量在编译时都会直接被转化为常量值 而不会被间接引用 这个时候就算把Server.class 删掉 Client也能正常运行\n\n- 假随机\n\n打乱数组时用Random是不正确的  使用Collection.shuffle\n\n## 餐后甜点\n\n```java\nint count = 0;\nfor(int =0;i<10;i++);{\n    count++;\n}\nSystem.out.println(count);// print 1 for后面的分号所导致的\n```\n\n```java\nInteger[]array = {3，1，4，1，5，9 };\nArrays.sort(array, new Comparator<Integer>({\n    public int compare(Integer i1，Integer i2）{\n    return i1<i2 ?-1: (i2 >i1 ?1:O);\n});\nSystem.out.println(Arrays.tostring(array));\n```\n\n```java\ntrue?false:true == true?false:true\n```\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}