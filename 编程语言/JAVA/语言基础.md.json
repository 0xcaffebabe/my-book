{"content":"# 语言基础\n\n## JAVA运行环境\n\n![](https://pic2.zhimg.com/80/0cc3f4a15d3184391a98a7b1c58f6e5f_hd.jpg)\n\n- JVM\n\nJava 虚拟机（JVM）是运行 Java 字节码的虚拟机。\n\n- JDK\n\nJDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具，能够创建和编译程序。\n\n- JRE\n\nJRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。\n\n**oracle jdk与openjdk**\n\nOracle JDK由Oracle公司开发，Oracle JDK采用了商业实现\nOpenJDK是Java SE平台版的开源和免费实现，虽然OpenJDK的部分功能有所缺失，但整体相差不大\n\n## 关键字\n\n- 完全小写的字母\n- 被高亮的单词\n\n### 标识符\n\n- 类的名称\n- 变量名称\n- 方法名称\n\n## 常量与变量\n\n### 常量\n\n>在程序运行期间，固定不变的量\n\n### 数据类型\n\n- 基本数据类型\n  - 整数型\n    - byte short int long 这些类型的包装类型的valueOf都作了缓存\n  - 浮点型\n    - float double\n  - 字符型\n    - char\n  - 布尔型\n    - boolean\n- 引用数据类型\n\n![屏幕截图 2020-09-16 152341](/assets/屏幕截图%202020-09-16%20152341.png)\n\n#### 浮点数的表示\n\n![屏幕截图 2020-09-13 103503](/assets/屏幕截图%202020-09-13%20103503.png)\n\n指数 = $X + 2^{x的二进制位数-1}$\n\n有效数字 = 使用原码存储\n\n由于某些数字不能由有限二进制位精确表示 所以会出现1f-0.9f != 0.1 这种情况\n\n### 变量\n\n> 程序运行期间，内容可以发生改变的量\n\n## 数据类型转换\n\n- 隐式转换\n\n> 数据范围从小到大\n\n- 显式转换\n\n```java\n范围小的类型 范围小的变量名 = (范围小的类) 原本范围大的数据;\n```\n\n*数据溢出*\n\n当被转换的数值范围大于目标类型时，就会发生数据溢出，导致一部分数据丢失\n\n- byte short char 在运算时都会被提升为int类型\n\n### ASCII 码表\n\n使用数字表示某些字符\n\n![202083111314](/assets/202083111314.png)\n\n## 运算符\n\n> 进行特定操作的符号\n\n### 算术运算符\n\n`+ - * / %`\n\n加号的三种用法：\n\n- 数值加法\n- 字符计算\n- 字符串连接\n\n  - 优先级问题\n\n    ```java\n    String s = \"123\" + 20 + 30;\n    ```\n\n### 自增自减运算符\n\n- 单独使用\n- 混合使用\n\n### 赋值运算符\n\n- 基本\n- 复合\n\n### 比较运算符\n\n`> < >= <= == !=`\n\n### 逻辑运算符\n\n`&& || !`\n\n- 短路\n\n当 a && b 中的a为false时 就不会去计算b表达式\n\n### 位运算符\n\n```java\n// 以下所有操作都代表的是在2进制操作下\nSystem.out.println(2 << 2); // 左移 8\nSystem.out.println(2 >> 1); // 右移 2\nSystem.out.println(0xffffffff >>> 3); // 无符号右移（忽略掉符号位，对符号位也会移动）\nSystem.out.println(8 | 0); // 位或 8\nSystem.out.println(8 & 0); // 位与 0\nSystem.out.println(8 ^ 0); // 异或 8\nSystem.out.println(~8); // 位非 -9\n```\n\n## 方法\n\n方法签名包括方法名称与参数列表 是方法的唯一标识\n\n### 方法调用\n\n- 直接调用\n- 赋值调用\n- 递归调用\n\n### 参数的传递\n\n在JAVA中 参数都是通过值来进行传递的\n\n- 形参：方法定义阶段\n- 实参：方法调用阶段\n\n要避免使用Object作为可变参数\n\n入参保护：对于入参数据量进行判断控制 处理不了 直接返回错误\n\n参数校验：对于外部的输入 都需要校验 基于防御式编程理念 但是对于一些底层的方法就不必校验 越靠近外部 越需要校验\n\n### 修饰符\n\n- 访问权限修饰符\n  - private\n  - public\n  - protected\n- static 静态方法\n  - 属于类本身\n- final 无法被子类重写\n- default 接口默认方法\n- abstract 抽象方法\n- synchronized 同步\n\n### 方法重载\n\n指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符和返 回值类型无关\n\n重载可以在编译时确定调用的方法 也被称为静态绑定\n\n```java\nvoid test(){\n  f(1);\n}\n\n// 重载方法的选择：\nvoid f(int i){} // 1. 精确匹配\nvoid f(long i){} // 2. 基本类型会自动转换成更大的数据类型\nvoid f(Integer i){} // 3. 自动装箱拆箱\nvoid f(Object i){} // 4. 向上转型进行匹配\nvoid f(Integer... i){} // 5. 最终通过可变参数匹配\n```\n\n### 方法重写\n\n对于子类 其可以改变父类的方法实现\n\n1. 父类无法调用在父类没有定义的方法\n2. 父类可以调用到子类重写的父类的方法\n\n子类重写的条件：\n\n- 只能针对非静态 非final 非构造方法\n- 访问权限不能变小\n- 重写方法的返回值类型要 `T super 父类的返回值类型`\n- 受检异常的类型同上\n- 方法签名需要与父类一致\n\n### 构造方法\n\n- 不能继承 不能覆写 不能直接调用\n- 方法名称必须与类名相同\n- 没有返回类型\n- 默认提供了一个无参构造\n- 可以为private\n\n### 类内方法\n\n外部使用静态成员时 尽量使用 类名.静态成员 来调用\n\n静态方法：\n\n- 不能使用实例成员\n- 不能使用super与this关键字\n\n### getter 与 setter\n\n为什么使用：\n\n- 满足面向对象的封装特性\n- 利于统一控制\n  - 权限...\n\n几种情况警惕：\n\n- 在方法中添加了业务逻辑会增加排查问题的难度\n- 同时定义getxxx与isxxx会迷惑程序员\n- 方法参数名称与成员变量名称相同 这点在IDE的使用下不是什么问题\n\n### 特殊方法\n#### finalize方法\n#### main方法\n\n### 同步异步\n\n异步处理的任务是非时间敏感的 异步调用需要通过诸如轮询的方式获取执行结果 轮询会增加机器的压力\n\n## 流程控制\n\n### 顺序结构\n\n### 分支结构\n\n- if\n- if-else\n- if-else if-else\n- switch\n\n### 循环结构\n\n- for循环\n\n```java\nfor(初始化表达式①; 布尔表达式②; 步进表达式④){\n     循环体③\n}\n```\n\n- while循环\n\n```java\n初始化表达式①   \nwhile(布尔表达式②){\n         循环体③     \n     步进表达式④ \n}\n```\n\n- do...while循环\n\n```java\n初始化表达式①     \ndo{     \n    循环体③     \n    步进表达式④ \n}while(布尔表达式②)\n```\n\n- for 和 while 的小区别： \n  - 控制条件语句所控制的那个变量，在for循环结束后，就不能再被访问到了，而while循环结束还可以继 续使用，如果你想继续使用，就用while，否则推荐使用for。原因是for循环结束，该变量就从内存中消 失，能够提高内存的使用效率。 在已知循环次数的时候使用推荐使用for，循环次数未知的时推荐使用while\n\n#### 跳出语句\n\n- continue\n- break\n  - 用在循环中\n  - 用在switch中\n\n#### 死循环\n\n#### 嵌套循环\n\n## 数组\n\n>数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。 \n\n### 定义\n\n```java\nint arr = new int[3];\nint arr = new int[]{1,2,3};\n```\n\n### 访问\n\n```java\n\nint a = arr[2];\nint l = arr.length;\n```\n\n## == 与 equals\n\n== 运算符比较的是两个对象的地址\nequals默认实现也是比较地址，如果重写了equals，可以根据相应的逻辑来判断两个对象是否相等\n\n## hashCode 与 equals\n\n- 如果两个对象相等，则 hashcode 一定也是相同的\n- 两个对象相等,对两个对象分别调用 equals 方法都返回 true\n- 两个对象有相同的 hashcode 值，它们也不一定是相等的\n- 因此，**equals 方法被覆盖过，则 hashCode 方法也必须被覆盖**\n- hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）\n\n## final关键字\n\n- 修饰类：类无法继承\n- 修饰变量：赋值之后无法修改\n- 修饰方法：无法被子类重写","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}