{"content":"# 编译原理\n\n## 词法解析\n\n```java\n// JavaParser\npublic JCTree.JCCompilationUnit parseCompilationUnit() {\n        Token firstToken = token;\n        JCModifiers mods = null;\n        boolean consumedToplevelDoc = false;\n        boolean seenImport = false;\n        boolean seenPackage = false;\n        ListBuffer<JCTree> defs = new ListBuffer<>();\n        if (token.kind == MONKEYS_AT)\n            mods = modifiersOpt(); // 解析修饰符\n\n        if (token.kind == PACKAGE) { // 解析包声明\n            int packagePos = token.pos;\n            List<JCAnnotation> annotations = List.nil();\n            seenPackage = true;\n            if (mods != null) {\n                checkNoMods(mods.flags);\n                annotations = mods.annotations;\n                mods = null;\n            }\n            nextToken();\n            JCExpression pid = qualident(false);\n            accept(SEMI);\n            JCPackageDecl pd = toP(F.at(packagePos).PackageDecl(annotations, pid));\n            attach(pd, firstToken.comment(CommentStyle.JAVADOC));\n            consumedToplevelDoc = true;\n            defs.append(pd);\n        }\n\n        boolean checkForImports = true;\n        boolean firstTypeDecl = true;\n        while (token.kind != EOF) {\n            if (token.pos <= endPosTable.errorEndPos) {\n                // error recovery\n                skip(checkForImports, false, false, false);\n                if (token.kind == EOF)\n                    break;\n            }\n            if (checkForImports && mods == null && token.kind == IMPORT) { // 解析import\n                seenImport = true;\n                defs.append(importDeclaration());\n            } else { // 解析类主体\n                Comment docComment = token.comment(CommentStyle.JAVADOC); // 类doc注释\n                if (firstTypeDecl && !seenImport && !seenPackage) {\n                    docComment = firstToken.comment(CommentStyle.JAVADOC);\n                    consumedToplevelDoc = true;\n                }\n                if (mods != null || token.kind != SEMI)\n                    mods = modifiersOpt(mods);\n                if (firstTypeDecl && token.kind == IDENTIFIER) {\n                    ModuleKind kind = ModuleKind.STRONG; // 模块解析\n                    if (token.name() == names.open) {\n                        kind = ModuleKind.OPEN;\n                        nextToken();\n                    }\n                    if (token.kind == IDENTIFIER && token.name() == names.module) {\n                        if (mods != null) {\n                            checkNoMods(mods.flags & ~Flags.DEPRECATED);\n                        }\n                        defs.append(moduleDecl(mods, kind, docComment));\n                        consumedToplevelDoc = true;\n                        break;\n                    } else if (kind != ModuleKind.STRONG) {\n                        reportSyntaxError(token.pos, Errors.ExpectedModule);\n                    }\n                }\n                JCTree def = typeDeclaration(mods, docComment);\n                if (def instanceof JCExpressionStatement)\n                    def = ((JCExpressionStatement)def).expr;\n                defs.append(def);\n                if (def instanceof JCClassDecl)\n                    checkForImports = false;\n                mods = null;\n                firstTypeDecl = false;\n            }\n        }\n        JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());\n        if (!consumedToplevelDoc)\n            attach(toplevel, firstToken.comment(CommentStyle.JAVADOC));\n        if (defs.isEmpty())\n            storeEnd(toplevel, S.prevToken().endPos);\n        if (keepDocComments)\n            toplevel.docComments = docComments;\n        if (keepLineMap)\n            toplevel.lineMap = S.getLineMap();\n        this.endPosTable.setParser(null); // remove reference to parser\n        toplevel.endPositions = this.endPosTable;\n        return toplevel;\n    }\n```\n\nJavaParser 根据 Java 语言规范来解析.java文件进行词法解析\n\n每调用一次nextToken 就会构造一个Token \n\n![屏幕截图 2020-10-04 095242](/assets/屏幕截图%202020-10-04%20095242.png)\n\n## 语法分析\n\n- 进行package词法分析的时候构建一个节点\n\n```java\nJCExpression t = toP(F.at(token.pos).Ident(ident()));\n```\n\n- 进行import词法分析时构造的import语法树\n\n```java\nprotected JCTree importDeclaration() {\n    int pos = token.pos;\n    nextToken();\n    boolean importStatic = false;\n    if (token.kind == STATIC) {\n        importStatic = true;\n        nextToken();\n    }\n    JCExpression pid = toP(F.at(token.pos).Ident(ident()));\n    do {\n        int pos1 = token.pos;\n        accept(DOT);\n        if (token.kind == STAR) {\n            pid = to(F.at(pos1).Select(pid, names.asterisk));\n            nextToken();\n            break;\n        } else {\n            pid = toP(F.at(pos1).Select(pid, ident()));\n        }\n    } while (token.kind == DOT);\n    accept(SEMI);\n    return toP(F.at(pos).Import(pid, importStatic));\n}\n```\n\n- 类主体语法树构造\n\n```java\nJCTree typeDeclaration(JCModifiers mods, Comment docComment) {\n    int pos = token.pos;\n    if (mods == null && token.kind == SEMI) {\n        nextToken();\n        return toP(F.at(pos).Skip());\n    } else {\n        return classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);\n    }\n}\n```\n\n最后会生成一颗完整的语法树\n\n## 语义分析\n\n打磨语法树\n\n- Enter类\n\n## 代码生成\n\n- Gen类\n\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}