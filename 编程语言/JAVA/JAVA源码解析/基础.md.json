{"content":"## 基础\n\n### String\n\n- String不可变的原因\n\nString内部是实现byte数组实现的\n\n```java\nprivate final byte[] value;\n```\n\n并且这个数组一旦赋上值，就无法再修改这个数组的引用了，同时String封装的很好，没有提供外部公开接口能直接操作这个数组，并且String类为final的，保证不会被继承，方法也不会被覆写，所以**String不可变**\n\n- equals原理\n\n```java\nif (this == obj){\n    return true;\n}\nif (obj instanceof String){\n    if (this.value.length == obj.value.length){\n        for(0...obj.length){\n            if (this.value[i] != obj.value[i]){\n                return false;\n            }\n        }\n    }\n}\nreturn false;\n```\n\n---\n\n问：如何解决 String 乱码\n\n1. 选择可以表示中文的字符集\n2. 在可以指定字符集的地方指定字符集\n\n### Long\n\n- Long与Integer一样，都对一定范围内的值做了缓存，所以有些Long对象，数值相同的情况下，直接用==比较会相等\n\n---\n\n问：为什么使用 Long 时，大家推荐多使用 valueOf 方法，少使用 parseLong 方法\n\n答：valueOf有做缓存\n\n### 常用关键字\n\n#### static\n\n- 修饰类变量\n  - 注意线程安全问题\n- 修饰方法\n  - 方法可以通过类直接调用\n- 修饰代码块\n  - 使用到静态变量的代码块可以在任何位置\n\n**初始化时机**\n\n1. 父类的静态变量和静态块比子类优先初始化；\n2. 静态变量和静态块比类构造器优先初始化。\n\n---\n\n问：如何证明 static 静态变量和类实例无关\n\n答：不需要创建该类的实例就可以使用静态变量与静态方法\n\n问：变量和方法被 static 和 final 两个关键字修饰，为什么这么做\n\n答：static可以直接使用这些方法与变量，final则是变量地址不可变，方法不可覆写，提升稳定性\n\n问：atch 中发生了未知异常，finally 还会执行么\n\n答：会，但是异常会被catch吞掉\n\n#### final\n\n1. 被 final 修饰的类，表明该类是无法继承的；\n2. 被 final 修饰的方法，表明该方法是无法覆写的；\n3. 被 final 修饰的变量，说明该变量在声明的时候，就必须初始化完成，而且以后也不能修改其内存地址\n\n第三点无法修改内存地址指的是无法修改引用，而不代表引用所指的对象内部无法修改\n\n#### try、catch、finally\n\n代码的执行顺序为：try -> catch -> finally\n\n#### volatile\n\n常用来修饰某个共享变量，意思是当共享变量的值被修改后，会及时通知到其它线程上，其它线程就能知道当前共享变量的值已经被修改了\n\n出现这种情况主要是因为JAVA的内存模型中的线程拥有一个工作区，线程对共享变量的读写都要先将变量从主存拉到工作区对其修改，修改后再将其写回到主存\n\n![202002181601](/assets/202002181601.jfif)\n\n#### transient\n\n常用来修饰类变量，意思是当前变量是无需进行序列化的\n\n#### default\n\n加在接口的方法上，修饰之后该方法就代表是一个默认实现，如果其他类继承该接口，就可以不用实现该方法，直接使用这个默认实现\n\n### jdk常用工具类\n\n#### Arrays\n\n- sort\n\n使用的双轴快速排序\n\n- binarySearch\n- copyOf、copyOfRange\n\n#### Collections\n\n- min、max\n\n这里可以学习一下最值方法返回值泛型的定义：\n\n```java\npublic static <T extends Object & Comparable<? super T>> T max\n```\n\n代表T必须继承自Object且实现了Comparable接口\n\n- 包装线程安全的集合\n\nsynchronized打头的方法可以将指定的集合包装成线程安全的集合\n\n具体原理是Collections内部有这些对应的线程安全集合，这些集合内部组合线程不安全的集合，通过synchronized加锁来操作内部的这些集合\n\n- 不可变集合\n\nunmodifiable 打头的方法则是会得到一些不可变集合，这些集合不能执行修改操作，否则会抛异常，也是通过对集合的包装来实现的\n\n#### Objects\n\n- equals\n\nObjects的equals内部的比较采用了deepEquals，这样即使两个对象是数组，也能放心比较\n\n- 一些判空方法\n\n![202002191416](/assets/202002191416.jfif)\n\n---\n\n问：如何写好一个工具类\n\n答： static final 关键字对方法进行修饰，工具类构造器必须是私有等等手段","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}