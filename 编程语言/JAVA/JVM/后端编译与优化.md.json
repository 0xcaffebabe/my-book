{"content":"# 后端编译与优化\n\n## 即时编译器\n\n### 解释器与编译器\n\n在整个Java虚拟机执行架构里，解释器与编译器经常是相辅相成地配合工作\n\n![屏幕截图 2020-11-09 092130](/assets/屏幕截图%202020-11-09%20092130.png)\n\nHotSpot在JDK10之前存在两个编译器：\n\n- C1:客户端编译器 通过 -client 参数指定使用这个编译器\n- C2:服务端编译器 通过 -server 参数指定使用这个编译器\n\n在JDK10之后 出现了一个Graal编译器 目的是用地取代C2\n\n无论采用的编译器是C1还是C2，解释器与编译器搭配使用的方式在虚拟机中被称为“混合模式”\n\n可以使用参数“-Xint”强制虚拟机运行于“解释模式\n\n使用参数“-Xcomp”强制虚拟机运行于“编译模式”\n\n分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，虚拟机会根据实际情况在不同层级之间转换\n\n### 编译对象与触发条件\n\n多次调用的方法以及多次执行的循环体被称为热点代码 这些热点代码会被进行编译\n\n这两种情况编译的目标都会是方法体 第二种情况的编译方式因为编译发生在方法执行的过程中，因此被很形象地称为“栈上替换”\n\nJVM 对于热点代码的判断称之为热点检测，目前有两种方法：\n\n1. 基于采样：采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”\n2. 基于计数器：采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”\n\nHotSpot 采用的是计数器方式 可以通过虚拟机参数-XX：CompileThreshold来人为设定这个计数器的阈值\n\n默认设置下 HotSpot的计数器并不是绝对技术 而是一段时间内的相对计数 当这段时间一过 该方法的调用计数器就会被减少一半 称之为半衰周期 可以使用虚拟机参数-XX：-UseCounterDecay来关闭热度衰减\n\n![屏幕截图 2020-11-09 093616](/assets/屏幕截图%202020-11-09%20093616.png)\n\n与方法计数器不同，回边计数器没有计数热度衰减的过程，因此这个计数器统计的就是该方法循\n环执行的绝对次数\n\n![屏幕截图 2020-11-09 094743](/assets/屏幕截图%202020-11-09%20094743.png)\n\n### 编译过程\n\n在第一个阶段，一个平台独立的前端将字节码构造成一种高级中间代码表示（High-Level\nIntermediate Representation，HIR，即与目标机器指令集无关的中间表示）\n\n在第二个阶段，一个平台相关的后端从HIR中产生低级中间代码表示（Low-Level Intermediate Representation，LIR，即与目标机器指令集相关的中间表示）\n\n最后的阶段是在平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在LIR上分配寄存器，并在LIR上做窥孔（Peephole）优化，然后产生机器代码\n\n## 提前编译器\n\nGCJ（GNU Compiler for Java）出现后提前编译基本没有什么太大进展，因为这与Java一次编译到处运行的理念相悖，直到Android 的ART的出现，也震撼到了 Java 世界\n\n### 提前编译的得与失\n\n1. 传统提前编译打破的就是即时编译占用了原本给程序运行时的资源\n2. 提前编译的第二条路就是在给即时编译做加速\n\n但即使编译又有以下优势：\n\n1. 性能分析制导优化（Profile-Guided Optimization，PGO），可以在运行阶段收集监控信息 从而更好地进行优化\n2. 激进预测性优化（Aggressive Speculative Optimization），即使编译激进优化可以做出一些假设 如果假设错了 大不了就回退到解释模式 但是提前编译不能做这些假设 它必须保证程序的外部影响优化前优化后都是一样的\n3. 链接时优化（Link-Time Optimization，LTO）\n\n## jaotc 提前编译\n\n```sh\njavac Main.class\njaotc --output Main.so Main.class # 将class编译为静态链接文件\njava -XX:+UnlockExperimentalVMOptions -XX:AOTLibrary=./Main.so Main # 运行它\n```\n\n## 编译器优化技术\n\n### 方法内联\n\n被戏称为优化之母 除了消除方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础\n\n在 Java 中，基本所有对象的方法都是虚方法，也就是这些方法直到运行时才能确定被调用的是哪一个，这位方法内联带来了困难\n\n为了解决虚方法的内联问题，Java虚拟机首先引入了一种名为类型继承关系分析（Class HierarchyAnalysis，CHA）的技术用于确定在目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法等\n\n如果CHA也判断方法有多个版本 那么会进入最后一次内联缓存优化尝试\n\n总而言之，多数情况下Java虚拟机进行的方法内联都是一种激进优化\n\n### 逃逸分析\n\n是为其他优化措施提供依据的分析技术\n\n分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部所引用 逃逸级别从低到高：\n\n- 不逃逸\n- 方法逃逸：通过方法返回值或者参数逃逸到其他方法\n- 线程逃逸：被其他线程访问到\n\n根据这些逃逸级别，可以采取不同的优化手段：\n\n- 栈上分配 如果对象不会方法逃逸 那对象可在栈内存分配 随着方法栈弹出，内存也被回收 大大减少GC的压力\n- 标量替换 如果对象不会方法逃逸，将对对象的访问转换为对int long的标量类型的访问 或者将对象创建打散为各种基本数据类型的创建\n- 同步消除 如果能确定不会线程逃逸 那就可以去掉同步机制 提高性能\n\n### 公共子表达式消除\n\n如果一个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式。对于这种表达式，没有必要花时间再对它重新进行计算，只需要直接用前面计算过的表达式结果代替E\n\n### 数组边界检查消除\n\n使用隐式异常来优化如数组边界检查以及NPE判断等每次操作的成本，用Java伪代码代表如下：\n\n```java\ntry {\n  return a[i]\n} catch(Exception e){\n  // 使用进程级别的Segment Fault信号的异常处理器处理这个异常\n}\n```\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}