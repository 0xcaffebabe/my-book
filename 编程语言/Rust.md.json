{"content":"# Rust\n\n- cargo 项目管理工具\n  - new\n  - build\n  - check\n\n第一个程序:\n\n```rust\nfn main(){\n  println!(\"hello world\");\n}\n```\n\n## 变量\n\n```rust\nconst MAX: u32 = 100; // 常量定义\nfn main() {\n    println!(\"MAX = {}\", MAX);\n    //变量定义\n    let a = 1;\n    let b: u32 = 1; // 显式指定类型\n    println!(\"a = {}\", a);\n    println!(\"b = {}\", b);\n\n    // b = 2; 编译报错：不能对不可变变量赋值两次\n    let mut c: u32 = 2; // 声明可变变量\n    c = 3;\n    println!(\"c = {}\", c);\n    \n    let a: f32 = 1.1; // 变量隐藏（变量遮蔽）\n    println!(\"a = {}\", a);\n}\n```\n\n## 数据类型\n\n```rust\nfn main() {\n    let success: bool = true; // 布尔类型\n    println!(\"success: {}\", success);\n    let name = '菜'; // char是32位的\n    println!(\"{}\", name);\n    // 数字类型：i8,i16,i32,i64 u8 u32 u64 f32 f64\n    let i: i8 = 127;\n    println!(\"{}\", i);\n    // 自适应类型：取决于平台 isize usize\n    println!(\"{} {}\", isize::max_value(), usize::max_value());\n    // 数组定义 数组长度也是数组类型的一部分（长度不同 类型不同？）\n    let arr: [u32; 5] = [1, 2, 3, 4, 5];\n    println!(\"{}\", arr[0]);\n    // print(arr); 编译错误：长度不匹配\n\n    // 元组\n    let person: (i32, char) = (18, '张');\n    println!(\"{} {}\", person.0, person.1);\n    let person = (18, '张');\n    println!(\"{} {}\", person.0, person.1);\n    let (age, name) = person; // 解构\n    println!(\"{} {}\", name, age);\n\n}\nfn print(arr:[u32;3]){}\n```\n\n## 函数\n\n```rust\nfn say_hello(name: char) -> i32{\n    println!(\"hello, {}\", name);\n    return 0;\n}\nfn add() -> i32{\n    //  语句执行一些操作 但没有返回值 例如let x= 1\n    // 表达式会返回一些值 如a+b 表达式就可以不加return直接返回\n    0 // 这样也可以返回\n}\nfn main() {\n    println!(\"{}\", say_hello('你'));\n    println!(\"{}\", add());\n}\n```\n\n## 控制流\n\n```rust\nfn main() {\n    let x = 0;\n    if x == 0 {\n        println!(\"0\");\n    }else if x == 1{\n        println!(\"1\");\n    }else {\n        println!(\"unknow\");\n    }\n    // 在let语句中使用if 两个分支的返回值需要为同一类型\n    let name = if x == 0 {\n        '陈'\n    }else {\n        '田'\n    };\n    println!(\"{}\", name);\n    let mut i = 0;\n    loop {\n        if i >= 10 {\n            break;\n        }\n        println!(\"{}\", i);\n        i = i + 1;\n    }\n    // loop 带返回值\n    let res = loop {\n        if i >= 30 {\n            break i * 2;\n        }\n        i = i+1;\n    };\n    println!(\"{}\", res);\n    // while循环\n    while i != 0 {\n        i -=1;\n    };\n    // for循环遍历数组\n    let arr:[u32; 5] = [1,2 ,3, 4, 5];\n    for i in arr.iter() {\n        println!(\"{}\", i);\n    }\n}\n```\n\n## 所有权\n\nRust 通过所有权机制管理内存 编译器会根据所有权规则对内存的使用进行检查\n\n- 堆栈\n\n编译时大小固定在栈 否则在堆上\n\n- String的内存回收\n\nString类型在离开作用域的时候回调用drop方法\n\n```rust\nlet s1 = String::from(\"hello\");\n    let s2 =s1; // -- value moved here 所有权转移 s1无效了\n    println!(\"{}\", s2);\n    // println!(\"{}\", s1); // 无法打印\n}\n```\n\n- deep clone\n\n```rust\n// 需要类型实现clone trait\nlet s3 = s2.clone();\nprintln!(\"{}\", s3);\n```\n\n- copy\n\n```rust\n// 需要类型实现copy trait\n// 基本类型+元组都实现了copy trait\nlet x = 1;\nlet y = x; // 栈上复制\nprintln!(\"{} {}\", x, y); // 正常使用y\n```\n\n## 引用\n\n![20201228204829](/assets/20201228204829.svg)\n\n```rust\n// 使用引用并不拥有这个值 离开这个作用域后也不会被丢弃\nfn length(s: &String) -> usize{\n    s.len()\n}\nfn modify_str(s: &mut String) {\n    s.push_str(\"kkk\");\n}\nfn main() {\n    let s = String::from(\"jntm\");\n    println!(\"{}\", length(&s));\n    println!(\"{}\", s); // 仍然能继续使用\n\n    let mut s1 = String::from(\"jntm\");\n    modify_str(&mut s1); // 引用不能直接修改值 使用借用（借用的变量必须为 mut）\n\n    let mut s = String::from(\"jntm\");\n    let r1 = &s;\n    let r2 = &mut s;\n    // 在任意时候 只能出现一个可变引用 运行多个不可变引用\n    //println!(\"{} {}\", r1 ,r2); // 不允许引用后出现借用\n\n}\n```\n\n## slice\n\n```rust\nfn main() {\n    let s = String::from(\"disa\");\n    println!(\"{}\", &s[0..2]);\n    println!(\"{}\", &s[0..=2]);\n    println!(\"{}\", &s[..=2]); // 默认从0开始\n    // println!(\"{}\", \"你好\"[..1]); // 索引要注意UTF8字节边界 切片是基于字节的\n    // 其他类型的slice\n    let a = [1, 2, 3, 4];\n    println!(\"{}\", &a[1..2][0]);\n}\n```\n\n## 结构体\n\n```rust\nfn main() {\n    // 定义\n    #[derive(Debug)] // 加了这个可以打印\n    struct User {\n        name: String,\n        age: u8,\n    }\n    // 创建\n    let mut cxk = User {name: String::from(\"cxk\"), age: 18};\n    println!(\"{:?}\", cxk); // 打印\n    // 修改\n    cxk.age = 24;\n    // 字段名与参数名同名简写\n    let name = String::from(\"bili\");\n    let age = 15;\n    let bili = User {name, age};\n    // 从其他结构体创建\n    let jame = User{name: String::from(\"jame\"), ..cxk};\n    // 匿名参数结构体\n    struct Point(i32, i32);\n    let p = Point(5, 5);\n    println!(\"{} {}\", p.0, p.1);\n    // 空结构体\n    struct Null{};\n}\n```\n\n### 方法\n\n```rust\nstruct Dog {\n    name: String\n}\nimpl Dog {\n    fn bark(&self) -> &Dog{\n        println!(\"{} wolf wolf\", self.name);\n        &self\n    }\n}\nfn main() {\n    let dog = Dog{name: String::from(\"boy\")};\n    dog.bark();\n}\n```\n\n## 枚举与匹配\n\n```rust\nenum MsgInfo {\n    ERROR, SUCCESS, UNKNOW\n}\nimpl MsgInfo {\n    // 匹配\n    fn print(&self) {\n        match *self {\n            MsgInfo::ERROR => println!(\"error\"),\n            MsgInfo::SUCCESS => println!(\"success\"),\n            _ => println!(\"unknow\")\n        }\n    }\n}\nfn main() {\n    struct Response {\n        status: MsgInfo,\n        msg: String\n    }\n    let response = Response {status: MsgInfo::SUCCESS, msg: String::from(\"成功\")};\n    // 官方推荐的定义方式\n    enum Ip {\n        V4(u8,u8,u8,u8),\n        V6(String)\n    }\n    let ip = Ip::V4(127,0,0,1);\n\n}\n```\n\n### Option\n\n标准库定义的枚举\n\n```rust\nfn main() {\n    let some_number: Option<i32> = Some(5);\n    let null_str: Option<String> = None;\n    // 打印some里面的值\n    match some_number {\n        Some(i) => println!(\"{}\", i),\n        _ => {},\n    }\n    match incr(some_number){\n        None => {},\n        Some(x) => println!(\"{}\", x)\n    }\n    // 使用if处理\n    if let Some(value) = incr(some_number) {\n        println!(\"{}\", value);\n    }\n}\nfn incr(x: Option<i32>) -> Option<i32> {\n    match x {\n        None => None,\n        Some(x) => Some(x + 1)\n    }\n}\n```\n\n## Vector\n\n```rust\nlet mut v: Vec<i32> = Vec::new();\nv.push(1);\nlet v = vec![1, 2, 3]; // 创建带有初始值的vector\nprintln!(\"{}\", &v[0]); // 引用访问\nmatch v.get(1) { // match访问\n    Some(value) => println!(\"{}\", value),\n    None => {}\n}\nlet mut v = Vec::new();\nv.push(1);v.push(2);v.push(3);\n// 不可变遍历\nfor i in &v {\n    println!(\"{}\", i);\n}\n// 可变遍历\nfor i in &mut v {\n    *i += 1; // 对每个值加1\n}\n```\n\n## 字符串\n\n```rust\nlet mut s = String::new(); // 空字符串\ns.push_str(\"hello \"); // 更新\nlet s = String::from(\"init\"); // 字面量\nlet mut s = \"123\".to_string();\nlet ss = \"123\".to_string();\ns.push_str(&ss);\nprintln!(\"{}\", ss); // 仍然可以使用\ns.push('m'); // push 只能添加字符\nlet s1 = String::from(\"hello\");\nlet s2 = String::from(\" world\");\nlet s3 = s1 + &s2; // 字符串合并 s1不能再使用\nlet str = format!(\"{} {}\", s2, s3); // 字符串格式化\nlet length = \"你好\".to_string().len(); // 编码为utf8 长度为6\nfor c in str.chars() { // 遍历\n    println!(\"{}\", c);\n}\nfor b in str.bytes() {\n    println!(\"{}\", b);\n}\n```\n\n## HashMap\n\n```rust\nuse std::collections::HashMap;\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(\"name\", \"cxk\");\n\n    // 使用两个vector创建hashmap\n    let keys = vec![\"name\",\"age\"];\n    let values = vec![\"cxk\",\"18\"];\n    let map:HashMap<_,_> = keys.iter().zip(values.iter()).collect();\n\n    let mut map:HashMap<String,String> = HashMap::new();\n    map.insert(String::from(\"name\"), String::from(\"cxk\"));\n    map.insert(String::from(\"age\"), String::from(\"18\"));\n    // 读取元素\n    match map.get(&String::from(\"name\")) {\n        Some(v) => println!(\"{}\", v),\n        None => {}\n    }\n    // 遍历元素\n    for (k,v) in &map {\n        println!(\"{} {}\",k,v);\n    }\n\n    // putIfAbsent\n    map.entry(String::from(\"name\")).or_insert(String::from(\"kd\"));\n}\n```\n\n## 模块\n\n- 创建模块\n\n```sh\ncargo new --lib mylib\n```\n\n- 在mylib/src创建factory.rs\n\n```rust\nmod factory {\n  pub mod socket_produder {\n      pub fn new_socket(){\n          println!(\"socket new\");\n      }\n  }\n\n  mod log_producer {\n      fn new_log(){\n          println!(\"log new\");\n      }\n  }\n}\n```\n\n-lib.rs导出\n\n```rust\npub mod factory;\n```\n\n- main.rs引用\n\n```toml\n[dependencies]\nmylib = {path = \"./mylib\"}\n```\n\n```rust\nuse mylib::factory::socket_produder;\n```\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}