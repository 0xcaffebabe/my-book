{"content":"# 面向对象\n\n## 对象\n\n- 属性\n- 方法\n\n### 创建对象\n\n```js\n// 字面量创建对象\nvar man = {\n    name: 'cxk',\n    play:function(){\n        console.log('jntm')\n    }\n}\n\n// 实例化对象\nvar man = new Man()\nman.play()\n```\n\n## 构造函数\n\n```js\n// 构造函数创建对象\nfunction Man(){\n    this.name = 'cxk';\n    this.play=function(){\n        console.log('jntm')\n    }\n}\n// 实例化对象\nvar man = new Man()\nman.play()\n```\n\n### 成员\n\n- 实例成员\n\n```js\n// 在函数内容通过this访问的是实例成员\nthis.name = 'cxk';\n```\n\n- 静态成员\n\n```js\n// 静态成员只能通过构造函数访问\nMan.people='70亿'\nconsole.log(Man.people)\n```\n\n### 构造函数的问题\n\n![2020227104859](/assets/2020227104859.png)\n\n## 构造函数原型prototype\n\n每一个构造函数都有一个prototype 属性，指向另一个对象。注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有\n我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法\n\n```js\nMan.prototype.people='70亿'\nvar man = new Man()\nconsole.log(man.people)\n```\n\n### 对象原型\n\n对象都会有一个属性 `__proto__` 指向构造函数的 prototype 原型对象，之所以我们对象可以使用构造函数 prototype 原型对象的属性和方法，就是因为对象有 `__proto__` 原型的存在\n\n```js\nman.__proto__ == Man.prototype // true\n```\n\n### constructor构造函数\n\n一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor  就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数\n\n```js\nMan.prototype = {\n    constructor:Man,\n    play:function(){\n        console.log('真香')\n    }\n}\n```\n\n### 原型链\n\n![202022711154](/assets/202022711154.png)\n\n当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性\n如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）\n如果还没有就查找原型对象的原型（Object的原型对象），依此类推一直找到 Object 为止（null）。\n\n### this指向\n\n构造函数中的this和原型对象的this,都指向我们new出来的实例对象\n\n## 继承\n\n### 构造函数继承\n\n```js\nfunction Animal(){\n    this.run = function(){\n        console.log('animal run')\n    }\n}\nfunction Dog(){\n    // 让父构造函数的this指向当前的this\n    Animal.call(this)\n    this.bark = function(){\n        console.log('wolf wolf')\n    }\n}\nvar dog = new Dog();\ndog.run()\ndog.bark()\n```\n\n### 原型继承\n\n```js\nfunction Animal() { }\nAnimal.prototype.run = function () {\n    console.log('animal run')\n}\nfunction Dog() { }\nDog.prototype = new Animal()\nDog.prototype.constructor = Dog;\nDog.prototype.bark = function () {\n    console.log('wolf wolf')\n}\nvar dog = new Dog()\ndog.run()\ndog.bark()\n```\n\n## 类\n\n在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象\n\n### 创建类\n\n```js\n// 创建一个Man类\nclass Man{\n    // 构造器\n    constructor(){\n        this.name = 'cxk'\n    }\n    // 实例方法\n    play(){\n        console.log('jntm')\n    }\n}\n// 实例化\nvar man = new Man()\nman.play()\n```\n\n### 类继承\n\n```js\nclass Animal {\n    constructor(){\n        console.log('animal create')\n    }\n    run(){\n        console.log('animal run')\n    }\n}\nclass Dog extends Animal {\n    // 创建子类前会调用父类的构造器\n    constructor(){\n        // 必须在第一行手动调用\n        super()\n        console.log('dog create')\n    }\n    // 覆写父类的方法\n    run(){\n        // 调用父类的run方法\n        super.run()\n        console.log('dog run')\n    }\n    // 定义新方法\n    bark(){\n        console.log('wolf wolf')\n    }\n}\nvar dog = new Dog()\ndog.run()\ndog.bark()\n```\n\n### 注意事项\n\n-  ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象\n-  注意this的指向问题,类里面的共有的属性和方法一定要加this使用","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}