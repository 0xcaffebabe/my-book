{"content":"# AJAX\n\n- 传统网站的弊端\n\n## 应用场景\n\n- 动态数据加载\n- 表单验证\n\n## 实现\n\n### 原生方式\n\n```js\nlet xhr = new XMLHttpRequest();\n// 发送get请求 通过url传递参数\nxhr.open('get',\"/home\");\nxhr.send();\nxhr.onload = function(){\n    console.log(xhr.responseText);\n}\n```\n\n- post\n\n```js\nxhr.open('post',\"/home\");\nxhr.setRequestHeader('Content-Type',\"application/json\");\nxhr.send('{\"name\":\"jntm\"}');\n```\n\n#### ajax状态码\n\n- 0：请求未初始化(还没有调用open())\n- 1：请求已经建立，但是还没有发送(还没有调用send())\n- 2：请求已经发送\n- 3：请求正在处理中，通常响应中已经有部分数据可以用了\n- 4：响应已经完成，可以获取并使用服务器的响应了\n\n```js\nxhr.onreadystatechange = function(){\n    console.log(xhr.readyState);\n}\n```\n\n区别描述          | onload事件 | onreadystatechange事件\n------------- | -------- | --------------------\n是否兼容IE低版本     | 不兼容      | 兼容\n是否需要判断Ajax状态码 | 不需要      | 需要\n被调用次数         | 一次       | 多次\n\n#### 错误处理\n\n- 后端能调通，但是返回错误\n\n```js\nxhr.status\n```\n\n- 网络中断，后端无法调通\n\n会触发xhr对象下面的onerror事件，在onerror事件处理函数中对错误进行处理\n\n- 低版本ie存在ajax缓存问题\n\n#### ajax封装\n\n```js\nfunction ajax(req) {\n    let xhr = new XMLHttpRequest();\n    let params = \"\";\n    for (let attr in req.data) {\n        params += attr + \"=\" + req.data[attr] + \"&\";\n    }\n    params = params.substr(0, params.length - 1);\n    xhr.open(req.type, req.type != 'get' ? req.url:req.url + \"?\" + params);\n\n    for(let attr in req.headers){\n        xhr.setRequestHeader(attr,req.headers[attr]);\n    }\n\n    if (req.type == 'get'){\n        xhr.send();\n    }else{\n        if (req.headers['Content-Type']=='application/json'){\n            xhr.send(JSON.stringify(req.data));\n        }else{\n            xhr.send(params);\n        }\n    }\n    xhr.onload = function () {\n        let contentType = xhr.getResponseHeader(\"Content-Type\");\n        let responseText = xhr.responseText;\n\n        if (contentType.includes(\"application/json\")){\n            responseText = JSON.parse(responseText);\n        }\n        if (xhr.status === 200) {\n            req.success && req.success(responseText);\n        } else {\n            req.error && req.error(responseText);\n        }\n    };\n}\n\najax({\n    url: '/home',\n    type: 'get',\n    data: {name: \"cxk\", age: 18},\n    headers:{\n        \"Content-Type\":\"application/json\"\n    },\n    success: function (res) {\n        console.log('normal res', res);\n    },\n    error: function (res) {\n        console.error('error res', res);\n    }\n})\n```\n\n### JQuery实现方式\n\n- ajax\n\n```js\n$.ajax({\n    url:\"./\" , // 请求路径\n    type:\"POST\" , //请求方式\n    //data: \"username=jack&age=23\",//请求参数\n    data:{\"username\":\"jack\",\"age\":23},\n    success:function (data) {\n        alert(data);\n    },//响应成功后的回调函数\n    error:function () {\n        alert(\"出错啦...\")\n    },//表示如果请求响应出现错误，会执行的回调函数\n});\n```\n\n发送jsonp请求\n\n```js\n$.ajax({\n    url: 'http://www.example.com',\n    // 指定当前发送jsonp请求\n    dataType: 'jsonp',\n    // 修改callback参数名称\n    jsonp: 'cb',\n    // 指定函数名称\n    jsonCallback: 'fnName',\n    success: function (response) {} \n})\n```\n\n- $.get\n- $.post\n- serialize\n\n```js\n$(\"#form\").serialize(); // 将表单输入的内容转换成如k=v&a=b这种形式\n```\n\n#### 全局事件\n\n```js\n.ajaxStart()     // 当请求开始发送时触发\n.ajaxComplete()  // 当请求完成时触发\n```\n\n配合nprogress来实现页面加载进度条\n\n## FormData\n\n- 表单上传\n- 二进制文件上传\n\n### 简单使用\n\n```html\n<form id=\"form\">\n    <input type=\"text\" name=\"username\"/>\n    <input type=\"password\" name=\"password\"/>\n    <input type=\"file\" name=\"file\">\n    <input type=\"button\" id=\"btn\"/>\n</form>\n```\n\n```js\nlet form = document.querySelector(\"#form\");\nlet formData = new FormData(form);\nlet xhr = new XMLHttpRequest();\nxhr.open('post','/formData');\nxhr.send(formData);\n```\n\n### 实例方法\n\n```js\n// 获取表单对象属性\nformData.get('username');\n// 设置表单对象属性\nformData.set(\"username\",\"cxk\");\n// 删除表单对象属性\nformData.delete(\"username\");\n// 追加表单对象属性,属性名已存在的情况下,set会覆盖,append会保留\nformData.append(\"username\",\"cxk\");\n```\n\n### 文件上传进度展示\n\n```js\nxhr.upload.onprogress = function (ev) {\n    console.log(ev.loaded / ev.total)\n}\n```\n\n### 图片上传实时预览\n\n```java\nvar file = document.querySelector('#file');\nfile.onchange = function(){\n    var reader = new FileReader();\n    reader.readAsDataURL(this.files[0]);\n    reader.onload = function(){\n        document.querySelector('.img-thumbnail').src = reader.result;\n    }\n}\n```\n\n### 使用Promise发送ajax\n\n```js\nfunction query() {\n    return new Promise((resolve, reject) => {\n        let xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState != 4) {\n                return;\n            }\n            if (xhr.readyState == 4 && xhr.status == 200) {\n                resolve(xhr.responseText);\n            } else {\n                reject(xhr.status);\n            }\n        };\n        xhr.open('get', '/home');\n        xhr.send();\n    });\n}\n\nquery().then(r => console.log(r)).catch(r => console.error(r))\n```\n\n## fetch\n\nFetch API是新的ajax解决方案\n\n**fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象**\n\n```js\nfetch('/home').then(data=>{\n    return data.text();\n})\n.then(data=>{\n    console.log(data);\n});\n```\n\ndata是一个response对象，其中包括返回的一堆原始字节，这些字节需要在收到后，需要我们通过调用方法将其转换为相应格式的数据，比如`JSON`，`BLOB`或者`TEXT`等等\n\n- 传递参数\n\n```js\nlet formData = new FormData();\nformData.append('username','cxk');\nformData.append('password','jntm');\nfetch('/formData',{\n    method:'post',\n    body:formData\n})\n```\n\n## axios\n\n```js\naxios.get('/home')\n    .then(res=>{\n        console.log(res);\n    })\n```\n```js\nlet formData = new FormData();\nformData.append('username','cxk');\nformData.append('password','jntm');\n// 默认传递的是json\naxios.post('/formData',formData)\n .then(res=>{\n     console.log(res);\n })\n```\n\n- 同步调用\n\n```js\nasync function f(){\n    let res =  await axios.post('/formData',formData);\n    console.log(res);\n}\n```\n\n### 全局参数\n\n```js\n// 配置公共的请求头 \naxios.defaults.baseURL = 'https://api.example.com';\n// 配置 超时时间\naxios.defaults.timeout = 2500;\n// 配置公共的请求头\naxios.defaults.headers.common['Authorization'] = AUTH_TOKEN;\n// 配置公共的 post 的 Content-Type\naxios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';\n```\n\n### 拦截器\n\n```js\n// 请求拦截器\naxios.interceptors.request.use(function(config) {\n    console.log(config.url)\n    // 这里一定要return   否则配置不成功\n    return config;\n}, function(err){\n    // 对请求错误做点什么\n    console.log(err)\n})\n// 响应拦截器\naxios.interceptors.response.use(function(res) {\n    console.log(res.data);\n    return res.data;\n}, function(err){\n    console.log(err)\n});\n```\n\n## 同源策略\n\najax受同源策略限制\n\n### JSONP\n\n原理：\n\n客户端定义一个函数：\n\n```js\nfunction fn (data) { // 接收到服务器data后的一些处理 }\n```\n\n服务端返回一个函数调用：\n\n```js\nconst data = 'fn({name: \"张三\", age: \"20\"})';\n```\n\n客户端使用script可以跨域加载数据\n\n```html\n<script src=\"server_ajax_address\"></script>\n```\n\n这样客户端就可以获取服务端的数据\n\n```js\nfunction fn(data){\n    console.log('server res',data);\n}\nlet script = document.createElement('script');\nscript.src = '/jsonp?v=1';\ndocument.body.appendChild(script);\n```\n\n```java\n@GetMapping(\"/jsonp\")\npublic String jsonp(){\n    return \"fn({name:'cxk',age:18})\";\n}\n```\n\n#### 优化\n\n- 回调函数名称参数化\n- 回调函数参数化\n  - 注意回调函数覆盖问题\n- url参数化 \n- 接收到回调后删除script标签\n\n### CORS\n\n全称为 Cross-origin resource sharing，即跨域资源共享，它允许浏览器向跨域服务器发送 Ajax 请求，克服了 Ajax 只能同源使用的限制\n\n通过设置`Access-Control-Allow-Origin`和`Access-Control-Allow-Methods`响应头来允许哪些源可以使用哪些方法访问\n\n```java\n@RestController\n@CrossOrigin(\"*\")\npublic class Controller {...}\n```\n\nwithCredentials：指定在涉及到跨域请求时，是否携带cookie信息，默认值为false\n\n### 使用后端服务器辅助访问","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}