{"content":"# BOM\n\nBOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window\n\n## 组成\n\n- window\n\n  - document\n  - location\n  - navigator\n  - screen\n  - history\n\n## window\n\n### 事件\n\n`window.onload` 是窗口 (页面）加载事件，**当文档内容完全加载完成**会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数\n\n`window.onresize` 是调整窗口大小加载事件, 当触发时就调用的处理函数.经常利用这个事件完成响应式布局。 `window.innerWidth` 当前屏幕的宽度\n\n### 定时器\n\n- setTimeout() 在指定的毫秒数后调用函数或计算表达式。\n- clearTimeout() 取消由 setTimeout() 方法设置的 timeout。\n- setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。\n- clearInterval() 取消由 setInterval() 设置的 timeout。\n\n### this指向问题\n\n1. 全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）\n2. 方法调用中谁调用this指向谁\n3. 构造函数中this指向构造函数的实例\n\n## location\n\n### 属性\n\n属性       | 描述\n-------- | ---------------------------\nhash     | 设置或返回从井号 (#) 开始的 URL（锚）。\nhost     | 设置或返回主机名和当前 URL 的端口号。\nhostname | 设置或返回当前 URL 的主机名。\nhref     | 设置或返回完整的 URL。\npathname | 设置或返回当前 URL 的路径部分。\nport     | 设置或返回当前 URL 的端口号。\nprotocol | 设置或返回当前 URL 的协议。\nsearch   | 设置或返回从问号 (?) 开始的 URL（查询部分）。\n\n### 方法\n\n属性        | 描述\n--------- | --------------------------\nassign()  | 加载新的文档。\nreload()  | 重新加载当前文档。\nreplace() | 用新的文档替换当前文档（不在历史记录中，无法后退）。\n\n## navigator\n\n### 属性\n\n属性              | 描述\n--------------- | -----------------------------\nappCodeName     | 返回浏览器的代码名。\nappMinorVersion | 返回浏览器的次级版本。\nappName         | 返回浏览器的名称。\nappVersion      | 返回浏览器的平台和版本信息。\nbrowserLanguage | 返回当前浏览器的语言。\ncookieEnabled   | 返回指明浏览器中是否启用 cookie 的布尔值。\ncpuClass        | 返回浏览器系统的 CPU 等级。\nonLine          | 返回指明系统是否处于脱机模式的布尔值。\nplatform        | 返回运行浏览器的操作系统平台。\nsystemLanguage  | 返回 OS 使用的默认语言。\nuserAgent       | 返回由客户机发送服务器的 user-agent 头部的值。\nuserLanguage    | 返回 OS 的自然语言设置。\n\n## history\n\n属性     | 描述\n------ | -------------------\nlength | 返回浏览器历史列表中的 URL 数量。\n\n方法        | 描述\n--------- | -----------------------\nback()    | 加载 history 列表中的前一个 URL。\nforward() | 加载 history 列表中的下一个 URL。\ngo()      | 加载 history 列表中的某个具体页面。\n\n## screen\n\n属性                   | 描述\n-------------------- | ----------------------------\navailHeight          | 返回显示屏幕的高度 (除 Windows 任务栏之外)。\navailWidth           | 返回显示屏幕的宽度 (除 Windows 任务栏之外)。\nbufferDepth          | 设置或返回调色板的比特深度。\ncolorDepth           | 返回目标设备或缓冲器上的调色板的比特深度。\ndeviceXDPI           | 返回显示屏幕的每英寸水平点数。\ndeviceYDPI           | 返回显示屏幕的每英寸垂直点数。\nfontSmoothingEnabled | 返回用户是否在显示控制面板中启用了字体平滑。\nheight               | 返回显示屏幕的高度。\nlogicalXDPI          | 返回显示屏幕每英寸的水平方向的常规点数。\nlogicalYDPI          | 返回显示屏幕每英寸的垂直方向的常规点数。\npixelDepth           | 返回显示屏幕的颜色分辨率（比特每像素）。\nupdateInterval       | 设置或返回屏幕的刷新率。\nwidth                | 返回显示器屏幕的宽度。\n\n## JS执行机制\n\n- JS是单线程\n\n单线程导致的问题就是后面的任务等待前面任务完成，如果前面任务很耗时，后面任务不得不一直等待，为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制。于是，JS 中出现了**同步任务**和**异步任务**\n\n![202001271945](/assets/202001271945.png)\n\nJS执行机制（事件循环）\n\n![202001271947](/assets/202001271947.png)\n\n由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为**事件循环(event loop)**\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}