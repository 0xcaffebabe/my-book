{"content":"# 事件\n\n## 事件三要素\n\n- 事件源（谁）：触发事件的元素\n- 事件类型（什么事件）： 例如 click 点击事件\n- 事件处理程序（做什么）：事件触发后要执行的代码(函数形式)，事件处理函数\n\n## 执行事件的步骤\n\n- 获取事件源\n- 注册事件\n- 添加事件处理程序\n\n## 注册事件\n\n### 传统注册方式\n\n```javascript\nbutton.onclick = function(){}\n```\n\n同一个元素同一个事件只能设置一个处理函数，后注册的会覆盖先注册的\n\n### 监听注册方式\n\n```javascript\nbutton.addEventListener('click',function(e){})\n```\n\n同一个元素可以注册多个处理函数，按注册顺序依次执行\n\n## 删除事件\n\n```javascript\n// 传统方式\nbutton.onclick = null;\nbutton.removeEventListener('click',fn);\n```\n\n## DOM事件流\n\n![202001261211](/assets/202001261211.png)\n\n- 事件冒泡：事件开始时有最具体的元素接收，然后逐级向上传播到DOM最顶层节点的过程\n- 事件捕获：由DOM最顶层节点开始，然后主机向下传播到最具体的元素接收的过程\n\nDOM 事件流会经历3个阶段：\n\n1. 捕获阶段\n2. 当前目标阶段\n3. 冒泡阶段\n\n`addEventListener`的第三个参数如果是true表示在事件捕获阶段调用事件处理函数，反之则是在事件冒泡阶段调用\n\n## 事件对象\n\n> 事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象\n\n在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找\n\n### 常见属性和方法\n\n![202001261356](/assets/202001261356.png)\n\n```javascript\n常情况下terget 和 this是一致的，\n但有一种情况不同，那就是在事件冒泡时（父子元素有相同事件，单击子元素，父元素的事件处理函数也会被触发执行），\n    这时候this指向的是父元素，因为它是绑定事件的元素对象，\n    而target指向的是子元素，因为他是触发事件的那个具体元素对象。\n```\n\n阻止默认行为\n\n```javascript\na.onclick = function(e) {\n    // 普通浏览器 e.preventDefault();  方法\n    e.preventDefault();\n    // 低版本浏览器 ie678  returnValue  属性\n    e.returnValue = false;\n    // 我们可以利用return false 也能阻止默认行为 没有兼容性问题\n    return false;\n}\n```\n\n阻止冒泡\n\n```javascript\n// 阻止事件继续向上传递给父组件\nson.addEventListener('click', function(e) {\n    alert('son');\n    e.stopPropagation(); // stop 停止  Propagation 传播\n    window.event.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡\n}, false);\n```\n\n#### 事件委托\n\n给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素\n\n- 我们只操作了一次 DOM ，提高了程序的性能。\n- 动态新创建的子元素，也拥有事件。\n\n## 常见事件\n\n### 鼠标事件\n\n![202001261443](/assets/202001261443.png)\n\n鼠标事件对象\n\n![202001261445](/assets/202001261445.png)\n\n### 键盘事件\n\n键盘事件       | 触发条件\n---------- | ---------------------\nonkeyup    | 某个键盘按键被松开时触发\nonkeydown  | 某个键盘按键被按下时触发\nonkeypress | 某个键盘按键被按下时触发，但是不识别功能键\n\n键盘事件对象\n\n- keyCode：返回该键的ASCII值\n\n### mouseenter 和mouseover的区别\n\n当鼠标移动到元素上时就会触发mouseenter 事件，- mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter 只会经过自身盒子触发，之所以这样，就是因为mouseenter不会冒泡，跟mouseenter搭配鼠标离开 mouseleave 同样不会冒泡\n\n### 触屏事件\n\n移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android和 IOS 都有\n\n常见的触屏事件\n\n触屏事件       | 说明\n---------- | ----------------\ntouchstart | 手指触摸到一个DOM元素时触发\ntouchmove  | 手指在一个DOM元素上滑动时触发\ntouchend   | 手指从一个DOM元素上移开时触发\n\n#### 触摸事件对象（TouchEvent）\n\n触摸列表           | 说明\n-------------- | -------------------------\ntouches        | 正在触发屏幕的所有手指的一个列表\ntargetTouches  | 正在触发当前DOM元素上的手指的一个列表\nchangedTouches | 手指状态发生了改变的列表，从无到有，从有到无的变化\n\n### click 延时解决方案\n\n移动端 click 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放(double tap to zoom) 页面\n\n1. 禁用缩放\n\n```html\n<meta name=\"viewport\" content=\"user-scalable=no\">\n```\n\n2. 利用touch事件封装事件解决300ms 延迟\n\n  - 当我们手指触摸屏幕，记录当前触摸时间\n  - 当我们手指离开屏幕， 用离开的时间减去触摸的时间\n  - 如果时间小于150ms，并且没有滑动过屏幕， 那么我们就定义为点击\n\n3. fastclick 插件\n\n```js\nif ('addEventListener' in document) {\n\tdocument.addEventListener('DOMContentLoaded', function() {\n\t\tFastClick.attach(document.body);\n\t}, false);\n}\n```\n\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}