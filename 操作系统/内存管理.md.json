{"content":"# 内存管理\n\n**分层存储器体系**\n\n**存储管理器**：操作系中管理分层存储器体系的部分\n\n## 无存储器抽象\n\n_PSW（程序状态字）_\n\nIBM 360系统的不用交换运行多个程序\n\n_避免绝对物理地址的引用_\n\n![ing](https://img-blog.csdnimg.cn/20181109175044133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMTI1MTgz,size_16,color_FFFFFF,t_70)\n\n## 存储器抽象：地址空间\n\n### 概念\n\n运行多个程序互相不影响，需要解决两问题：\n\n- 保护\n- 重定位\n\n**基址寄存器与界限寄存器** _动态重定位_\n\n### 交换技术\n\n> 把一个进程完整调入内存，使该进程运行一段时间，再将其写回磁盘\n\n**内存紧缩**：将小空闲区合并成一大块\n\n### 空闲内存管理\n\n- 使用位图的存储管理\n\n  ![img](https://img-blog.csdnimg.cn/20181109175114553.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMTI1MTgz,size_16,color_FFFFFF,t_70)\n\n- 使用链表\n\n  ![](https://img-blog.csdnimg.cn/20181109175121227.png)\n\n- 首次适配算法\n\n- 下次适配算法\n\n- 最佳适配算法\n\n- 最差适配算法\n\n- 快速适配算法\n\n## 虚拟内存\n\n> 地址空间被分为多块，每块称作**页** 页被映射到物理内存，如果程序引用不存在的物理内存 由操作系统负责将缺失的部分装入物理内存\n\n### 分页\n\n**缺页中断**：当访问的页没有映射到物理内存中时，操作系统会将其他的页写到磁盘，将空出来的内存映射给当前的页，**内存管理单元（MMU）** 则是执行这个映射的服务\n\n![202032184635](/assets/202032184635.png)\n\n### 页表\n\n- 页表项的结构\n\n  - 保护位：允许什么类型的访问（读、写、执行）\n  - 修改位：判断页面是否被写过\n  - 访问位：判断页面是否被访问过\n  - 高速缓存禁止位\n\n![](https://img-blog.csdnimg.cn/20181109175139805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMTI1MTgz,size_16,color_FFFFFF,t_70)\n\n### 加速分页过程\n\n分页系统需要考虑的2个问题：\n\n- 虚拟地址映射到物理地址必须非常快\n- 如果虚拟地址空间很大，则页表也会很大\n\n**转换检测缓冲区（TLB）**：小型硬件设备，能直接将虚拟地址映射成物理地址，而无需访问页表（二八定律）\n\n#### 软件TLB管理\n\n_软失效与硬失效_\n\n### 针对大内存的页表\n\n- 多级页表\n\n  ![](https://img-blog.csdnimg.cn/20181109175148764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMTI1MTgz,size_16,color_FFFFFF,t_70)\n\n- 倒排页表\n\n  _地址映射与散列查找_\n\n  ![](https://img-blog.csdnimg.cn/20181109175155999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMTI1MTgz,size_16,color_FFFFFF,t_70)\n\n## 页面置换算法\n\n**主要目的**：挑选出最不常使用的页面\n\n_WEB服务器文件缓存_\n\n- 最优页面置换算法（OPT, Optimal replacement algorithm）\n\n_无法确定哪个页面未来最少被使用_ ，该算法只是一种理论算法，无法实现\n\n- 最近未使用(NRU)页面置换算法\n\n随机淘汰最近一个时钟周期没有访问、没有修改的页面\n\n- 先进先出页面置换算法（FIFO, First In First Out）\n\n选择换出的页面是最先进入的页面\n\n- 第二次机会页面置换算法\n\n淘汰掉一个进入时间最长，且最久未被使用的页面\n\n- 时钟页面置换算法\n\n使用一个指针指向最老的页面\n\n![202032185224](/assets/202032185224.png)\n\n- 最近最少使用(LRU)页面置换算法\n\n在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的\n\n- 工作集页面置换算法\n\n**工作集**：进程当前正在使用的页面集合 淘汰掉工作集中最少使用的页面\n\n- 工作集时钟页面置换算法\n\n### 用软件模拟LRU\n\n**最不常使用（NFU）** 会记住最近一段时间内各个时钟周期的访问情况\n\n![](https://img-blog.csdnimg.cn/20181109175201581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMTI1MTgz,size_16,color_FFFFFF,t_70)\n\n## 分页系统中的设计问题\n\n### 局部分配策略与全局分配策略\n\n**缺页中断率（PFF）**：用来指出何时增加或减少分配给进程的页面\n\n### 负载控制\n\n将进程从内存交换到磁盘\n\n### 页面大小\n\n- 选择小页面的好处：节省内存\n\n### 分离的指令空间和数据空间\n\n![](https://img-blog.csdnimg.cn/20181109175214814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMTI1MTgz,size_16,color_FFFFFF,t_70)\n\n### 共享页面\n\n如果地址空间分离实现共享页面就会非常简单 **写时复制**\n\n![](https://img-blog.csdnimg.cn/20181109175220998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMTI1MTgz,size_16,color_FFFFFF,t_70)\n\n### 共享库\n\n**位置无关代码**：只使用相对偏移量的代码\n\n### 内存映射文件\n\n把文件当做成一个内存中的大字符数组\n\n### 清除策略\n\n**分页守护进程**\n\n### 虚拟内存接口\n\n_分布式共享内存_\n\n## 有关实现的问题\n\n- 与分页有关的工作\n\n  - 创建一个新进程时：确定程序和数据大小，创建一个页表\n  - 进程执行时：重置MMU,刷新TLB，清除之前进程的痕迹\n  - 缺页中断时：确定是哪个虚拟地址发生了中断，读入所需页面，重新执行指令\n  - 进程退出时：释放页表、页面\n\n- 缺页中断处理\n\n- 指令备份 重启引起缺页中断的那条指令，这不是一件容易的事\n\n- 锁定内存中的页面 锁住正在做IO操作的内存中的页面保证它不会被移出内存\n\n- 后备存储 _linux中的swap_\n\n- 策略与机制分离\n\n  - MMU\n  - 缺页中断处理程序\n  - 页面调度程序\n\n![](https://img-blog.csdnimg.cn/20181109175233602.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIxMTI1MTgz,size_16,color_FFFFFF,t_70)\n\n## 分段\n\n**表碰撞**：动态增长的表会导致覆盖的问题\n\n![202032185558](/assets/202032185558.png)\n\n### 纯分段的实现\n\n### 段页式\n\n程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能\n\n### 分段和分页结合：MULTICS\n\n段（段号，段内地址（页号，偏移地址））\n\n### 分段和分页结合：Intel x86\n\nLDT与GDT 线性地址（目录，页面，偏移量）\n\n### 分页与分段\n\n对比     | 分页                    | 分段\n------ | --------------------- | ----------------------\n透明性    | 对程序员透明                | 需要程序员显示划分每个段\n地址空间维度 | 一维地址                  | 二维地址\n大小可否改变 | 页大小不可改变               | 段大小可以动态改变\n出现原因   | 分页用来实现虚拟内存，以获得更大的地址空间 | 分段是为了独立程序和数据并且有助于共享与保护\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}