{"content":"# Docker\n\n> Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口\n\n使用场景\n\n- 持续集成\n- 可伸缩的云服务\n- 微服务架构\n\n## 容器与虚拟机\n\n![2020822151647](/assets/2020822151647.png)\n\n虚拟机最大的缺点就是依赖其专用的操作系统\n\n## Docker架构\n\n![](https://www.runoob.com/wp-content/uploads/2016/04/576507-docker1.png)\n\n- 镜像与容器\n  - 容器是镜像的实例\n\n## 安装\n\n- 安装脚本\n\n```shell\nwget https://get.docker.com\n```\n\n## 引擎\n\nDocker引擎由如下主要的组件构成：Docker客户端（Docker Client）、Docker守护进程（Docker daemon）、containerd以及runc。它们共同负责容器的创建和运行\n\n![2020822154342](/assets/2020822154342.png)\n\nLXC提供了对诸如命名空间（Namespace）和控制组（CGroup）等基础工具的操作能力，它们是基于Linux内核的容器虚拟化技术\n\n![2020822154039](/assets/2020822154039.png)\n\nDocker公司开发了名为Libcontainer的自研工具，用于替代LXC\n\nrunc：\n\n- 创建容器\n\ncontainerd：\n\n- 容器的生命周期管理\n\n启动容器的过程：\n\n![2020822154716](/assets/2020822154716.png)\n\n容器运行时与Docker daemon是解耦的,对Docker daemon的维护和升级工作不会影响到运行中的容器\n\nshim：\n\n- 保持所有STDIN和STDOUT流是开启状态\n- 将容器的退出状态反馈给daemon\n\n## 镜像\n\n![2020823154249](/assets/2020823154249.png)\n\n### 镜像使用\n\n- 搜索镜像\n\n```shell\ndocker search name\n```\n\n- 拉取镜像\n\n```shell\ndocekr pull name<:tag>\n```\n\n- 删除镜像\n\n```shell\ndocker rmi 镜像ID\ndocker image rm $(docker image ls -q) -f\n```\n\n### 标签\n\n在镜像名后面的:xxx 代表标签\n\n没有标签的镜像被称为悬虚镜像\n\n### 分层\n\n![2020823154946](/assets/2020823154946.png)\n\ndocker 会复用已存在的镜像层\n\n### 镜像仓库\n\n![2020823154458](/assets/2020823154458.png)\n\n#### 搭建\n\n```shell\ndocekr pull registry\n```\n\n```shell\ndocker run -di --name=registry 5000:5000 registry   \n```\n\n## 上传镜像到私服\n\n```shell\ndocker tag nginx 127.0.0.1:5000/nginx \n```\n\n```shell\ndocker push 127.0.0.1:5000/nginx \n```\n\n## 容器\n\n### 持久化\n\n容器在停止后启动写入的数据仍会存在\n\n但是volume才是持久化的首选\n\n### 重启策略\n\n在指定事件或者错误后重启来完成自我修复\n\n- always\n- unless-stoped\n- on-failed\n\n### 容器使用\n\n- 查看容器\n\n```shell\ndocker ps\n```\n\n- 运行一个容器\n\n```shell\ndocker run -p 8080:80 -d daocloud.io/nginx\n```\n\n- 复制文件到容器中\n\n```shell\ndocker cp index.html e07dc4e0236a://usr/share/nginx/html\n```\n\n- 从容器中复制出文件\n\n```shell\ndocker cp name:容器文件路径 宿主路径\n```\n\n- 停止容器\n\n```shell\ndocker stop name\n# 优雅关闭并删除：stop rm\n```\n\n- 启动容器\n\n```shell\ndocker start name\n```\n\n- 进入容器内部\n\n```shell\ndocker exec -it <name> bash\n```\n\n- 目录挂载\n  - 在启动容器时，使用`-v`参数\n\n- 查看容器信息\n\n```shell\ndocker inspect name\n```\n\n- 查看容器日志\n\n```sh\ndocker logs name\n```\n\n## 常用软件部署\n\n- mysql\n\n```shell\n# 将宿主机33306映射到容器3306，指定root密码为123\ndocker run -di --name=mysql1 -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123 mysql \n```\n\n- tomcat\n\n```shell\ndocker run -di --name=mytomcat -p 9000:8080 -v /usr/local/webapps:/usr/local/tomcat/webapps tomcat \n```\n\n- nginx\n\n```shell\ndocker run -di --name=mynginx2 -p 8080:80 nginx-update \n```\n\n## 迁移与备份\n\n\n- 保存镜像\n\n```shell\ndocker commit -m 'update' e07dc4e0236a nginx-update\n```\n\n- 保存为压缩包\n\n```shell\ndocker save -o nginx-update.tar nginx-update\n```\n\n- 把压缩包恢复成镜像\n\n```shell\ndocker load -i nginx-update.tar\n```\n\n## 容器化\n\n![202082316156](/assets/202082316156.png)\n\n### Dockerfile\n\n![批注 2019-07-25 153841](/assets/批注%202019-07-25%20153841.png)\n\n编写Dockerfile文件：\n\n```docker\nFROM ubuntu\nMAINTAINER MY\nRUN apt-get update\nRUN apt-get install nginx -y\nCOPY index.html /var/www/html\nENTRYPOINT [\"/usr/sbin/nginx\",\"-g\",\"daemon off;\"]\nEXPOSE 80\n```\n\n每一个RUN指令会新增一个镜像层。因此，通过使用&& 连接多个命令以及使用反斜杠（\\ ）换行的方法，将多个命令包含在一个RUN指令中，通常来说是一种值得提倡的方式\n\n根据文件构建镜像：\n\n```shell\ndocker build -t='name' .\n```\n\n### DockerMaven插件\n\n- 开启docker接受远程操作\n- 添加maven插件\n\n```xml\n<plugin>\n    <groupId>com.spotify</groupId>\n    <artifactId>docker-maven-plugin</artifactId>\n    <version>0.4.12</version>\n    <configuration>\n      <!-- 注意imageName一定要是符合正则[a-z0-9-_.]的，否则构建不会成功 -->\n      <!-- 详见：https://github.com/spotify/docker-maven-plugin    Invalid repository name ... only [a-z0-9-_.] are allowed-->\n      <imageName>my-pc:5000/${project.artifactId}:${project.version}</imageName>\n        <baseImage>java</baseImage>\n        <entryPoint>[\"java\", \"-jar\", \"/${project.build.finalName}.jar\"]</entryPoint>\n          <resources>\n              <resource>\n                  <targetPath>/</targetPath>\n                  <directory>${project.build.directory}</directory>\n                  <include>${project.build.finalName}.jar</include>\n              </resource>\n          </resources>\n        <dockerHost>http://my-pc:2375</dockerHost>\n     </configuration>\n</plugin>\n```\n\n- JDK8以上的版本需要添加如下依赖\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>javax.activation</groupId>\n        <artifactId>activation</artifactId>\n        <version>1.1.1</version>\n    </dependency>\n</dependencies>\n```\n\n- 构建并推送\n\n```shell\nmvn clean package docker:build -DpushImage\n```\n\n\n### 推送到仓库\n\n```sh\ndocker images push\n```\n\n![202082316201](/assets/202082316201.png)\n\n### 多阶段构建\n\n```Dockerfile\nFROM xxx AS T1\n\nFROM xxx AS T2\nCOPY --from=T1 ...\n```\n\n### 最佳实践\n\n利用构建缓存：\n\n- 执行命令时，Docker会检查构建缓存中是否存在基于同一基础镜像，并且执行了相同指令的镜像层\n\n合并镜像：\n\n- 执行docker image build 命令时，可以通过增加--squash 参数来创建一个合并的镜像\n\n![202082316289](/assets/202082316289.png)\n\nno-install-recommends：\n\n- 若使用的是APT包管理器，则应该在执行apt-get install 命令时增加no-install-recommends 参数。这能够确保APT仅安装核心依赖（Depends 中定义）包\n\n不要安装MSI包（Windows）\n\n## Compose\n\n编写docker-compose.yml:\n\n```yml\nversion: \"3.5\"\nservices:\n  redis:\n    image: \"redis:alpine\"\n    networks:\n      my-net:\n  nginx:\n    image: \"nginx\"\n    networks:\n      my-net:\nnetworks:\n  my-net:\n\nvolumes:\n  my-net:\n```\n\n启动：\n\n```sh\ndocker-compose up\n```\n\n## Docker 网络\n\nCNM: 定了Docker网络架构的基础组成要素\n\n![2020824154717](/assets/2020824154717.png)\n![2020824154742](/assets/2020824154742.png)\n\nLibnetwork是CNM标准的实现\n\n![2020824155551](/assets/2020824155551.png)\n\n```sh\ndocker network ls # 列出可用网络\ndocker run -d --network my-net # 指定容器网络\n```\n\n如果在相同网络中继续接入新的容器，那么在新接入容器中是可以通过的容器名称来进行网络通信的\n\n### 网络类型\n  \n- Bridge：: 单机桥接网络 Docker设计的NAT网络模型（默认类型）\n  -  只能在单个Docker主机上运行，并且只能与所在Docker主机上的容器进行连接\n\n![2020824155816](/assets/2020824155816.png)\n\n```sh\ndocker network create -d bridge localnet\n```\n\n- Host：与主机共享Network Namespace，--net=host\n- overlay：多机覆盖网络\n- 接入现有网络\n- None：:不为容器配置任何网络功能，没有网络 --net=none\n- Container：与另一个运行中的容器共享Network Namespace，--net=container:containerID\n- 端口映射\n\n```shell\n# 将本机8080端口映射到容器80端口\ndocker run -p 8080:80 <name>\n\n# 将本机端口随机与容器端口映射\ndocker run -P <name>\n```\n\n## 持久化\n\n每个Docker容器都有自己的非持久化存储。非持久化存储自动创建，从属于容器，生命周期与容器相同\n\n持久化是将数据存储在卷上。卷与容器是解耦的\n\n![2020825152949](/assets/2020825152949.png)\n![2020825153020](/assets/2020825153020.png)\n\n卷类型：\n\n- 块存储\n  - 适用于对小块数据的随机访问负载\n- 文件存储\n  - 包括NFS和SMB协议的系统\n- 对象存储\n  - 适用于较大且长期存储的、很少变更的二进制数据存储。通常对象存储是根据内容寻址\n\n### 卷操作\n\n```sh\ndocker volume create myv\ndocker volume inspect myv\ndocker run ... --mount source=bizvol,target=/vol # 指定容器存储卷\n```\n\n## 安全\n\n![202082516037](/assets/202082516037.png)\n\nDocker 平台安全技术：\n\n- Swarm模式\n  - 加密节点ID。\n  - 基于TLS的认证机制。\n  - 安全准入令牌。\n  - 支持周期性证书自动更新的CA配置。\n  - 加密集群存储（配置DB）。\n  - 加密网络\n- 内容信任\n  - 通过 Docker Hub 信任内容\n- 密钥\n  - 使用`docker secret`管理密钥","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}