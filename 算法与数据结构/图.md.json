{"content":"# 图\n\n## 一些概念\n\n一个图（一般记作{\\displaystyle G}G）由两类元素构成，分别称为**顶点**（或节点、结点）和**边**。每条边有两个顶点作为其端点，我们称这条边“连接”了它的两个端点\n\n**分类**\n\n- 有向图与无向图\n- 有权图与无权图\n\n## 表示方法\n\n- 邻接矩阵\n\n![批注 2020-02-12 093539](/assets/批注%202020-02-12%20093539.png)\n\n```java\nboolean[][] g;\n// n代表顶点的数量，v代表边的数量\nint n, m;\n// 判断两个顶点是否存在边\nboolean hasEdge(int v, int w) {\n    return g[v][w];\n}\n// 给两个顶点增加一条边\nvoid addEdge(int v, int w) {\n    if (hasEdge(v, w)) {\n        return;\n    }\n    g[v][w] = true;\n    if (!directed) {\n        g[w][v] = true;\n    }\n    m++;\n}\n// \n```\n\n- 邻接表\n\n![批注 2020-02-12 093727](/assets/批注%202020-02-12%20093727.png)\n\n```java\nList<List<Integer>> g;\nvoid addEdge(int v, int w) {\n    g.get(v).add(w);\n    if (!directed && v != w) {\n        g.get(w).add(v);\n    }\n    m++;\n}\nboolean hasEdge(int v, int w) {\n    for (int i = 0; i < g.get(v).size(); i++) {\n        if (g.get(v).get(i).equals(w)) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n邻接表适合表示稀疏的图，邻接矩阵适合表示稠密的图\n\n## 搜索\n\n- 深度优先\n\n从一个点开始 如果这个点没有被访问过 则选择该点的某个连接点进行深度优先搜索 直到所有能访问的顶点都被访问过\n\n![202002121156](/assets/202002121156.png)\n\n```java\nfor (int i = 0; i < graph.V(); i++) {\n    // 对每个节点进行深度优先遍历\n    if (!visited[i]) {\n        dfs(i);\n    }\n}\nvoid dfs(int v) {\n    visited[v] = true;\n    id[v] = count;\n    // 对传进来的节点所连接的节点再进行DFS\n    GraphIterator iterator = graph.iterator(v);\n    for (int i = iterator.begin(); !iterator.end(); i = iterator.next()) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n}\n```\n\n- 广度优先\n\n![](https://img-blog.csdn.net/20170710121420612?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvSnVyYm8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n从一个点开始 逐个遍历与该点连接的所有顶点 在遍历某节点时 将该节点的所有连接点入队 每次进行广度搜索的节点就从队列里面拿\n\n两个算法的不同之处只在于获取下一个节点的方式不一样\n\n- 广度优先下一个节点是最早加入的节点\n- 深度优先下一个节点是最晚加入的节点\n\n## 连通分量\n\n>无向图G的极大连通子图称为G的连通分量\n\n## 有向图\n\n### 表示\n\n同样也是使用邻接表表示\n\n### 可达性\n\nDFS 与　BFS　同样适用于有向图\n\n### 环\n\n- 拓扑排序\n\n将所有顶点排序，使得所有的有向边均从排在前面的元素指向后面的元素\n\n### 强连通性\n\n如果两个顶点互相可达，则称它们是强连通的\n\n## 有权图\n\n### 表示\n\n- 邻接表\n\n![批注 2020-02-13 113821](/assets/批注%202020-02-13%20113821.png)\n\n- 邻接表\n\n![批注 2020-02-13 113923](/assets/批注%202020-02-13%20113923.png)\n\n一副连通加权无向图中一棵权值最小的生成树\n\n## 最小生成树\n\n- 贪心算法\n\n>找到最小生成树的一条边，不断重复，直到找到所有最小生成树的所有边\n\n### Prim算法\n\n每次将一个与树节点连接但不在树中且权值最小的边加入树，直至边数达到节点数-1\n\n![202002131423](/assets/202002131423.png)\n\n### kruskal算法\n\n每次将权值最小的且不会构成环的边加入生成树，直至边数达到节点数-1\n\n![202002131458](/assets/202002131458.png)\n\n![202002131459](/assets/202002131459.png)\n\n- 如何判断环\n\n当边加入之后，使用union find判断从某一节点是否连接它自己，如果是，则就是有环\n\n## 最短路径\n\n找到从一个顶点到另一个顶点成本最小的路径\n\n### Dijkstra算法\n\n- 前提：图中不能存在负权边\n\n![202002140953](/assets/202002140953.jpg)\n\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}