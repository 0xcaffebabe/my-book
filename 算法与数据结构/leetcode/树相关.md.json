{"content":"# 树相关的算法题\n\n这种题目的解法特点一般就是两种，递归跟迭代。\n\n很多题目的解法基本都是通过前中后序遍历的方式来解。迭代的话主要得利用一个额外的栈，通过不断的出入栈来模拟递归。\n\n## 相同的树\n\n给定两个二叉树，编写一个函数来检验它们是否相同\n\n<https://leetcode-cn.com/problems/same-tree/>\n\n- 解法\n\n对两棵树做前序遍历，结果存到两个list，比较两个lsit即可\n需要注意的是，需要特别处理左树为空，但右树不为空的情况\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        ArrayList<Integer> list1 = new ArrayList<>();\n        ArrayList<Integer> list2 = new ArrayList<>();\n        preWalk(p,list1);\n        preWalk(q,list2);\n        return list1.equals(list2);\n    }\n    public void preWalk(TreeNode p, List<Integer> list){\n        if (p == null){\n            return ;\n        }\n        list.add(p.val);\n        if (p.left == null && p.right != null) {\n            list.add(null);\n        }\n        preWalk(p.left,list);\n        preWalk(p.right,list);\n    }\n}\n```\n\n耗时:0ms\n\n## 二叉树的最大深度\n\n给定一个二叉树，找出其最大深度。\n\n<https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/>\n\n- 解法\n\n同上题，传入根节点，如果根节点为空，返回0\n否则i++\n接下来递归获取左右子树的深度，获取最大深度，累加到i即可\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        return getDepth(root,0);\n    }\n    public int getDepth(TreeNode root,int i) {\n        if (root == null) {\n            return 0;\n        }\n        i++;\n        int left = getDepth(root.left,0);\n        int right = getDepth(root.right,0);\n        if (left > right) {\n            return i + left;\n        }else {\n            return i + right;\n        }\n    }\n}\n```\n\n耗时：0ms\n\n## 二叉树的层次遍历\n\n给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n\n<https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/>\n\n- 解法\n\n对树做前序遍历，将结果写到list里，再对list进行reverse\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        ArrayList<List<Integer>> list = new ArrayList<>();\n        walk(root,list,0);\n        Collections.reverse(list);\n        return list;\n    }\n    public void walk(TreeNode root,ArrayList<List<Integer>> list,int p) {\n        if (root == null) {\n            return;\n        }\n        if (list.size()<=p) {\n            list.add(p,new ArrayList<>());\n        }\n        list.get(p).add(root.val);\n        walk(root.left,list,p+1);\n        walk(root.right,list,p+1);\n    }\n}\n```\n\n耗时：1ms\n\n## 二叉树的最小深度\n\n<https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/submissions/>\n\n```java\nclass Solution {\n    public int minDepth(TreeNode root) {\n        if (root == null) return 0;\n        if (root.left == null && root.right == null) return 1;\n        int l = minDepth(root.left)+1;\n        int r = minDepth(root.right)+1;\n        if (root.left == null || root.right == null){\n            return Math.max(l,r);\n        }else{\n            return Math.min(l,r);\n        }\n    }\n}\n```\n\n耗时：0\n\n## 二叉树的中序遍历\n\n<https://leetcode-cn.com/problems/binary-tree-inorder-traversal/>\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> list = new ArrayList<>();\n        walk(root, list);\n        return list;\n    }\n    private void walk(TreeNode root, List<Integer> list){\n        if (root == null) return;\n        walk(root.left, list);\n        list.add(root.val);\n        walk(root.right, list);\n    }\n}\n```\n\n耗时：0\n\n## 226. 翻转二叉树\n\n<https://leetcode-cn.com/problems/invert-binary-tree/>\n\n```java\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        invertTree0(root);\n        return root;\n    }\n    private void invertTree0(TreeNode root){\n        if (root == null) return;\n        \n        TreeNode t = root.left;\n        root.left = root.right;\n        root.right = t;\n\n        if (root.left !=null) invertTree0(root.left);\n        if (root.right !=null) invertTree0(root.right);\n    }\n}\n```\n\n耗时：0\n\n## 110. 平衡二叉树\n\n<https://leetcode-cn.com/problems/balanced-binary-tree/>\n\n```java\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        if (root == null) return true;\n        if (root.left == null && root.right == null) return true;\n        \n        if (Math.abs(treeHeight(root.left, 0) - treeHeight(root.right, 0)) > 1) return false;\n        return isBalanced(root.left) && isBalanced(root.right);\n    }\n\n    private int treeHeight(TreeNode root, int i){\n        if (root == null) return i;\n        i++;\n        int l = treeHeight(root.left, i);\n        int r = treeHeight(root.right, i);\n        return l > r ? l : r;\n    }\n}\n```\n\n耗时：1\n\n## 145. 二叉树的后序遍历\n\n<https://leetcode-cn.com/problems/binary-tree-postorder-traversal/>\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> list = new ArrayList<>();\n        postOrder(root, list);\n        return list;\n    }\n\n    private void postOrder(TreeNode root, List<Integer> list){\n        if (root == null) return;\n        postOrder(root.left, list);\n        postOrder(root.right, list);\n        list.add(root.val);\n    }\n}\n```\n\n耗时：0\n\n## 230. 二叉搜索树中第K小的元素\n\n<https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/>\n\n```java\nclass Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        return getKMin(root,k,new int[]{0});\n    }\n\n    public int getKMin(TreeNode root,int k,int[] i){\n        if (root == null) return -1;\n        int l = getKMin(root.left, k,i);\n        i[0]++;\n        if (i[0] == k) {\n            return root.val;\n        }\n        \n        int r = getKMin(root.right, k,i);\n        if (l != -1) {\n            return l;\n        }\n        if (r != -1) {\n            return r;\n        }\n        \n        return -1;\n    }\n}\n```\n\n耗时：0\n\n## 222. 完全二叉树的节点个数\n\n<https://leetcode-cn.com/problems/count-complete-tree-nodes/>\n\n```java\nclass Solution {\n    public int countNodes(TreeNode root) {\n        if (root == null) return 0;\n        if (root.left == null && root.right == null) return 1;\n        int l = countNodes(root.left);\n        int r = countNodes(root.right);\n        return l + r + 1;\n    }\n}\n```\n\n耗时：0\n\n## 144. 二叉树的前序遍历\n\n<https://leetcode-cn.com/problems/binary-tree-preorder-traversal/>\n\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> list = new ArrayList<>();\n        preTravel(root,list);\n        return list;\n    }\n\n    private void preTravel(TreeNode root, List<Integer> list){\n        if (root == null) return;\n        list.add(root.val);\n        preTravel(root.left, list);\n        preTravel(root.right, list);\n    }\n}\n```\n\n耗时：0\n\n## 872. 叶子相似的树\n\n<https://leetcode-cn.com/problems/leaf-similar-trees/>\n\n```java\nclass Solution {\n    public boolean leafSimilar(TreeNode root1, TreeNode root2) {\n        List<Integer> list1 = new ArrayList<>();\n        List<Integer> list2 = new ArrayList<>();\n        getLeafNodes(root1, list1);\n        getLeafNodes(root2, list2);\n        return list1.equals(list2);\n    }\n    private void getLeafNodes(TreeNode root, List<Integer> list){\n        if (root == null) return ;\n        if (root.left == null && root.right == null) list.add(root.val);\n        getLeafNodes(root.left, list);\n        getLeafNodes(root.right, list);\n    }\n}\n```\n\n耗时：0\n\n## 897. 递增顺序查找树\n\n<https://leetcode-cn.com/problems/increasing-order-search-tree/>\n\n```java\nclass Solution {\n    public TreeNode increasingBST(TreeNode root) {\n        if (root == null) return null;\n        List<Integer> list = new ArrayList<>();\n        travel(root, list);\n        TreeNode ret = new TreeNode();\n        TreeNode origin = ret;\n        for(int i=0;i<list.size();i++){\n            ret.val = list.get(i);\n            if (i == list.size() -1) break;\n            ret.right = new TreeNode();\n            ret = ret.right;\n        }\n        return origin;\n    }\n    private void travel(TreeNode root, List<Integer> list){\n        if (root == null) return;\n        travel(root.left, list);\n        list.add(root.val);\n        travel(root.right, list);\n    }\n}\n```\n\n耗时：0\n\n## 671. 二叉树中第二小的节点\n\n<https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/>\n\n```java\nclass Solution {\n    private int min = Integer.MAX_VALUE;\n    private int secMin = Integer.MAX_VALUE;\n    private boolean existsSecMin = false;\n    public int findSecondMinimumValue(TreeNode root) {\n        findMin(root);\n        findSecMin(root);\n        if (!existsSecMin) return -1;\n        return secMin;\n    }\n\n    private void findMin(TreeNode root) {\n        if (root == null) return;\n        if (root.val <= min) min = root.val;\n        findMin(root.left);\n        findMin(root.right);\n    }\n\n    private void findSecMin(TreeNode root) {\n        if (root == null) return;\n        if (root.val <= secMin && root.val > min) {\n            secMin = root.val;\n            existsSecMin = true;\n        }\n        findSecMin(root.left);\n        findSecMin(root.right);\n    }\n}\n```\n\ntime:0 beat:100\n\n## 1038. 把二叉搜索树转换为累加树\n\n<https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/>\n\n```java\nclass Solution {\n    private int sum;\n    private List<TreeNode> nodeList;\n    public TreeNode bstToGst(TreeNode root) {\n        nodeList = new ArrayList<>(100);\n        travel(root);\n        for(int i = 0;i<nodeList.size();i++){\n            TreeNode item = nodeList.get(i);\n            int orign = item.val;\n            item.val = sum;\n            sum -= orign;\n        }\n        return root;\n    }\n\n    private void travel(TreeNode root) {\n        if (root == null) return;\n        travel(root.left);\n        nodeList.add(root);\n        sum += root.val;\n        travel(root.right);\n    }\n}\n```\n\ntime:0 beat:100\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}