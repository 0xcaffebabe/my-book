{"content":"# leetcode\n\n## 两数之和\n\n给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。\n\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍\n\n>给定 nums = [2, 7, 11, 15], target = 9\n>\n>因为 nums[0] + nums[1] = 2 + 7 = 9\n>所以返回 [0, 1]\n\n\n- 解法1\n\n暴力求解，双重循环求得数组的两个项等于target的组合\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] ret =new int[2];\n        for(int i=0;i<nums.length;i++){\n            for(int j=i;j<nums.length;j++){\n                if(nums[i]+nums[j]==target\n                  && i!=j){\n                    ret[0]=i;\n                    ret[1]=j;\n                    return ret;\n                }\n            }\n        }\n        return ret;\n    }\n}\n```\n耗时:60-100ms\n\n- 解法2\n\n使用map存储(target-数组的item,index)\n遍历数组，根据数组的item查找到index，\n如果找到的index不与当前遍历的index相同，\n则结果就是当前的index与查找的index\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] result = new int[2];\n        Map<Integer,Integer> map = new HashMap<>();\n        for (int i=0;i<nums.length;i++){\n            map.put(target-nums[i],i);\n        }\n        for (int i=0;i<nums.length;i++){\n            Integer i1 = map.get(nums[i]);\n            if (i1 == null || i == i1) {\n                continue;\n            }\n            if (nums[i] + nums[i1] == target){\n                return new int[]{i,i1};\n            }\n        }\n        return result;\n    }\n}\n```\n\n耗时:3-4ms\n\n## 翻转32位整数\n\n123 -> 321\n\n- 解法1\n\n转换成字符串翻转\n\n```java\nclass Solution {\n    public int reverse(int x) {\n       boolean f = false;\n        if (x<0){\n            f=true;\n\n        }\n        long l = x;\n        String s = String.valueOf(l);\n\n        StringBuilder sb = new StringBuilder();\n        for(int i =s.length()-1;i>=0;i--){\n            sb.append(s.charAt(i));\n        }\n        if (sb.toString().charAt(sb.length()-1) == '-'){\n            sb = sb.replace(sb.length()-1,sb.length(),\"\");\n        }\n        long ret = Long.parseLong(sb.toString());\n        if (f){\n            ret = -ret;\n        }\n        if (ret > Integer.MAX_VALUE || ret <Integer.MIN_VALUE){\n            return 0;\n        }\n        return (int) ret;\n    }\n}\n```\n\n耗时：28ms\n\n- 解法2\n\n将这个数通过区域拆解成n个个位数\n再倒序n个个位数相加\n\n```java\nclass Solution {\n    public int reverse(int x) {\n        int i;\n        long result = 0;\n        LinkedList<Integer> list = new LinkedList<>();\n        long f =1;\n        while (x!=0){\n            i = x%10;\n            x/=10;\n            if (x!=0){\n                f*=10;\n            }\n            list.offer(i);\n        }\n        while(list.size() != 0){\n            result +=list.poll()*f;\n            f/=10;\n        }\n        // 判断溢出\n        return (int)result == result ? (int)result:0;\n    }\n}\n```\n\n使用队列解决正序转倒序问题\n\n耗时：3ms\n\n## 判断回文数\n\n判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数\n\n- 解法1\n\n转为字符串，生成该字符串的倒序字符串，进行判断\n\n```java\nclass Solution {\n    public boolean isPalindrome(int x) {\n        String s = String.valueOf(x);\n        StringBuilder sb = new StringBuilder();\n        for (int i=s.length()-1;i>=0;i--){\n            sb.append(s.charAt(i));\n        }\n        if (sb.toString().equals(s)){\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n耗时：146ms\n\n- 解法2\n\n过滤负数，逐一拆分为n个个位数倒序加入队列\n将队列元素出队，还原为倒序的整数，判断是否相等\n\n```java\nclass Solution {\n    public boolean isPalindrome(int x) {\n        int x1 = x;\n        if (x<0) {\n            return false;\n        }\n        LinkedList<Integer> queue = new LinkedList<>();\n        int f =1;\n        while(x !=0){\n            queue.add(x%10);\n            x = x/10;\n            if (x != 0) {\n                f *=10;\n            }\n        }\n        int ret = 0;\n        while (queue.size()!=0) {\n            ret+=queue.poll()*f;\n            f/=10;\n        }\n        return ret == x1;\n    }\n}\n```\n\n耗时：13ms\n\n## 罗马数字转整数\n\nV -> 5\nIV -> 4\n\n准备(字符,整数)，从下表1-结束扫描字符串\n找到罗马字符代表的整数，\n如果当前扫码的罗马字符比index-1的罗马字符还要小，\n    则将该罗马字符代表的整数累加到结果\n    否则减去两倍index-1位置的值（因为你前已经加了一遍）\n\n```java\nimport java.util.*;\nclass Solution {\n    public int romanToInt(String s) {\n        Map<Character,Integer> map = new HashMap<>();\n        map.put('I',1);\n        map.put('V',5);\n        map.put('X',10);\n        map.put('L',50);\n        map.put('C',100);\n        map.put('D',500);\n        map.put('M',1000);\n        int ret = 0;\n        for(int i =0;i<s.length();i++){\n            char c = s.charAt(i);\n            if (i<1){\n                ret +=map.get(c);\n            }else{\n                int current = map.get(c);\n                int previous = map.get(s.charAt(i-1));\n                ret += current;\n                if (current > previous){\n                    ret -=2*previous;\n                }\n            }\n        }\n        return ret;\n    }\n}\n```\n\n耗时：8ms\n\n## 字符串数组最长公共前缀\n\n- 暴力解法\n\n取字符串数组第一个作为src\n分别求得src的所有前缀\n判断数组其他项是否都有这个前缀，如果没有，最长前缀及当前src的前缀\n\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if (strs.length == 0) {\n            return \"\";\n        }\n        String prefix = \"\";\n        String src = strs[0];\n        for (int i =0;i<=src.length();i++){\n            String tmpPrefix = src.substring(0,i);\n            boolean f = false;\n            for (String s : strs){\n                if (!s.startsWith(tmpPrefix)){\n                    f = true;\n                    break;\n                }\n            }\n            if (!f) {\n                prefix = tmpPrefix;\n            }else {\n                // flag为true，代表当前tmpPrefix是最长前缀，跳出循环，避免没有意义的循环\n                break;\n            }\n        }\n        return prefix;\n    }\n}\n```\n\n耗时：4ms\n\n## 括号匹配问题\n\n输入\"()\" -> true \"[)\" -> false\n\n- 使用栈\n\n左括号是入栈，右括号出栈\n如果发现出栈的与入栈不匹配，则不匹配\n或者发现输入右括号时，栈为空，也是不匹配\n字符串扫描完成时，栈为空，表明匹配\n\n```java\nclass Solution {\n    public boolean isValid(String s) {\n        LinkedList<Character> stack = new LinkedList<>();\n        Map<Character,Character> map = new HashMap<>();\n        map.put('{','}');\n        map.put('[',']');\n        map.put('(',')');\n        for (int i=0;i<s.length();i++){\n            char c = s.charAt(i);\n            if (c == '{' || c == '(' || c == '[') {\n                stack.push(c);\n            }else {\n                if (stack.size() == 0) {\n                    return false;\n                }\n                if (c !=map.get(stack.pop())){\n                    return false;\n                }\n            }\n        }\n        return stack.size() == 0;\n    }\n}\n```\n\n耗时：2ms\n\n## 合并两个有序链表\n\n输入：1->2->4, 1->3->4\n输出：1->1->2->3->4->4\n\n- 解法\n\n当两个指针都不为空时，则判断哪个指针的值比较小，\n将较小的值存入结果，结果的指针与比较小的指针后移\n\n如果只有一个指针不为空，则不断对该指针存入结果，并且将结果与该指针后移\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null && l2 == null) {\n            return null;\n        }\n        ListNode node = new ListNode();\n        ListNode ret = node;\n        while(l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                node.val = l1.val;\n                l1 = l1.next;\n            }else {\n                node.val = l2.val;\n                l2 = l2.next;\n            }\n            node.next = new ListNode();\n            node = node.next;\n        }\n        ListNode tl = null;\n        if (l1 == null) {\n           tl = l2;\n        } else if (l2 == null) {\n            tl = l1;\n        }\n        while (tl != null) {\n            node.val = tl.val;\n            tl = tl.next;\n            if (tl != null) {\n                node.next = new ListNode();\n                node = node.next;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n耗时：1ms\n\n## 删除排序数组中的重复项\n\n给定数组 nums = [1,1,2], \n\n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n\n- 解法1\n\n从左向右扫描数组\n如果发现被扫描元素等于左边元素\n则将该元素往后的所有元素往前移动一位\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int length = nums.length;\n        for (int i=1;i<length;i++){\n            \n            if (nums[i-1] == nums[i]){\n                for(int j=i;j<length;j++){\n                    nums[j-1]=nums[j];\n                }\n                i--;\n                length--;\n            }\n        }\n        return length;\n    }\n}\n```\n\n耗时：86ms\n\n- 解法2\n\n双指针解法\n定义一个指针i，默认指向0\n从1-n扫描数组，如果发现右边不等于左边\n则i++，然后让数组i的位置内容替换为扫描位置的内容\n\n由于i代表的是下标，所以最后需要i+1转为长度\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length == 0) return 0;\n        int i = 0;\n        for (int j = 1; j < nums.length; j++) {\n            if (nums[j] != nums[i]) {\n                i++;\n                nums[i] = nums[j];\n            }\n        }\n        return i + 1;\n    }\n}\n```\n\n耗时：1ms\n\n## 移除元素\n\n给定 nums = [3,2,2,3], val = 3,\n\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n\n你不需要考虑数组中超出新长度后面的元素\n\n- 解法1\n\n这道题跟上一道题很像，同样可以扫描元素，等于val时就将后面的元素全部向前移动一位\n\n耗时：5ms\n\n- 解法2\n\n维护一个指针i=0\n从左向右扫描元素，如果发现扫描的值不等于要被移除的值\n则将扫描的值转移到数组i的位置，然后i向后移动一位\n\n```java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int i = 0;\n        for (int j=0; j < nums.length; j++) {\n            if (nums[j] != val) {\n                nums[i]=nums[j];\n                i++;\n            }\n        }\n        return i;\n    }\n}\n```\n\n耗时：0ms\n\n## IP地址无效化\n\n给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。\n所谓无效化 IP 地址，其实就是用 \"[.]\" 代替了每个 \".\"。\n\n- 解法\n\n从左至右扫描字符，遇到“.”就改为\"[.]\"否则原样输出\n\n为了效率，这里使用了StringBuffer\n\n```java\nclass Solution {\n    public String defangIPaddr(String address) {\n        StringBuffer sb = new StringBuffer();\n        for(int i =0;i<address.length();i++){\n            char c = address.charAt(i);\n            if (c != '.'){\n                sb.append(c);\n            }else{\n                sb.append(\"[.]\");\n            }\n        }\n        return sb.toString();\n    }\n}\n```\n\n## 合并两个有序数组\n\n输入:\nnums1 = [1,2,3,0,0,0], m = 3\nnums2 = [2,5,6],       n = 3\n\n输出: [1,2,2,3,5,6]\n\n```java\n\n```\n\n跟合并两个有序链表类似\n\n```java\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        LinkedList<Integer> list1 = new LinkedList<>();\n        for (int i=0;i<m;i++) {\n            list1.add(nums1[i]);\n        }\n        LinkedList<Integer> list2 = new LinkedList<>();\n        for (int i=0;i<n;i++) {\n            list2.add(nums2[i]);\n        }\n        int index = 0;\n        while (!list1.isEmpty() && !list2.isEmpty()){\n            int i = list1.peek();\n            int j = list2.peek();\n            if (i<j){\n                nums1[index++] = i;\n                list1.remove();\n            }else {\n                nums1[index++] = j;\n                list2.remove();\n            }\n        }\n        LinkedList<Integer> list;\n        if (list1.isEmpty()){\n            list=list2;\n        }else {\n            list = list1;\n        }\n        while(!list.isEmpty()){\n            nums1[index++]=list.remove();\n        }\n    }\n}\n```\n\n耗时：2ms\n\n## 最后一个单词的长度\n\n<https://leetcode-cn.com/problems/length-of-last-word/>\n\n输入: \"Hello World\"\n输出: 5\n\n- 解法\n\n从后往前扫描文本\n发现字符为非空格，长度+1\n发现字符是空格，并且长度不等于0，则已经查找到最后一个单词的长度\n\n```java\nclass Solution {\n    public int lengthOfLastWord(String s) {\n        int length =0;\n        for (int i=s.length()-1;i>=0;i--){\n            if (s.charAt(i) == ' ' && length != 0) {\n                break;\n            }else if (s.charAt(i) != ' '){\n                length ++;\n            }\n        }\n        return length;\n    }\n}\n```\n\n耗时：0ms\n\n## 删除排序链表中的重复元素\n\n<https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/>\n\n给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次\n\n- 解法\n\n遍历链表，如果发现当前节点等于后继节点，则将当前节点的后继修改为后继节点的后继\n当当前节点或者后继节点为null，停止遍历\n\n```java\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode origin = head;\n        while(head != null && head.next != null) {\n            if (head.val == head.next.val) {\n                head.next = head.next.next;\n                continue;\n            }\n            head = head.next;\n        }\n        return origin;\n    }\n}\n```\n\n耗时：0ms\n\n## 求1+2+…+n\n\n求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\n\n<https://leetcode-cn.com/problems/qiu-12n-lcof/>\n\n- 解法\n\n等差数列求和公式\n\n```java\nreturn (n+1)*n/2;\n```\n\n## 验证回文串\n\n给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写\n\n<https://leetcode-cn.com/problems/valid-palindrome/>\n\n- 解法\n\n类似于前面的验证回文数字，分别正序与逆序将字符串入栈，比较两个栈\n\n```java\nclass Solution {\n    public boolean isPalindrome(String s) {\n        s = s.toLowerCase();\n        LinkedList<Character> stack1 = new LinkedList<>();\n        LinkedList<Character> stack2 = new LinkedList<>();\n        for (int i=s.length()-1;i>=0;i--){\n            char c =s.charAt(i);\n            if ((c >=48 && c <=57) || (c >=97 && c <=122)){\n                stack1.addLast(c);\n                stack2.addFirst(c);\n            }\n        }\n        return stack1.equals(stack2);\n    }\n}\n```\n\n## 环形链表\n\n给定一个链表，判断链表中是否有环。\n\n<https://leetcode-cn.com/problems/linked-list-cycle/>\n\n- 解法\n\n使用map存储遍历过的node\n对List进行遍历，发现存在过的node即存在环\n\n```java\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        Map<ListNode,Boolean> map = new HashMap();\n        while(head != null){\n            if (map.containsKey(head)){\n                return true;\n            }\n            map.put(head,true);\n            head = head.next;\n        }\n        return false;\n    }\n}\n```\n\n耗时：5ms\n\n## 一维数组的动态和\n\n输入：nums = [1,2,3,4]\n输出：[1,3,6,10]\n解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。\n\n<https://leetcode-cn.com/problems/running-sum-of-1d-array/>\n\n- 解法\n\n求出nums的和，设置ret的最后一个元素为sum\n\n遍历ret数组倒数第二个至第一个，ret元素内容为后一个下标元素-nums对应的数\n\n```java\nclass Solution {\n    public int[] runningSum(int[] nums) {\n        if (nums.length == 0) {\n            return new int[]{};\n        }\n        int[] ret = new int[nums.length];\n        int sum = 0;\n        for (int i:nums){\n            sum+=i;\n        }\n        ret[ret.length-1]=sum;\n        for(int i=nums.length-2;i>=0;i--){\n            ret[i] = ret[i+1]-nums[i+1];\n        }\n        return ret;\n    }\n}\n```\n\n## 斐波那契数\n\n给定 N，计算 F(N)。\n\n<https://leetcode-cn.com/problems/fibonacci-number/submissions/>\n\n- 解法1\n\n递归\n\n```java\nclass Solution {\n    public int fib(int N) {\n        if (N == 0 || N == 1) {\n            return N;\n        }\n        return fib(N-1) + fib(N-2);\n    }\n}\n```\n\n耗时:9ms\n\n- 解法2\n\n使用缓存避免重复的计算\n\n```java\nclass Solution {\n    private int[] cache = new int[100];\n    public int fib(int N) {\n        return fib0(N);\n    }\n    private int fib0(int N){\n        if (N == 0 || N == 1) {\n            return N;\n        }\n        if (cache[N] == 0){\n            cache[N] = fib1(N);\n        }\n        return cache[N];\n    }\n     private int fib1(int N){\n        if (N == 0 || N == 1) {\n            return N;\n        }\n        return fib0(N-1) + fib0(N-2);\n    }\n}\n```\n\n耗时:0ms\n\n## 反转字符串\n\n<https://leetcode-cn.com/problems/reverse-string/>\n\n使用前后双指针 两个指针往中间靠 交换元素\n\n```java\nclass Solution {\n    public void reverseString(char[] s) {\n        if (s.length <=1) return;\n        int l=0,r=s.length-1;\n        while(l<r){\n            char tmp = s[l];\n            s[l]=s[r];\n            s[r]=tmp;\n            l++;r--;\n        }\n    }\n}\n```\n\n## 只出现一次的数字\n\n<https://leetcode-cn.com/problems/single-number/>\n\n使用异或去除相同数字\n\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int base = nums[0];\n        for(int i=1;i<nums.length;i++){\n            base = base^nums[i];\n        }\n        return base;\n    }\n}\n```\n\n耗时:1ms\n\n## 完全平方数\n\n<https://leetcode-cn.com/problems/valid-perfect-square/submissions/>\n\n- 从1扫描到num/2+1 每次递增1\n\n```java\nclass Solution {\n    public boolean isPerfectSquare(int num) {\n        int N = num/2+1;\n        for (int i=1;i<=N;i++){\n            if (i*i == num){\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n耗时:1449ms\n\n## 两数之和\n\n<https://leetcode-cn.com/problems/sum-of-two-integers/submissions/>\n\n```java\nclass Solution {\n    public int getSum(int a, int b) {\n        if (b >0){\n            while(b>0){\n                a++;\n                b--;\n            }\n        }else if (b<0){\n            while(b<0){\n                a--;\n                b++;\n            }\n        }\n        return a;\n    }\n}\n```\n\n耗时:946\n\n## 猜数字大小\n\n<https://leetcode-cn.com/problems/guess-number-higher-or-lower/submissions/>\n\n```java\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int low = 1;\n        int high = n;\n        while(low <= high){\n            int mid = low+(high-low)/2;\n            int ret = guess(mid);\n            if (ret == 0){\n                return mid;\n            }else if (ret == 1){\n                low = mid+1;\n            }else {\n                high = mid-1;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n## 多数元素\n\n<https://leetcode-cn.com/problems/majority-element/submissions/>\n\n- 解法1：使用哈希表存储每个数字出现的频率\n\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        int n = nums.length/2;\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i :nums){\n            if (map.containsKey(i)){\n                map.put(i,map.get(i)+1);\n            }else{\n                map.put(i,1);\n            }\n        }\n        for(int i:map.keySet()){\n            if (map.get(i)>n){\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n耗时：16ms\n\n- 解法2：摩尔投票法？\n\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        if (nums.length == 0) return 0;\n        int cnt = 0, last = nums[0];\n        for(int i : nums){\n            if (i == last) cnt++;\n            else cnt--;\n            if (cnt < 0) {\n                last = i;\n                cnt = 0;\n            }\n        }\n        return last;\n    }\n}\n```\n\n## 路径总和\n\n<https://leetcode-cn.com/problems/path-sum/submissions/>\n\n```java\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int sum) {\n        if (root == null){\n            return false;\n        }\n        if (root.left == null && root.right == null){\n            return root.val == sum;\n        }else if(root.left == null){\n            return hasPathSum(root.right,sum-root.val);\n        }else if(root.right == null){\n            return hasPathSum(root.left,sum-root.val);\n        }else {\n            return hasPathSum(root.right,sum-root.val) || \n                    hasPathSum(root.left,sum-root.val);\n        }\n    }\n}\n```\n\n耗时:0\n\n## 魔术索引\n\n<https://leetcode-cn.com/problems/magic-index-lcci/submissions/>\n\n```java\nclass Solution {\n    public int findMagicIndex(int[] nums) {\n        for(int i=0;i<nums.length;i++){\n            if (nums[i] == i){\n                return nums[i];\n            }\n        }\n        return -1;\n    }\n}\n```\n\n耗时:1\n\n## 左叶子之和\n\n<https://leetcode-cn.com/problems/sum-of-left-leaves/submissions/>\n\n```java\nclass Solution {\n    public int sumOfLeftLeaves(TreeNode root) {\n        return sum(root,false);\n    }\n    public int sum(TreeNode root,boolean isLeft){\n        if (root == null){\n            return 0;\n        }\n        if (root.left == null && root.right == null){\n            if (isLeft){\n                return root.val;\n            }else {\n                return 0;\n            }\n        }\n        return sum(root.left,true)+sum(root.right,false);\n    }\n}\n```\n\n耗时:0\n\n## 汉明距离\n\n<https://leetcode-cn.com/problems/hamming-distance/submissions/>\n\n```java\nclass Solution {\n    public int hammingDistance(int x, int y) {\n        // 异或：相同为0 不同为1\n        int z = x^y;\n        int ret = 0;\n        // 计算二进制有多少1\n        while(z!=0){\n            int t = z%2;\n            z/=2;\n            if (t == 1){\n                ret++;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n耗时：0\n\n## 从尾到头打印链表\n\n<https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof>\n\n```java\nclass Solution {\n    public int[] reversePrint(ListNode head) {\n        List<Integer> list = new ArrayList<>();\n        walk(head,list);\n        int [] ret = new int[list.size()];\n        for (int i=0;i<ret.length;i++){\n            ret[i]=list.get(i);\n        }\n        return ret;\n    }\n    private void walk(ListNode head,List<Integer> list){\n        if (head == null){\n            return;\n        }\n        walk(head.next,list);\n        list.add(head.val);\n    }\n}\n```\n\n耗时：1\n\n## Excel 表列序号\n\n<https://leetcode-cn.com/problems/excel-sheet-column-number/submissions/>\n\n```java\nclass Solution {\n    public int titleToNumber(String s) {\n        int ret = 0;\n        int N = s.length();\n        for(int i=0;i<N;i++){\n            char c = s.charAt(i);\n            int val = c-64;\n            double t =Math.pow(26,N-i-1);\n            ret+=val*t;\n        }\n        return ret;\n    }\n}\n```\n\n耗时：2\n\n## 移动零\n\n<https://leetcode-cn.com/problems/move-zeroes/submissions/>\n\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int numOf0 = 0;\n        int passOf0 =0;\n        for(int i=0;i<nums.length;i++){\n            if (nums[i] == 0) numOf0++;\n        }\n        for(int i=0;i<nums.length;i++){\n            if (nums[i]==0){\n                passOf0++;\n            }else{\n                // 如果当前数不为0并且已经过的0个数不为0\n                if (passOf0 != 0){\n                    // 当前数向左移动passOf0\n                    nums[i-passOf0] = nums[i];\n                }\n            }\n        }\n        for(int i=nums.length-1;i>=nums.length-numOf0;i--){\n            nums[i]=0;\n        }\n    }\n}\n```\n\n耗时：0\n\n## 剑指 Offer 22. 链表中倒数第k个节点\n\n<https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/>\n\n递归到尾不断对计数器+1 判断计数器等于目标值 就返回当前遍历节点\n\n```java\nclass Solution {\n\n    private ListNode ret;\n\n    public ListNode getKthFromEnd(ListNode head, int k) {\n        getKthFromEnd0(head,k,new int[]{0});\n        return ret;\n    }\n    private void getKthFromEnd0(ListNode head, int k,int[] arr) {\n        if (head == null){\n            return;\n        }\n        getKthFromEnd0(head.next,k,arr);\n        arr[0]=arr[0]+1;\n        if (arr[0] == k){\n            ret = head;\n        }\n    }\n}\n```\n\n耗时：0\n\n## LCP 06. 拿硬币\n\n<https://leetcode-cn.com/problems/na-ying-bi/>\n\n```java\nclass Solution {\n    public int minCount(int[] coins) {\n        int count = 0;\n        for (int i:coins){\n            count+=i/2;\n            if (i % 2!= 0){\n                count+=1;\n            }\n        }\n        return count;\n    }\n}\n```\n\n耗时:0\n\n## 剑指 Offer 50. 第一个只出现一次的字符\n\n<https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/>\n\n```java\nclass Solution {\n    public char firstUniqChar(String s) {\n        int[] map = new int[128];\n        for(char c : s.toCharArray()){\n            map[c] = map[c] + 1;\n        }\n        for(int i=0;i<s.length();i++){\n            char c = s.charAt(i);\n            if (map[c] == 1){\n                return c;\n            }\n        }\n        return ' ';\n    }\n}\n```\n\n耗时：6\n\n## 1486. 数组异或操作\n\n<https://leetcode-cn.com/problems/xor-operation-in-an-array/>\n\n```java\nclass Solution {\n    public int xorOperation(int n, int start) {\n        int ret=start;\n        for(int i=1;i<n;i++){\n            ret=ret^(start+2*i);\n        }\n        return ret;\n    }\n}\n```\n\n耗时：0\n\n## 剑指 Offer 58 - II. 左旋转字符串\n\n<https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/submissions/>\n\n```java\nclass Solution {\n    public String reverseLeftWords(String s, int n) {\n        StringBuffer sb = new StringBuffer();\n        for(int i = n;i<s.length();i++){\n            sb.append(s.charAt(i));\n        }\n        for(int i=0;i<n;i++){\n            sb.append(s.charAt(i));\n        }\n        return sb.toString();\n    }\n}\n```\n\n耗时：5\n\n## 剑指 Offer 53 - II. 0～n-1中缺失的数字\n\n<https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/submissions/>\n\n```java\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int ret = nums[nums.length-1];\n        for(int i=0;i<ret;i++){\n            if (nums[i] != i) return i;\n        }\n        return ret+1;\n    }\n}\n```\n\n耗时：0\n\n## 剑指 Offer 05. 替换空格\n\n<https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/>\n\n```java\nclass Solution {\n    public String replaceSpace(String s) {\n        StringBuffer sb = new StringBuffer();\n        for(int i=0;i<s.length();i++){\n            char c = s.charAt(i);\n            if (c == ' '){\n                sb.append(\"%20\");\n            }else{\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}\n```\n\n耗时：0\n\n## 剑指 Offer 03. 数组中重复的数字\n\n<https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/>\n\n```java\nclass Solution {\n    public int findRepeatNumber(int[] nums) {\n        int[] map = new int[nums.length];\n        for(int i:nums){\n            map[i] = map[i] + 1;\n        }\n        for(int i=0;i<map.length;i++){\n            if (map[i]>1){\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n耗时：1\n\n## 剑指 Offer 17. 打印从1到最大的n位数\n\n<https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/>\n\n```java\nclass Solution {\n    public int[] printNumbers(int n) {\n        if (n == 0) return new int[]{};\n        int[] ret = new int[(int)Math.pow(10,n)-1];\n        for(int i=0;i<ret.length;i++){\n            ret[i]=i+1;\n        }\n        return ret;\n    }\n}\n```\n\n耗时：1\n\n## 有效的字母异位词\n\n<https://leetcode-cn.com/problems/valid-anagram/>\n\n```java\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        int[] map1 = new int[128];\n        int[] map2 = new int[128];\n        for(int i=0;i<s.length();i++){\n            char c = s.charAt(i);\n            map1[c] = map1[c] + 1;\n        }\n        for(int i=0;i<t.length();i++){\n            char c = t.charAt(i);\n            map2[c] = map2[c] + 1;\n        }\n        for(int i=0;i<map1.length;i++){\n            if (map1[i] != map2[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n耗时：4\n\n## 反转链表\n\n<https://leetcode-cn.com/problems/reverse-linked-list/>\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null) return null;\n        LinkedList<Integer> stack = new LinkedList<>();\n        while(head != null){\n            stack.push(head.val);\n            head = head.next;\n        }\n        ListNode root = new ListNode();\n        ListNode origin = root;\n        while(!stack.isEmpty()){\n            root.val = stack.pop();\n            if (!stack.isEmpty()){\n                root.next = new ListNode();\n                root = root.next;\n            }\n        }\n        return origin;\n    }\n}\n```\n\n耗时：0\n\n## 389. 找不同\n\n<https://leetcode-cn.com/problems/find-the-difference/>\n\n```java\nclass Solution {\n    public char findTheDifference(String s, String t) {\n        int[] map = new int[128];\n\n        for(int i =0;i<t.length();i++){\n            char c = t.charAt(i);\n            map[c] = map[c] + 1;\n        }\n        for(int i=0;i<s.length();i++){\n            char c = s.charAt(i);\n            map[c] = map[c] - 1;\n        }\n        for(int i=0;i<map.length;i++){\n            if (map[i] != 0) return (char)i;\n        }\n        return (char)-1;\n    }\n}\n```\n\n耗时：4\n\n## 412. Fizz Buzz\n\n<https://leetcode-cn.com/problems/fizz-buzz/>\n\n```java\nclass Solution {\n    public List<String> fizzBuzz(int n) {\n        List<String> list = new ArrayList<>();\n        for(int i=1;i<=n;i++){\n            if (i % 15 == 0){\n                list.add(\"FizzBuzz\");\n            }else if(i % 3 == 0){\n                list.add(\"Fizz\");\n            }else if(i % 5 == 0) {\n                list.add(\"Buzz\");\n            }else{\n                list.add(i + \"\");\n            }\n        }\n        return list;\n    }\n}\n```\n\n耗时：6\n\n## 173. 二叉搜索树迭代器\n\n<https://leetcode-cn.com/problems/binary-search-tree-iterator/>\n\n```java\nclass BSTIterator {\n    private LinkedList<Integer> list = new LinkedList<>();\n    public BSTIterator(TreeNode root) {\n        midVisist(root);\n    }\n\n    private void midVisist(TreeNode root){\n        if (root == null) return;\n        midVisist(root.left);\n        list.add(root.val);\n        midVisist(root.right);\n    }\n    \n    /** @return the next smallest number */\n    public int next() {\n        return list.removeFirst();\n    }\n    \n    /** @return whether we have a next smallest number */\n    public boolean hasNext() {\n        return !list.isEmpty();\n    }\n}\n```\n\n耗时：24\n\n## 290. 单词规律\n\n<https://leetcode-cn.com/problems/word-pattern/>\n\n```java\nclass Solution {\n    public boolean wordPattern(String pattern, String s) {\n        Map<Character,String> map1 = new HashMap<>();\n        Map<String,Character> map2 = new HashMap<>();\n        String[] strs = s.split(\" \");\n        if (strs.length != pattern.length()) return false;\n\n        for(int i = 0;i<pattern.length();i++){\n            char c = pattern.charAt(i);\n\n            if (!map1.containsKey(c)) {\n                map1.put(c, strs[i]);\n            }\n            if (!map2.containsKey(strs[i])) {\n                map2.put(strs[i],pattern.charAt(i));\n            }\n        }\n        for(int i = 0;i<pattern.length();i++){\n            String s1 = map1.get(pattern.charAt(i));\n            Character c = map2.get(s1);\n            if (!s1.equals(strs[i])) return false;\n            if (c == null) return false;\n            if (c.charValue() != pattern.charAt(i)) return false;\n        }\n        return true;\n    }\n}\n```\n\n耗时：1\n\n## 709. 转换成小写字母\n\n<https://leetcode-cn.com/problems/to-lower-case/>\n\n```java\nclass Solution {\n    public String toLowerCase(String str) {\n        StringBuffer sb = new StringBuffer();\n        for(int i =0;i<str.length();i++){\n            char c = str.charAt(i);\n            if (c >= 65 && c <=90) c = (char)(c+32);\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n}\n```\n\n耗时：0\n\n## 66. 加一\n\n<https://leetcode-cn.com/problems/plus-one/>\n\n```java\nclass Solution {\n    public int[] plusOne(int[] digits) {\n        int[] ret = new int[digits.length+1];\n        for(int i=0;i<digits.length;i++){\n            ret[i+1] = digits[i];\n        }\n        ret[ret.length-1] = ret[ret.length-1] + 1;\n        boolean f = false;\n        for(int i=ret.length-1;i>=0;i--){\n            if (ret[i] == 10) {\n                ret[i] = 0;\n                f = true;\n                continue;\n            }\n            if (f) {\n                if (ret[i] == 9) {\n                    ret[i] = 0;\n                    f = true;\n                }else {\n                    ret[i]++;\n                    f= false;\n                }\n            }\n        }\n        if (ret[0] == 0) {\n            int[] trimArr = new int[ret.length-1];\n            System.arraycopy(ret,1,trimArr,0,trimArr.length);\n            return trimArr;\n        }\n        return ret;\n    }\n}\n```\n\n耗时：0\n\n## 349. 两个数组的交集\n\n<https://leetcode-cn.com/problems/intersection-of-two-arrays/>\n\n```java\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        HashSet<Integer> s1 = new HashSet<>();\n        HashSet<Integer> s2 = new HashSet<>();\n        for(int i : nums1) {\n            s1.add(i);\n        }\n        for(int i : nums2) {\n            s2.add(i);\n        }\n        if (s1.size() < s2.size()) {\n            var t = s1;\n            s1 = s2;\n            s2 = t;\n        }\n\n        Iterator<Integer> it = s1.iterator();\n        while(it.hasNext()){\n            var e = it.next();\n            if (!s2.contains(e)) it.remove();\n        }\n\n        int[] ret = new int[s1.size()];\n        int count = 0;\n        for(int i :s1){\n            ret[count] = i;\n            count++;\n        }\n        return ret;\n    }\n}\n```\n\n耗时：3\n\n## 557. 反转字符串中的单词 III\n\n<https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/>\n\n```java\nclass Solution {\n    public String reverseWords(String s) {\n        if (s.length() == 0) return \"\";\n        StringBuffer sb = new StringBuffer();\n        for(int i =s.length()-1;i>=0;i--){\n            sb.append(s.charAt(i));\n        }\n        String[] strs = sb.toString().split(\" \");\n        sb = new StringBuffer();\n        for(int i = strs.length-1;i>=0;i--){\n            sb.append(strs[i]);\n            if (i != 0) sb.append(\" \");\n        }\n        return sb.toString();\n    }\n}\n```\n\n耗时：10\n\n## 811. 子域名访问计数\n\n<https://leetcode-cn.com/problems/subdomain-visit-count/>\n\n```java\nclass Solution {\n    public List<String> subdomainVisits(String[] cpdomains) {\n        Map<String,Integer> map = new HashMap<>(256);\n        for (String s : cpdomains){\n            String[] a = s.split(\" \");\n            int count = Integer.valueOf(a[0]);\n            String domain = a[1];\n            for(int i=domain.length()-1;i>=0;i--){\n                char c = domain.charAt(i);\n                if (c == '.') {\n                    String subDomain = domain.substring(i+1,domain.length());\n                    Integer oldCount = map.get(subDomain);\n                    if (oldCount == null){\n                        map.put(subDomain, count);\n                    }else {\n                        map.put(subDomain, oldCount + count);\n                    }\n                }\n                if (i == 0){\n                    Integer oldCount = map.get(domain);\n                    if (oldCount == null){\n                        map.put(domain, count);\n                    }else {\n                        map.put(domain, oldCount + count);\n                    }\n                }\n            }\n        }\n        List<String> ret = new ArrayList<>();\n        for (String s: map.keySet()){\n            ret.add(map.get(s) + \" \" + s);\n        }\n        return ret;\n    }\n}\n```\n\n耗时：21\n\n## 876. 链表的中间结点\n\n<https://leetcode-cn.com/problems/middle-of-the-linked-list/>\n\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode[] map = new ListNode[101];\n        int i = 1;\n        while(head != null){\n            map[i]=head;\n            i++;\n            head = head.next;\n        }\n        if (i % 2 !=0) return map[i/2+1];\n        else return map[i/2];\n    }\n}\n```\n\n耗时：0\n\n## 118. 杨辉三角\n\n<https://leetcode-cn.com/problems/pascals-triangle/>\n\n```java\nclass Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> list = new ArrayList<>();\n        for(int i=0;i<numRows;i++){\n            List<Integer> seq = new ArrayList<>();\n            for(int j = 0;j<=i;j++){\n                if (j == 0 || j == i) {\n                    seq.add(1);\n                    continue;\n                }\n                seq.add(list.get(i-1).get(j-1) + list.get(i-1).get(j));\n            }\n            list.add(seq);\n        }\n        return list;\n    }\n}\n```\n\n耗时：1\n\n## 231. 2的幂\n\n<https://leetcode-cn.com/problems/power-of-two/>\n\n```java\nclass Solution {\n    public boolean isPowerOfTwo(int n) {\n        int k = 1;\n        while (true){\n            if (n == k) return true;\n            if (k > n) return false;\n            if (k < 0) break;\n            k <<= 1;\n        }\n        return false;\n    }\n}\n```\n\n耗时：1\n\n## 844. 比较含退格的字符串\n\n<https://leetcode-cn.com/problems/backspace-string-compare/>\n\n```java\nclass Solution {\n    public boolean backspaceCompare(String S, String T) {\n        LinkedList<Character> s1 = new LinkedList<>();\n        LinkedList<Character> s2 = new LinkedList<>();\n        for(int i = 0;i<S.length();i++){\n            char c = S.charAt(i);\n            if (c == '#' && !s1.isEmpty()) s1.pop();\n            else if(c != '#') s1.push(c);\n        }\n        for(int i = 0;i<T.length();i++){\n            char c = T.charAt(i);\n            if (c == '#' && !s2.isEmpty()) s2.pop();\n            else if(c != '#') s2.push(c);\n        }\n        if (s1.size() != s2.size()) return false;\n        while(!s1.isEmpty() && !s2.isEmpty()){\n            if (s1.pop() != s2.pop()) return false;\n        }\n        return true;\n    }\n}\n```\n\n耗时：2\n\n## 747. 至少是其他数字两倍的最大数\n\n<https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/>\n\n```java\nclass Solution {\n    public int dominantIndex(int[] nums) {\n        int maxIndex = 0;\n        for(int i = 0;i<nums.length;i++){\n            if (nums[i] > nums[maxIndex]) maxIndex = i;\n        }\n        for(int i = 0;i<nums.length;i++){\n            if (nums[i] * 2 > nums[maxIndex] && i != maxIndex) return -1;\n        }\n        return maxIndex;\n    }\n}\n```\n\n耗时：0\n\n## 234. 回文链表\n\n<https://leetcode-cn.com/problems/palindrome-linked-list/>\n\n```java\nclass Solution {\n    private ListNode origin;\n    public boolean isPalindrome(ListNode head) {\n        origin = head;\n        return travel(head);\n    }\n    private boolean travel(ListNode head){\n        if (head == null) return true;\n        if (!travel(head.next)){\n            return false;\n        }\n        if (head.val == origin.val){\n            origin = origin.next;\n            return true;\n        }else {\n            return false;\n        }\n    }\n}\n```\n\n耗时：2\n\n## 938. 二叉搜索树的范围和\n\n<https://leetcode-cn.com/problems/range-sum-of-bst/>\n\n```java\nclass Solution {\n    public int rangeSumBST(TreeNode root, int L, int R) {\n        int[] sum = new int[]{0};\n        midTravel(root,sum,L,R);\n        return sum[0];\n    }\n    private void midTravel(TreeNode root,int[] sum,int l,int r){\n        if (root == null) return;\n        midTravel(root.left, sum,l,r);\n        if (root.val >=l && root.val <=r ) sum[0] += root.val;\n        midTravel(root.right, sum,l,r);\n    }\n}\n```\n\n耗时：1\n\n## 929. 独特的电子邮件地址\n\n<https://leetcode-cn.com/problems/unique-email-addresses/>\n\n```java\nclass Solution {\n    public int numUniqueEmails(String[] emails) {\n        List<String> list = new ArrayList<>();\n        for(String s: emails){\n            String[] a = s.split(\"@\");\n            String name = a[0];\n            String domain = a[1];\n            StringBuilder sb = new StringBuilder();\n            for(int i = 0;i<name.length();i++){\n                char c = name.charAt(i);\n                if (c == '+') break;\n                if (c != '.') sb.append(c);\n            }\n            sb.append(\"@\");\n            sb.append(domain);\n            if (!list.contains(sb.toString())){\n                list.add(sb.toString());\n            }\n        }\n        return list.size();\n    }\n}\n```\n\n耗时：12\n\n## 744. 寻找比目标字母大的最小字母\n\n<https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/>\n\n```java\nclass Solution {\n    public char nextGreatestLetter(char[] letters, char target) {\n        for(int i = 0;i<letters.length;i++){\n            if (letters[i] > target) return letters[i];\n        }\n        return letters[0];\n    }\n}\n```\n\n耗时：0\n\n## 191. 位1的个数\n\n<https://leetcode-cn.com/problems/number-of-1-bits/>\n\n```c\nint hammingWeight(uint32_t n) {\n    int count = 0;\n    while(n != 0){\n        if (n % 2 != 0) count++;\n        n >>= 1;\n    }\n    return count;\n}\n```\n\n耗时：4\n\n## 706. 设计哈希映射\n\n<https://leetcode-cn.com/problems/design-hashmap/>\n\n```java\nclass MyHashMap {\n    private static final int SIZE = 1000001;\n    private Integer[] data = new Integer[SIZE];\n    \n    public void put(int key, int value) {\n        data[key % SIZE] = value;\n    }\n    \n    public int get(int key) {\n        Integer i = data[key % SIZE];\n        if (i == null) return -1;\n        return i;\n    }\n    \n    public void remove(int key) {\n        data[key % SIZE] = null;\n    }\n}\n```\n\n耗时：30\n\n## 225. 用队列实现栈\n\n<https://leetcode-cn.com/problems/implement-stack-using-queues/>\n\n```java\nclass MyStack {\n\n    private LinkedList<Integer> q1 = new LinkedList<>();\n    private LinkedList<Integer> q2 = new LinkedList<>();\n    private int next = 0;\n    \n    public void push(int x) {\n        q1.add(x);\n        next = x;\n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    public int pop() {\n        int size = q1.size();\n        int oldNext = next;\n        for(int i = 0;i<size;i++){\n            int x = q1.remove();\n            if (i == size - 2) next = x;\n            if (i != size - 1) q2.add(x);\n        }\n        var t = q1;\n        q1 = q2;\n        q2 = t;\n        return oldNext;\n    }\n    \n    public int top() { return next; }\n    \n    public boolean empty() { return q1.isEmpty(); }\n}\n```\n\n耗时：0\n\n## 面试题 01.01. 判定字符是否唯一\n\n<https://leetcode-cn.com/problems/is-unique-lcci/>\n\n- 解法1：暴力解法\n\n```java\nclass Solution {\n    public boolean isUnique(String astr) {\n        int l = astr.length();\n        for(int i = 0;i<l;i++){\n            for(int j =0;j<l;j++){\n                if (j == i) continue;\n                if (astr.charAt(i)  == astr.charAt(j)) return false;\n            }\n        }\n        return true;\n    }\n}\n```\n\n耗时：0\n\n## 面试题 01.02. 判定是否互为字符重排\n\n<https://leetcode-cn.com/problems/check-permutation-lcci/>\n\n```java\nclass Solution {\n    public boolean CheckPermutation(String s1, String s2) {\n        if (s1.length() != s2.length()) return false;\n        int[] map = new int[128];\n        for(int i = 0;i<s1.length();i++) {\n            map[s1.charAt(i)]++;\n            map[s2.charAt(i)]--;\n        }\n        for(int i : map){\n            if (i != 0) return false;\n        }\n        return true;\n```\n\n耗时：0\n\n## 49. 字母异位词分组\n\n<https://leetcode-cn.com/problems/group-anagrams/>\n\n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        HashMap<String,Integer> map = new HashMap<>(128);\n        int i = 0;\n        List<List<String>> list = new ArrayList<>();\n        for(String s : strs) {\n            var arr = s.toCharArray();\n            Arrays.sort(arr);\n            String key = Arrays.toString(arr);\n            if (!map.containsKey(key)){\n                map.put(key, i);\n                i++;\n                list.add(new ArrayList<>());\n                list.get(list.size() -1).add(s);\n            }else{\n                int index = map.get(key);\n                list.get(index).add(s);\n            }\n        }\n        return list;\n    }\n}\n```\n\n耗时：10\n\n## 804. 唯一摩尔斯密码词\n\n<https://leetcode-cn.com/problems/unique-morse-code-words/>\n\n```java\nclass Solution {\n    public int uniqueMorseRepresentations(String[] words) {\n        String[] map = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\n        \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\n        \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\n        Set<String> set = new HashSet<>();\n        for(String s : words){\n            StringBuffer sb = new StringBuffer();\n            for(int i = 0;i<s.length();i++){\n                sb.append(map[s.charAt(i) - 97]);\n            }\n            set.add(sb.toString());\n        }\n        return set.size();\n    }\n}\n```\n\n耗时：2\n\n## 238. 除自身以外数组的乘积\n\n<https://leetcode-cn.com/problems/product-of-array-except-self/submissions/>\n\n```java\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int[] lMap = new int[nums.length];\n        int[] rMap = new int[nums.length];\n        int lAll = 1;\n        int rAll = 1;\n        for(int i = 0;i<nums.length;i++){\n            lMap[i] = lAll;\n            lAll *= nums[i];\n        }\n        for(int i = nums.length - 1;i>=0;i--){\n            rMap[i] = rAll;\n            rAll *= nums[i];\n        }\n        for(int i = 0;i<nums.length;i++){\n            lMap[i] *= rMap[i];\n        }\n        return lMap;\n\n    }\n}\n```\n\n耗时：1\n\n## 34. 在排序数组中查找元素的第一个和最后一个位置\n\n<https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/>\n\n```java\nclass Solution {\n    public int[] searchRange(int[] nums, int target) {\n        int start = -1;\n        int end = -1;\n        for(int i = 0;i<nums.length;i++){\n            if (nums[i] == target) {\n                if (start == -1) {\n                    start = i;   \n                }\n                end = i;\n            }\n        }\n        return new int[]{start, end};\n    }\n}\n```\n\n耗时：1\n\n## 387. 字符串中的第一个唯一字符\n\n<https://leetcode-cn.com/problems/first-unique-character-in-a-string/>\n\n```java\nclass Solution {\n    public int firstUniqChar(String s) {\n        int[] map = new int[128];\n        for(int i = 0;i<s.length();i++){\n            map[s.charAt(i)]++;\n        }\n        for(int i = 0;i<s.length();i++){\n            if (map[s.charAt(i)] == 1) return i;\n        }\n        return -1;\n    }\n}\n```\n\n耗时：7\n\n## 1313. 解压缩编码列表\n\n<https://leetcode-cn.com/problems/decompress-run-length-encoded-list/>\n\n```python\nclass Solution(object):\n    def decompressRLElist(self, nums):\n        ret = []\n        for i in range(len(nums)/2):\n            for j in range(nums[2*i]):\n                ret.append(nums[2*i+1])\n        return ret\n```\n\n耗时：24\n\n## 303. 区域和检索 - 数组不可变\n\n<https://leetcode-cn.com/problems/range-sum-query-immutable/>\n\n```java\nclass NumArray {\n\n    private int[] nums;\n    private int[] cache;\n\n    public NumArray(int[] nums) {\n        this.nums = nums;\n        cache = new int[nums.length];\n        int total = 0;\n        for(int i = 0;i<nums.length;i++){\n            total += nums[i];\n            cache[i] = total;\n        }\n    }\n    \n    public int sumRange(int i, int j) {\n        if (j == 0 && i == 0) return cache[0];\n        if (i == 0) return cache[j];\n        return cache[j] - cache[i-1];\n    }\n}\n```\n\n耗时：10\n\n## 190. 颠倒二进制位\n\n<https://leetcode-cn.com/problems/reverse-bits/>\n\n```java\nuint32_t reverseBits(uint32_t n) {\n    int map[32];\n    int i = 0;\n    uint32_t ret = 0;\n    const uint32_t p = 1;\n    while(n > 0){\n        map[31-i] = n%2;\n        n /= 2;\n        i++;\n    }\n    for(;i<32;i++) map[31-i] = 0;\n\n    for(i=0;i<32;i++){\n        if (map[i] != 0){\n            if (i == 0) ret+=1;\n            else ret += p << i;\n        }\n    }\n    return ret;\n}\n```\n\n耗时：0\n\n## 771. 宝石与石头\n\n<https://leetcode-cn.com/problems/jewels-and-stones/submissions/>\n\n```java\nclass Solution {\n    public int numJewelsInStones(String J, String S) {\n        int[] map = new int[128];\n        int ret = 0;\n        for(int i = 0;i<J.length();i++){\n            map[J.charAt(i)] = 1;\n        }\n        for(int i = 0;i<S.length();i++){\n            if (map[S.charAt(i)] == 1) ret++;\n        }\n        return ret;\n    }\n}\n```\n\n耗时：1\n\n## 917. 仅仅反转字母\n\n<https://leetcode-cn.com/problems/reverse-only-letters/>\n\n```java\nclass Solution {\n    public String reverseOnlyLetters(String S) {\n        char[] strs = new char[S.length()];\n        int p = 0;\n        for(int i=0;i<S.length();i++){\n            char c = S.charAt(i);\n            if ((c >= 97 && c <=122) || (c >= 65 && c <= 90)) {\n                strs[p++] = c;\n            }\n        }\n        StringBuilder sb = new StringBuilder(S.length());\n        for(int i=0;i<S.length();i++){\n            char c = S.charAt(i);\n            if ((c >= 97 && c <=122) || (c >= 65 && c <= 90)) {\n                sb.append(strs[--p]);\n            }else{\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}\n```\n\n耗时：1\n\n\n## 217. 存在重复元素\n\n<https://leetcode-cn.com/problems/contains-duplicate/>\n\n```java\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        if (nums.length <= 1) return false;\n        \n        Set<Integer> set = new HashSet<>(nums.length);\n        for(int i: nums) set.add(i);\n        return set.size() != nums.length;\n```\n\n耗时：6\n\n## 338. 比特位计数\n\n<https://leetcode-cn.com/problems/counting-bits/>\n\n```java\nclass Solution {\n    public int[] countBits(int num) {\n        int[] ret = new int[num+1];\n        for(int i=0;i<=num;i++){\n            int k = i;\n            while(k > 0) {\n                ret[i]+=k%2;\n                k/=2;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n耗时：12\n\n## 1389. 按既定顺序创建目标数组\n\n<https://leetcode-cn.com/problems/create-target-array-in-the-given-order/>\n\n```java\nclass Solution {\n    public int[] createTargetArray(int[] nums, int[] index) {\n        if (index.length <= 1) return nums;\n        LinkedList<Integer> target = new LinkedList<>();\n        for(int i = 0;i<index.length;i++) target.add(index[i], nums[i]);\n\n        int[] ret = new int[nums.length];\n        for(int i = 0;i<index.length;i++) ret[i]=target.get(i);\n        return ret;\n    }\n}\n```\n\n耗时：2\n\n## 1290. 二进制链表转整数\n\n<https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/>\n\n```java\nclass Solution {\n    public int getDecimalValue(ListNode head) {\n        LinkedList<Integer> s = new LinkedList<>();\n        while(head != null) {\n            s.push(head.val);\n            head = head.next;\n        }\n        int ret = 0;\n        int i = 0;\n        while(!s.isEmpty()){\n            ret += s.pop() * Math.pow(2,i++);\n        }\n        return ret;\n    }\n\n}\n```\n\n耗时：1\n\n## 1295. 统计位数为偶数的数字\n\n<https://leetcode-cn.com/problems/find-numbers-with-even-number-of-digits/>\n\n```java\nclass Solution {\n    public int findNumbers(int[] nums) {\n        int ret = 0;\n        for(int i : nums){\n            if (String.valueOf(i).length() %2 == 0) ret++;\n        }\n        return ret;\n    }\n}\n```\n\n耗时：2\n\n## 933. 最近的请求次数\n\n<https://leetcode-cn.com/problems/number-of-recent-calls/>\n\n```java\nclass RecentCounter {\n\n    private LinkedList<Integer> s = new LinkedList<>();\n\n    public RecentCounter() { }\n    \n    public int ping(int t) {\n        s.add(t);\n        while(!s.isEmpty()){\n            if(s.peekLast() - s.peekFirst() <= 3000){\n                break;\n            }else{\n                s.pop();\n            }\n        }\n        return s.size();\n    }\n}\n```\n\n耗时：26\n\n## 205. 同构字符串\n\n<https://leetcode-cn.com/problems/isomorphic-strings/>\n\n```java\nclass Solution {\n    public boolean isIsomorphic(String s, String t) {\n       Map<Character,Character> m1 = new HashMap<>();\n       Map<Character,Character> m2 = new HashMap<>();\n       for(int i=0;i<s.length();i++){\n           char c1 = s.charAt(i);\n           char c2 = t.charAt(i);\n           m1.putIfAbsent(c1,c2);\n           m2.putIfAbsent(c2,c1); \n       }\n       if (m1.size() != m2.size()) return false;\n       for(int i=0;i<s.length();i++){\n           char c1 = s.charAt(i);\n           char c2 = t.charAt(i);\n           if (c2 != m1.get(c1)) return false;\n           if (c1 != m2.get(c2)) return false;\n       }\n        return true;\n    }\n}\n```\n\n耗时：15\n\n## 面试题 10.01. 合并排序的数组\n\n<https://leetcode-cn.com/problems/sorted-merge-lcci/>\n\n```java\nclass Solution {\n    public void merge(int[] A, int m, int[] B, int n) {\n        int[] ret = new int[m + n];\n        int p=0, q=0, pos = 0;\n        while(pos < ret.length){\n            if (p >= m) {\n                ret[pos++]=B[q++];\n                continue;\n            }\n            if (q >= n) {\n                ret[pos++]=A[p++];\n                continue;\n            }\n            if (A[p] < B[q]) ret[pos++] = A[p++];\n            else ret[pos++] = B[q++];\n            \n        }\n        for(int i=0;i<A.length;i++) A[i] = ret[i];\n    }\n}\n```\n\n耗时：0\n\n## 1299. 将每个元素替换为右侧最大元素\n\n<https://leetcode-cn.com/problems/replace-elements-with-greatest-element-on-right-side/>\n\n```java\nclass Solution {\n    public int[] replaceElements(int[] arr) {\n        PriorityQueue<Integer> q = new PriorityQueue<>((Comparator<Integer>) (o1, o2) -> o2-o1);\n        int[] ret = new int[arr.length];\n        for(int i=arr.length-1;i>=0;i--){\n            if (q.peek() == null) {\n                ret[i]=-1;\n            }else{\n                ret[i]=q.peek();\n            }\n            q.offer(arr[i]);\n        }\n        return ret;\n    }\n}\n```\n\n耗时：10\n\n## 228. 汇总区间\n\n<https://leetcode-cn.com/problems/summary-ranges/>\n\n```java\nclass Solution {\n    public List<String> summaryRanges(int[] nums) {\n        if (nums.length == 0) return List.of();\n        if (nums.length == 1) return List.of(nums[0] + \"\");\n\n        int n = nums.length;\n        int p=0,q=0;\n        List<String> ret = new ArrayList<>(20);\n        for(int i=0;i<n;i++){\n            q = i;\n            if (i == n-1){\n                ret.add(build(p, q, nums));\n                break;\n            }\n            if (nums[i] != nums[i+1]-1){\n                ret.add(build(p,q,nums));\n                p = i+1;\n            }\n        }\n        return ret;\n    }\n    private String build(int p, int q, int[] nums){\n        if (q == p){\n            return nums[p] + \"\";\n        }else {\n            return nums[p] + \"->\"+nums[q];\n        }\n    }\n}\n```\n\n耗时：8\n\n## 674. 最长连续递增序列\n\n<https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/>\n\n```java\nclass Solution {\n    public int findLengthOfLCIS(int[] nums) {\n        if(nums.length <= 1) return nums.length;\n        int max = 0;\n        int seq = 1;\n        for(int i = 1;i<nums.length;i++){\n            if (nums[i] > nums[i-1]) seq++;\n            else seq = 1;\n            if (seq > max) max = seq;\n        }\n        return max;\n    }\n}\n```\n\n耗时：0\n\n## 724. 寻找数组的中心索引\n\n<https://leetcode-cn.com/problems/find-pivot-index/>\n\n```java\nclass Solution {\n    public int pivotIndex(int[] nums) {\n        if (nums.length == 0) return -1;\n        if (nums.length == 1) return 0;\n        int[] l = new int[nums.length];\n        l[0] = nums[0];\n        int[] r = new int[nums.length];\n        r[nums.length - 1] = nums[nums.length - 1];\n\n        for(int i = 1;i<nums.length;i++) l[i] = nums[i] + l[i-1];\n        for(int i = nums.length -2;i>=0;i--) r[i] = nums[i] + r[i+1];\n\n        for(int i = 0;i<l.length;i++){\n            if (l[i] == r[i]) return i;\n        }\n        return -1;\n    }\n}\n```\n\n耗时：2\n\n## 237. 删除链表中的节点\n\n<https://leetcode-cn.com/problems/delete-node-in-a-linked-list/>\n\n```java\nclass Solution {\n    public void deleteNode(ListNode node) {\n        ListNode previous = null;\n        while(node != null){\n            if (node.next != null) node.val = node.next.val;\n            else previous.next = null;\n            \n            previous = node;\n            node = node.next;\n        }\n    }\n}\n```\n\n耗时：0\n\n## 1078. Bigram 分词\n\n<https://leetcode-cn.com/problems/occurrences-after-bigram/>\n\n```java\nclass Solution {\n    public String[] findOcurrences(String text, String first, String second) {\n        List<String> list = new ArrayList<>();\n        String[] arr = text.split(\" \");\n        for(int i=2;i<arr.length;i++){\n            if (first.equals(arr[i-2]) && second.equals(arr[i-1])) list.add(arr[i]);\n        }\n        return list.toArray(new String[]{});\n    }\n}\n```\n\ntime:1 beat:93\n\n## 643. 子数组最大平均数 I\n\n<https://leetcode-cn.com/problems/maximum-average-subarray-i/>\n\n```java\n/*\n* 滑动窗口和思路：维护两个指针，每次滑动总和就减去前一个，然后加上后一个\n*/\nclass Solution {\n    public double findMaxAverage(int[] nums, int k) {\n        if (nums.length <k) return -1;\n        int p=0,q=k-1;\n        int sum=0;\n        double max=0;\n        for(int i=p;i<=q;i++) sum += nums[i];\n        max = (double)sum/k;\n        while(q < nums.length-1){\n            sum -= nums[p++];\n            sum += nums[++q];\n            double t = (double)sum /k;\n            if (t > max) max = t;\n        }\n        return max;\n    }\n}\n```\n\ntime:4 beat:68\n\n## LCP 17. 速算机器人\n\n<https://leetcode-cn.com/problems/nGK0Fy/>\n\n```java\nclass Solution {\n    public int calculate(String s) {\n        int x = 1, y = 0;\n        int p = 0,q = 0;\n        for(int i=0;i<s.length();i++){\n            if (s.charAt(i) == 'A') x = 2 * x + y;\n            else y = 2* y + x;\n        }\n        return x + y;\n    }\n}\n```\n\ntime:0 beat: 100\n\n## 剑指 Offer 40. 最小的k个数\n\n<https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/>\n\n```java\nclass Solution {\n    public int[] getLeastNumbers(int[] arr, int k) {\n        PriorityQueue<Integer> queue = new PriorityQueue<>((o1, o2) -> o1 - o2);\n        for(int i:arr) queue.offer(i);\n        int[] ret = new int[k];\n        for(int i=0;i<k;i++) ret[i]=queue.poll();\n        return ret;\n    }\n}\n```\n\ntime: 20 beat:31\n\n## 160. 相交链表\n\n<https://leetcode-cn.com/problems/intersection-of-two-linked-lists/>\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Map<ListNode,Boolean> map = new HashMap<>();\n        while(headA != null){\n            map.put(headA, true);\n            headA = headA.next;\n        }\n        while(headB != null){\n            if (map.containsKey(headB)) return headB;\n            headB = headB.next;\n        }\n        return null;\n    }\n}\n```\n\ntime:9 beat:15\n\n## 448. 找到所有数组中消失的数字\n\n<https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/>\n\n- 解法1：使用bitmap存储数字是否出现 这个方法使用了额外的存储空间\n\n```java\nclass Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        if (nums.length <=1) return List.of();\n        int[] map = new int[nums.length + 1];\n        for(int i : nums){\n            map[i] = 1;\n        }\n        List<Integer> ret = new ArrayList<>();\n        for(int i = 1;i<map.length;i++){\n            if (map[i] == 0 ) ret.add(i);\n        }\n        return ret;\n    }\n}\n```\n\ntime: 4 beat: 98\n\n## 剑指 Offer 09. 用两个栈实现队列\n\n<https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/>\n\n使用一个辅助栈来实现FIFO的效果\n\n```java\nclass CQueue {\n\n    private LinkedList<Integer> main = new LinkedList<>();\n    private LinkedList<Integer> help = new LinkedList<>();\n    \n    public void appendTail(int value) {\n        main.push(value);\n    }\n    \n    public int deleteHead() {\n        if (main.isEmpty()) return -1;\n        int ret = -1;\n        while(!main.isEmpty()){\n            ret = main.pop();\n            help.push(ret);\n        }\n        help.pop();\n        while(!help.isEmpty()){\n            main.push(help.pop());\n        }\n        return ret;\n    }\n}\n```\n\ntime:220 beat:11\n\n## 剑指 Offer 57. 和为s的两个数字\n\n<https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/>\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int p = 0,q = nums.length - 1;\n        while(p < q){\n            int r = nums[p] + nums[q];\n            if (target == r) return new int[]{nums[p],nums[q]};\n            if (r < target) p++;\n            else q--;\n        }\n        return new int[]{};\n    }\n}\n```\n\ntime:2 beat:95\n\n## 485. 最大连续1的个数\n\n<https://leetcode-cn.com/problems/max-consecutive-ones/>\n\n```java\nclass Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        int cnt = 0;\n        int max = 0;\n        for(int i : nums) {\n            if (cnt >= max) max = cnt;\n            if (i == 0) cnt = 0;\n            else cnt++;\n            if (cnt >= max) max = cnt;\n        }\n        return max;\n    }\n}\n```\n\ntime:2 beat: 90\n\n## 961. 重复 N 次的元素\n\n<https://leetcode-cn.com/problems/n-repeated-element-in-size-2n-array/>\n\n```java\nclass Solution {\n    public int repeatedNTimes(int[] A) {\n        int[] map = new int[10001];\n        for(int i : A) map[i]++;\n        int n = A.length/2;\n        for(int i = 0;i<map.length;i++) if (map[i] >= n) return i;\n        return -1;\n    }\n}\n```\n\ntime:2 beat: 47\n\n## 284. 顶端迭代器\n\n<https://leetcode-cn.com/problems/peeking-iterator/>\n\n```java\nclass PeekingIterator implements Iterator<Integer> {\n\n    private ArrayList<Integer> list = new ArrayList<>();\n    private int pos=0;\n\n\tpublic PeekingIterator(Iterator<Integer> iterator) {\n\t    while(iterator.hasNext()) list.add(iterator.next());\n\t}\n\t\n\tpublic Integer peek() {\n        return list.get(pos);\n\t}\n\t\n\t@Override\n\tpublic Integer next() {\n        return list.get(pos++);\n\t}\n\t\n\t@Override\n\tpublic boolean hasNext() {\n\t    return pos < list.size();\n\t}\n}\n```\n\ntime: 5 beat:99\n\n## 剑指 Offer 59 - I. 滑动窗口的最大值\n\n<https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/>\n\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if (nums.length == 0) return new int[]{};\n        List<Integer> ret = new ArrayList<>();\n        int n = nums.length - k+1;\n        for(int i =0;i<n;i++){\n            int max = nums[i];\n            int p = i,q = k+i;\n            for(int j = p;j<q;j++) if (nums[j] > max) max = nums[j];\n            ret.add(max);\n        }\n\n        int[] ra = new int[ret.size()];\n        for(int i = 0;i<ret.size();i++){\n            ra[i] = ret.get(i);\n        }\n        return ra;\n    }\n}\n```\n\ntime: 40 beat:10\n\n## 1672. 最富有客户的资产总量\n\n<https://leetcode-cn.com/problems/richest-customer-wealth/>\n\n```java\nclass Solution {\n    public int maximumWealth(int[][] accounts) {\n        int max = 0;\n        for(int[] a: accounts){\n            int sum = 0;\n            for(int i: a) sum += i;\n            if (sum > max) max = sum;\n        }\n        return max;\n    }\n}\n```\n\ntime:0 beat:100\n\n## 832. 翻转图像\n\n<https://leetcode-cn.com/problems/flipping-an-image/>\n\n```java\nclass Solution {\n    public int[][] flipAndInvertImage(int[][] A) {\n        for(int[] a: A){\n            int p = 0,q = a.length - 1;\n            while(p <= q) {\n                int t = a[q];\n                a[q] = a[p];\n                a[p] = t;\n                if (a[q] == 0) a[q]=1;\n                else a[q] = 0;\n\n                if (p == q) break;\n                \n                if (a[p] == 0) a[p]=1;\n                else a[p] = 0;\n                p++;q--;\n            }\n        }\n        return A;\n    }\n}\n```\n\ntime:0 beat: 100\n\n## 867. 转置矩阵\n\n<https://leetcode-cn.com/problems/transpose-matrix/>\n\n```java\nclass Solution {\n    public int[][] transpose(int[][] matrix) {\n        int[][] reversed = new int[matrix[0].length][matrix.length];\n        for(int i = 0;i<matrix.length;i++){\n            for(int j = 0;j<matrix[i].length;j++){\n                reversed[j][i] = matrix[i][j];\n            }\n        }\n        return reversed;\n    }\n}\n```\n\ntime: 1 beat: 38\n\n## 面试题 16.01. 交换数字\n\n<https://leetcode-cn.com/problems/swap-numbers-lcci/>\n\n```py\nclass Solution(object):\n    def swapNumbers(self, numbers):\n        numbers[0] = numbers[1] + numbers[0]\n        numbers[1] = numbers[0] - numbers[1]\n        numbers[0] = numbers[0] - numbers[1]\n        return numbers\n```\n\ntime:12 beat:91\n\n## 896. 单调数列\n\n<https://leetcode-cn.com/problems/monotonic-array/>\n\n```java\nclass Solution {\n    public boolean isMonotonic(int[] A) {\n        if (A.length == 1) return true;\n        boolean lastIncr = false;\n        boolean lastDecr = false;\n        for(int i = 1;i<A.length;i++){\n            int q = A[i] - A[i - 1];\n            if (q > 0) { // 递增\n                if (lastDecr) return false;\n                lastIncr = true;\n            }else if (q < 0) { // 递减\n                if (lastIncr) return false;\n                lastDecr = true;\n            }\n        }\n        return true;\n    }\n}\n```\n\ntime: 1 beat: 100\n\n## 1470. 重新排列数组\n\n<https://leetcode-cn.com/problems/shuffle-the-array/>\n\n```java\nclass Solution {\n    public int[] shuffle(int[] nums, int n) {\n        int p = 0,q = n;\n        int[] ret = new int[nums.length];\n        for(int i = 0;i<ret.length;i+=2){\n            ret[i] = nums[p++];\n            ret[i + 1] = nums[q++];\n        }\n        return ret;\n    }\n}\n```\n\ntime: 0 beat: 100\n\n## 304. 二维区域和检索 - 矩阵不可变\n\n<https://leetcode-cn.com/problems/range-sum-query-2d-immutable/>\n\n```java\nclass NumMatrix {\n    private int[][] cache;\n    public NumMatrix(int[][] matrix) {\n        if (matrix.length == 0) cache = new int[0][0];\n        else cache = new int[matrix.length][matrix[0].length];\n        \n        for(int i = 0;i<matrix.length;i++){\n            for(int j = 0;j< matrix[i].length;j++){\n                cache[i][j] = matrix[i][j];\n            }\n        }\n        for(int i = 0;i<matrix.length;i++){\n            for(int j = 1;j< matrix[i].length;j++){\n                cache[i][j] += cache[i][j-1];\n            }\n        }\n        for(int i = 1;i<matrix.length;i++){\n            for(int j = 0;j< matrix[i].length;j++){\n                cache[i][j] += cache[i-1][j];\n            }\n        }\n    }\n    \n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        if (cache.length == 0) return 0;\n        if (row1 == 0 && col1 == 0) return cache[row2][col2];\n        if (row1 == 0) return cache[row2][col2] - cache[row2][col1-1];\n        if (col1 == 0) return cache[row2][col2] - cache[row1-1][col2];\n        \n        return cache[row2][col2] - cache[row1-1][col2] - (cache[row2][col1-1] - cache[row1-1][col1-1]);\n    }\n}\n```\n\ntime: 14 beat: 98\n\n## 1047. 删除字符串中的所有相邻重复项\n\n<https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/>\n\n```java\nclass Solution {\n    public String removeDuplicates(String S) {\n        LinkedList<Character> s = new LinkedList<>();\n        for(int i = 0;i<S.length();i++){\n            if (s.peek() == null) {\n                s.push(S.charAt(i));\n                continue;\n            }\n            if (S.charAt(i) == s.peek()) s.pop();\n            else s.push(S.charAt(i));\n        }\n        char[] ca = new char[s.size()];\n        for(int i = s.size() - 1;i>=0;i--) ca[i] = s.pop();\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0;i<ca.length;i++) sb.append(ca[i]);\n        return sb.toString();\n    }\n}\n```\n\ntime: 16 beat: 72\n\n## 1512. 好数对的数目\n\n<https://leetcode-cn.com/problems/number-of-good-pairs/>\n\n```java\nclass Solution {\n    public int numIdenticalPairs(int[] nums) {\n        int cnt = 0;\n        for(int i = 0;i<nums.length;i++){\n            for(int j = i+1;j<nums.length;j++){\n                if (nums[i] == nums[j]) cnt++;\n            }\n        }\n        return cnt;\n    }\n}\n```\n\ntime:1 beat:81\n\n## 面试题 02.03. 删除中间节点\n\n<https://leetcode-cn.com/problems/delete-middle-node-lcci/>\n\n```java\nclass Solution {\n    public void deleteNode(ListNode node) {\n        ListNode prev = null;\n        while(node != null){\n            if (prev != null) prev.val = node.val;\n            if (node.next == null) break;\n            prev = node;\n            node = node.next;\n        }\n        if (prev != null) prev.next = null;\n    }\n}\n```\n\ntime:0 beat: 100\n\n## 1684. 统计一致字符串的数目\n\n<https://leetcode-cn.com/problems/count-the-number-of-consistent-strings/>\n\n```java\nclass Solution {\n    public int countConsistentStrings(String allowed, String[] words) {\n        boolean[] map = new boolean[128];\n        for(int i = 0;i<allowed.length();i++){\n            map[allowed.charAt(i)] = true;\n        }\n        int cnt = 0;\n        for(String str : words){\n            boolean flag = true;\n            for(int i =0;i<str.length();i++){\n                if (!map[str.charAt(i)]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) cnt++;\n        }\n        return cnt;\n\n    }\n}\n```\n\ntime:8 beat:74\n\n## 1379. 找出克隆二叉树中的相同节点\n\n<https://leetcode-cn.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/>\n\n```java\nclass Solution {\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\n        if (original == null) return null;\n        if (original == target){\n            return cloned;\n        }\n        TreeNode left = getTargetCopy(original.left, cloned.left, target);\n        TreeNode right = getTargetCopy(original.right, cloned.right, target);\n        if (left != null) return left;\n        if (right != null) return right;\n        return null;\n    }\n}\n```\n\ntime:2 beat:46\n\n## 1464. 数组中两元素的最大乘积\n\n<https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array/>\n\n```java\n\nclass Solution {\n    public int maxProduct(int[] nums) {\n        int max = -1;\n        int second = -1;\n        int maxIndex = 0;\n        int secondIndex = 1;\n        for(int i =0;i<nums.length;i++){\n            if (nums[i] > max) {\n                max = nums[i];\n                maxIndex = i;\n            }\n        }\n        for(int i =0;i<nums.length;i++){\n            if (nums[i] > second && i != maxIndex) {\n                second = nums[i];\n                secondIndex = i;\n            }\n        }\n        return (max-1) * (second - 1);\n    }\n}\n```\n\ntime:1 beat:76\n\n## 535. TinyURL 的加密与解密\n\n<https://leetcode-cn.com/problems/encode-and-decode-tinyurl/>\n\n```java\nimport java.util.concurrent.atomic.*;\npublic class Codec {\n    private ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();\n    private volatile AtomicInteger cnt = new AtomicInteger();\n    public String encode(String longUrl) {\n        map.putIfAbsent(String.valueOf(cnt.incrementAndGet()), longUrl);\n        return String.valueOf(cnt.get());\n    }\n\n    public String decode(String shortUrl) {\n        return map.get(shortUrl);\n    }\n}\n```\n\ntime:2 beat: 68\n\n## 删除有序数组中的重复项\n\n<https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/>\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length == 0) return 0;\n        int i = 0;\n        for (int j = 1; j < nums.length; j++) {\n            if (nums[j] != nums[i]) {\n                i++;\n                nums[i] = nums[j];\n            }\n        }\n        return i + 1;\n    }\n}\n```\n\ntime:1 beat: 81\n\n## 5734. 判断句子是否为全字母句\n\n<https://leetcode-cn.com/problems/check-if-the-sentence-is-pangram/>\n\n```java\nclass Solution {\n    public boolean checkIfPangram(String sentence) {\n        if (sentence.length() < 26) return false;\n        boolean[] map = new boolean[26];\n        for(int i = 0;i< sentence.length();i++){\n            char c = sentence.charAt(i);\n            map[c - 97] = true;\n        }\n        for(boolean i : map){\n            if (!i) return false;\n        }\n        return true;\n    }\n}\n```\n\ntime:2 beat:100\n\n## 1822. 数组元素积的符号\n\n<https://leetcode-cn.com/problems/sign-of-the-product-of-an-array/>\n\n```java\n\nclass Solution {\n    public int arraySign(int[] nums) {\n        boolean n = true;\n        for(int i : nums){\n            if (i == 0) return 0;\n            if (n && i < 0) {\n                n = false;\n                continue;\n            }\n            if (n && i > 0) {\n                n = true;\n                continue;\n            }\n            if (!n && i > 0) {\n                n = false;\n                continue;\n            }\n            if (!n && i < 0) {\n                n = true;\n                continue;\n            }\n        }\n        if (n) return 1;\n        else return -1;\n\n    }\n}\n```\ntime: 1 beat:29\n\n## 1365. 有多少小于当前数字的数字\n\n<https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/>\n\n```java\nclass Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int[] ret = new int[nums.length];\n        for(int i = 0;i < nums.length;i++){\n            for(int j = 0;j < nums.length;j++){\n                if (j == i) continue;\n                if (nums[j] < nums[i]) ret[i]++;\n            }\n        }\n        return ret;\n    }\n}\n```\n\ntime:18 beat:8\n\n## 1476. 子矩形查询\n\n<https://leetcode-cn.com/problems/subrectangle-queries/>\n\n```java\nclass SubrectangleQueries {\n    private int[][] rectangle;\n    public SubrectangleQueries(int[][] rectangle) {\n        this.rectangle = rectangle;\n    }\n    \n    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {\n        for(int i = row1;i<= row2;i++){\n            for(int j = col1;j<=col2;j++){\n                rectangle[i][j] = newValue;\n            }\n        }\n    }\n    \n    public int getValue(int row, int col) {\n        return rectangle[row][col];\n    }\n}\n```\n\ntime: 30 beat:86\n\n## 剑指 Offer 54. 二叉搜索树的第k大节点\n\n<https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/>\n\n```java\nclass Solution {\n    public int kthLargest(TreeNode root, int k) {\n       LinkedList<Integer> s = new LinkedList<>();\n       travel(root, s);\n       int cnt = 1;\n       while(!s.isEmpty()){\n           int i = s.pop();\n           if (cnt == k) return i;\n           cnt++;\n       }\n       return -1;\n    }\n\n    public void travel(TreeNode root, LinkedList<Integer> s){\n        if (root == null) return;\n        travel(root.left, s);\n        s.push(root.val);\n        travel(root.right, s);\n    }\n}\n```\n\ntime:1 beat:40\n\n## 1603. 设计停车系统\n\n<https://leetcode-cn.com/problems/design-parking-system/>\n\n```java\nclass ParkingSystem {\n\n    private int big;\n    private int medium;\n    private int small;\n\n    public ParkingSystem(int big, int medium, int small) {\n        this.big = big;\n        this.medium = medium;\n        this.small = small;\n    }\n    \n    public boolean addCar(int carType) {\n        if (carType == 1) {\n            if (big > 0) {\n                big--;\n                return true;\n            }\n            return false;\n        }\n        if (carType == 2) {\n            if (medium > 0) {\n                medium--;\n                return true;\n            }\n            return false;\n        }\n        if (carType == 3) {\n            if (small > 0){\n                small--;\n                return true;\n            }\n            return false;\n        }\n        return false;\n    }\n}\n```\n\ntime: 16 beat:9\n\n## 977. 有序数组的平方\n\n<https://leetcode-cn.com/problems/squares-of-a-sorted-array/>\n\n```java\nclass Solution {\n    public int[] sortedSquares(int[] nums) {\n        for(int i=0;i<nums.length;i++){\n            nums[i] = nums[i] * nums[i];\n        }\n        int p=0,q=nums.length - 1;\n        int[] ret = new int[nums.length];\n        for(int i = nums.length - 1; i>=0;i--){\n            if (nums[p] > nums[q]){\n                ret[i] = nums[p++];\n            }else if (nums[p] <= nums[q]) {\n                ret[i] = nums[q--];\n            }\n        }\n        return ret;\n    }\n}\n```\n\ntime:1 beat:100\n\n## 1304. 和为零的N个唯一整数\n\n```java\nclass Solution {\n    public int[] sumZero(int n) {\n        if (n == 2) return new int[]{1, -1};\n        int preSum = 0;\n        int[] ret = new int[n];\n        for(int i = 0;i<n - 1;i++){\n            preSum += i;\n            ret[i] = i;\n        }\n        ret[n - 1] = -preSum;\n        return ret;\n    }\n}\n```\n\ntime:0 beat: 100\n\n## 面试题 02.02. 返回倒数第 k 个节点\n\n<https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/>\n\n```java\nclass Solution {\n\n    private int ret;\n\n    private int cnt;\n\n    public int kthToLast(ListNode head, int k) {\n        cnt = 0;\n        process(head, k);\n        return ret;\n    }\n\n    public void process(ListNode head, int k){\n        if (head == null) {\n            return;\n        }\n        process(head.next, k);\n        cnt++;\n        if (cnt == k) ret = head.val;\n    }\n}\n```\n\ntime:0 beat:100\n\n\n## 1261. 在受污染的二叉树中查找元素\n\n<https://leetcode-cn.com/problems/find-elements-in-a-contaminated-binary-tree/>\n\n- 解法1 \n\n```java\nclass FindElements {\n\n    private TreeNode root;\n\n    public FindElements(TreeNode root) {\n        this.root = root;\n        if (root != null) root.val = 0;\n        recover(root);\n    }\n    \n    public boolean find(int target) {\n        return find(root, target);\n    }\n\n    private boolean find(TreeNode root, int target){\n        if (root == null) return false;\n        if (root.val == target) return true;\n        return find(root.left, target) || find(root.right, target);\n    }\n\n    private void recover(TreeNode root){\n        if (root == null) return;\n\n        if (root.left != null) root.left.val = 2*root.val+1;\n        if (root.right != null) root.right.val = 2*root.val+2;\n\n        recover(root.left);\n        recover(root.right);\n    }\n}\n```\n\ntime: 1000+ beat:20\n\n- 解法2 优化：增加缓存\n\n```java\nclass FindElements {\n\n    private TreeNode root;\n    private Map<Integer, Boolean> map = new HashMap<>();\n\n    public FindElements(TreeNode root) {\n        this.root = root;\n        if (root != null) root.val = 0;\n        recover(root);\n    }\n    \n    public boolean find(int target) {\n        return map.containsKey(target);\n    }\n\n    private void recover(TreeNode root){\n        if (root == null) return;\n\n        if (root.left != null) {\n            root.left.val = 2*root.val+1;\n            map.put(root.left.val, true);\n        }\n        if (root.right != null) { \n            root.right.val = 2*root.val+2;\n            map.put(root.right.val, true);\n        }\n\n        recover(root.left);\n        recover(root.right);\n```\n\ntime:28 beat:84\n\n## 1678. 设计 Goal 解析器\n\n<https://leetcode-cn.com/problems/goal-parser-interpretation/>\n\n```java\nclass Solution {\n    public String interpret(String command) {\n        StringBuilder sb = new StringBuilder();\n        int p = 0,q = 1;\n        for(;p<command.length();p++,q++){\n            char c = command.charAt(p);\n            if (c == 'G') sb.append('G');\n            if (c == '(') {\n                if (command.charAt(q) == ')') {\n                    sb.append(\"o\");\n                    p++;\n                    q++;\n                }\n                else {\n                    sb.append(\"al\");\n                    p += 2;\n                    q += 2;\n                }\n            }\n        }\n        return sb.toString();\n    }\n}\n```\n\ntime: 0\n\n## 905. 按奇偶排序数组\n\n<https://leetcode-cn.com/problems/sort-array-by-parity/>\n\n```java\nclass Solution {\n    public int[] sortArrayByParity(int[] nums) {\n        if (nums.length == 1) return nums;\n        int p = 0, q = nums.length - 1;\n        int[] ret = new int[nums.length];\n        for(int i : nums){\n            if (i % 2 == 0) ret[p++] = i;\n            else ret[q--] = i;\n        }\n        return ret;\n    }\n}\n```\n\ntime:1 beat:100\n\n## 1773. 统计匹配检索规则的物品数量\n\n<https://leetcode-cn.com/problems/count-items-matching-a-rule/>\n\n```java\nclass Solution {\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n        return (int)items\n                .stream()\n                .filter(list -> {\n                    if (\"type\".equals(ruleKey)) return list.get(0).equals(ruleValue);\n                    else if (\"color\".equals(ruleKey)) return list.get(1).equals(ruleValue);\n                    else if (\"name\".equals(ruleKey)) return list.get(2).equals(ruleValue);\n                    return false;\n                })\n                .count();\n    }\n}\n```\n\ntime:5 beat: 57\n\n## 1848. 到目标元素的最小距离\n\n<https://leetcode-cn.com/problems/minimum-distance-to-the-target-element/>\n\n```java\nclass Solution {\n    public int getMinDistance(int[] nums, int target, int start) {\n        int min = -1;\n        int minVal = 0;\n        int tmp = 0;\n        for(int i = 0;i<nums.length;i++) {\n            if (nums[i] == target) {\n                tmp = Math.abs(i - start);\n                if (min == -1) {\n                    min = i;\n                    minVal = tmp;\n                    continue;\n                }\n                if (tmp < minVal) {\n                    min = i;\n                    minVal = tmp;\n                }\n            }\n        }\n        return minVal;\n    }\n}\n```\n\ntime: 1 beat:62\n\n## 1450. 在既定时间做作业的学生人数\n\n<https://leetcode-cn.com/problems/number-of-students-doing-homework-at-a-given-time/>\n\n```java\nclass Solution {\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\n        int cnt = 0;\n        for(int i = 0;i<startTime.length;i++){\n            if (startTime[i] <= queryTime && queryTime <= endTime[i]) cnt++;\n        }\n        return cnt;\n    }\n}\n```\n\ntime: 0\n\n## 1859. 将句子排序\n\n<https://leetcode-cn.com/problems/sorting-the-sentence/>\n\n```java\nclass Solution {\n    public String sortSentence(String s) {\n        String[] a = s.split(\" \");\n        String[] ret = new String[a.length];\n        for(String str : a){\n            int index = Integer.parseInt(str.charAt(str.length() - 1) + \"\");\n            ret[index - 1] = str.substring(0, str.length() - 1);\n        }\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0;i<ret.length;i++){\n            sb.append(ret[i]);\n            if (i != ret.length - 1) sb.append(\" \");\n        }\n        return sb.toString();\n    }\n}\n```\n\ntime:4 beat:28\n\n## 面试题 04.08. 首个共同祖先\n\n<https://leetcode-cn.com/problems/first-common-ancestor-lcci/>\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        List<TreeNode> list = new ArrayList<>();\n        lowestCommonAncestor1(root, p, q, list);\n        return list.get(list.size() - 1);\n    }\n\n    public void lowestCommonAncestor1(TreeNode root, TreeNode p, TreeNode q, List<TreeNode> list) {\n        if (root == null) return;\n\n        if (hasChild(p, q)) list.add(p);\n        if(hasChild(q, p)) list.add(q);\n        if (hasChild(root, p) && hasChild(root, q)) list.add(root);;\n        \n        lowestCommonAncestor1(root.left, p, q, list);\n        lowestCommonAncestor1(root.right, p, q, list);\n    }\n\n    private boolean hasChild(TreeNode root, TreeNode child) {\n        if (root == null) return false;\n        if (root == child) return true;\n        return hasChild(root.left, child) || hasChild(root.right, child);\n    }\n}\n```\n\ntime:2500+ beat:5\n\n## 1662. 检查两个字符串数组是否相等\n\n<https://leetcode-cn.com/problems/check-if-two-string-arrays-are-equivalent/>\n\n```java\nclass Solution {\n    public boolean arrayStringsAreEqual(String[] word1, String[] word2) {\n        String s1 = Arrays.stream(word1)\n                    .collect(Collectors.joining());\n        String s2 = Arrays.stream(word2)\n                    .collect(Collectors.joining());\n        return s1.equals(s2);\n    }\n}\n```\n\ntime:3 beat:11\n\n## 342. 4的幂\n\n<https://leetcode-cn.com/problems/power-of-four/>\n\n```java\nclass Solution {\n    public boolean isPowerOfFour(int n) {\n        int cnt = 0;\n        int lim = (int)Math.sqrt(n);\n        while(cnt <= lim) {\n            if (Math.pow(4, cnt) == n) return true;\n            cnt++;\n        }\n        return false;\n    }\n}\n```\n\ntime:10 beat:8\n\n## 面试题 17.04. 消失的数字\n\n<https://leetcode-cn.com/problems/missing-number-lcci/>\n\n```java\nclass Solution {\n    public int missingNumber(int[] nums) {\n        if (nums.length < 1) return 0;\n        \n        boolean[] map = new boolean[nums.length + 1];\n        for(int i : nums) map[i] = true;\n        for(int i = 0; i< map.length;i++) {\n            if (!map[i]) return i;\n        }\n        return -1;\n    }\n}\n```\n\ntime:1 beat:40\n\n## 852. 山脉数组的峰顶索引\n\n<https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/>\n\n```java\nclass Solution {\n    public int peakIndexInMountainArray(int[] arr) {\n        int max = 0;\n        for(int i = 0;i<arr.length;i++){\n            if (arr[i] > arr[max]) max = i;\n        }\n        return max;\n    }\n}\n```\n\ntime:1 beat: 16\n\n## 1869. 哪种连续子字符串更长\n\n<https://leetcode-cn.com/problems/longer-contiguous-segments-of-ones-than-zeros/>\n\n```java\nclass Solution {\n    public boolean checkZeroOnes(String s) {\n        return getMaxSeq(s, '1') > getMaxSeq(s, '0');\n    }\n\n    private int getMaxSeq(String s, char n) {\n        if (s.length() == 1) return s.charAt(0) == n ? 1 : 0;\n        int p=0,q=0;\n        int max = 0;\n        for(int i = 0;i<s.length();i++){\n            char c = s.charAt(i);\n            if (c == n) q = i;\n            else p = i + 1;\n\n            if (q - p > max) max = q - p;\n        }\n        return max;\n    }\n}\n```\n\ntime:1 beat:98\n\n## 1342. 将数字变成 0 的操作次数\n\n<https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/>\n\n```java\nclass Solution {\n    public int numberOfSteps(int num) {\n        int cnt = 0;\n        while(num != 0) {\n            if (num % 2 == 1) num--;\n            else num /= 2;\n            cnt++;\n        }\n        return cnt;\n    }\n}\n```\n\ntime:0 beat:100\n\n## 19. 删除链表的倒数第 N 个结点\n\n<https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/>\n\n```java\nclass Solution {\n    private int cnt = 0;\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        remove(head, new int[]{n});\n        if (cnt == n) return head.next;\n        return head;\n    }\n\n    private void remove(ListNode head, int[] n) {\n        if (head == null) return;\n        cnt++;\n        remove(head.next, n);\n        if (n[0] == 0) {\n            head.next = head.next.next;\n        }\n        n[0]--;\n    }\n}\n```\n\ntime:0 beat:100\n\n## 1302. 层数最深叶子节点的和\n\n<https://leetcode-cn.com/problems/deepest-leaves-sum/>\n\n```java\nclass Solution {\n    private int maxDepth = 0;\n    private int sum;\n    public int deepestLeavesSum(TreeNode root) {\n        travel(root, 0);\n        calc(root, 0);\n        return sum;\n    }\n\n    private void calc(TreeNode root, int depth){\n        if (root == null) return;\n        int curDepth = depth + 1;\n        calc(root.left, curDepth);\n        calc(root.right, curDepth);\n        if (depth == maxDepth - 1) sum += root.val;\n    }\n\n    private void travel(TreeNode root, int depth){\n        if (depth > maxDepth) maxDepth = depth;\n        if (root == null) return;\n        int curDepth = depth + 1;\n        travel(root.left, curDepth);\n        travel(root.right, curDepth);\n    }\n}\n```\n\ntime:1 beat:100\n\n## 1833. 雪糕的最大数量\n\n<https://leetcode-cn.com/problems/maximum-ice-cream-bars/>\n\n```java\nclass Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        PriorityQueue<Integer> q = new PriorityQueue<>(Comparator.comparingInt(o -> o));\n        for (int i : costs) {\n            q.offer(i);\n        }\n        int cnt = 0;\n        while(coins > 0) {\n            Integer i = q.poll();\n            if (i == null) return cnt;\n            if (i > coins) return cnt;\n            cnt++;\n            coins -= i;\n        }\n        return cnt;\n    }\n}\n```\n\ntime: 60+ beat: 5\n\n## 1929. 数组串联\n\n<https://leetcode-cn.com/problems/concatenation-of-array/>\n\n```java\nclass Solution {\n    public int[] getConcatenation(int[] nums) {\n        int[] ans = new int[nums.length * 2];\n        for(int i = 0;i<ans.length;i++){\n            ans[i] = nums[i % nums.length];\n        }\n        return ans;\n    }\n}\n```\n\ntime:1 beat:100\n\n## 1920. 基于排列构建数组\n\n<https://leetcode-cn.com/problems/build-array-from-permutation/>\n\n```java\nclass Solution {\n    public int[] buildArray(int[] nums) {\n        int[] ans = new int[nums.length];\n        for(int i = 0;i<nums.length;i++) ans[i] = nums[nums[i]];\n        return ans;\n    }\n}\n```\n\n## 1720. 解码异或后的数组\n\n<https://leetcode-cn.com/problems/decode-xored-array/>\n\n```java\nclass Solution {\n    public int[] decode(int[] encoded, int first) {\n        int[] ans = new int[encoded.length + 1];\n        ans[0] = first;\n        for (int i = 1;i<ans.length;i++){\n            ans[i] = encoded[i - 1] ^ ans[i - 1];\n        }\n        return ans;\n    }\n}\n```\n\ntime:1 beat:100\n\n## 1431. 拥有最多糖果的孩子\n\n<https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/>\n\n```java\nclass Solution {\n    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {\n        int max = candies[0];\n        for(int i : candies) {\n            if (i > max) max = i;\n        }\n        List<Boolean> ans = new ArrayList<>(candies.length);\n        for(int i : candies) {\n            ans.add(i + extraCandies >= max);\n        }\n        return ans;\n    }\n}\n```\n\ntime:0 beat:100\n\n## 1656. 设计有序流\n\n<https://leetcode-cn.com/problems/design-an-ordered-stream/>\n\n```java\nclass OrderedStream {\n    private String[] data;\n    private int ptr = 1;\n    public OrderedStream(int n) {\n        data = new String[n + 1];\n    }\n    \n    public List<String> insert(int idKey, String value) {\n        data[idKey] = value;\n        List<String> ans = new ArrayList<>();\n        int i = ptr;\n        for (;i< data.length;i++){\n            if (data[i] != null) ans.add(data[i]);\n            else break;\n        }\n        ptr = i % data.length;\n        return ans;\n    }\n}\n```\n\ntime: 78 beat: 98\n\n## 219. 存在重复元素 II\n\n<https://leetcode-cn.com/problems/contains-duplicate-ii/>\n\n```java\nclass Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        if (k == 0) return false;\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0;i<nums.length;i++){\n            if (map.containsKey(nums[i])) {\n                if (Math.abs(map.get(nums[i]) - i) <= k) return true;\n                else map.put(nums[i], i);\n            }else {\n                map.put(nums[i], i);\n            }\n        }\n        return false;\n    }\n}\n```\n\ntime:17 beat:40\n\n## 1877. 数组中最大数对和的最小值\n\n<https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/>\n\n```java\nclass Solution {\n    public int minPairSum(int[] nums) {\n        Arrays.sort(nums);\n        int ans = 0;\n        int n = nums.length;\n        int t = 0;\n        for(int i=0;i<n;i++) {\n            t = nums[i] + nums[n - i - 1];\n            if (t > ans) ans = t;\n        }\n        return ans;\n    }\n}\n```\n\ntime: 57 beat:98\n\n## 268. 丢失的数字\n\n<https://leetcode-cn.com/problems/missing-number/>\n\n```java\nclass Solution {\n    public int missingNumber(int[] nums) {\n        int n = nums.length;\n        int sum = (n * (n+1)) /2;\n        for(int i : nums) sum -= i;\n        return sum;\n    }\n}\n```\n\ntime:0 beat:100\n\n## 1704. 判断字符串的两半是否相似\n\n<https://leetcode-cn.com/problems/determine-if-string-halves-are-alike/>\n\n```java\nclass Solution {\n    public boolean halvesAreAlike(String s) {\n        int[] map = new int[128];\n        map['a'] = 1;\n        map['e'] = 1;\n        map['i'] = 1;\n        map['o'] = 1;\n        map['u'] = 1;\n        map['A'] = 1;\n        map['E'] = 1;\n        map['I'] = 1;\n        map['O'] = 1;\n        map['U'] = 1;\n        int front = 0;\n        int back = 0;\n        int n = s.length()/2;\n        for(int i = 0;i<n;i++) {\n            char c1 = s.charAt(i);\n            char c2 = s.charAt(i + n);\n            if (map[c1] == 1) front++;\n            if (map[c2] == 1) back++;\n        }\n        return front == back;\n    }\n}\n```\n\ntime:2 beat:95\n\n\n## 260. 只出现一次的数字 III\n\n<https://leetcode-cn.com/problems/single-number-iii/>\n\n```java\nclass Solution {\n    public int[] singleNumber(int[] nums) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i : nums) {\n            if (map.containsKey(i)) map.remove(i);\n            else map.put(i, i);\n        }\n        int[] ans = new int[2];\n        int cnt = 0;\n        for(int key: map.keySet()) ans[cnt++] = key;\n        return ans;\n    }\n}\n```\n\ntime: 5 beat: 17\n\n## 551. 学生出勤记录 I\n\n<https://leetcode-cn.com/problems/student-attendance-record-i/>\n\n```java\nclass Solution {\n    public boolean checkRecord(String s) {\n        int a = 2;\n        boolean lateInTripleDay = false;\n\n        for(int i = 0;i<s.length();i++) if (s.charAt(i) == 'A') a--;\n\n        int p = 0, q = 2;\n        while(q < s.length()) {\n            if (s.charAt(p) == 'L' && s.charAt(q-1) == 'L' && s.charAt(q) == 'L') lateInTripleDay = true;\n            p++;q++;\n        }\n\n        return a > 0 && !lateInTripleDay;\n    }\n}\n```\n\ntime：1 beat: 41\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}