{"content":"# 字符串\n\n## 排序\n\n- 低位优先排序\n\n```java\npublic static void sort(String[]a,int W) {\n        int N = a.length;\n        int R = 256;\n        String[] aux = new String[N];\n        //循环W次键索引记数法\n        for(int d = W-1; d>=0;d--) {\n            int[] count = new int[R+1];\n            //键索引记数法第一步--频率统计\n            for(int i=0;i<N;i++)\n                count[a[i].charAt(d)+1]++;\n            //键索引记数法第二步--将频率转化为索引\n            for(int r=0;r<R;r++)\n                count[r+1]+=count[r];\n            //键索引记数法第三步--排序\n            for(int i=0;i<N;i++)\n                aux[count[a[i].charAt(d)]++] = a[i];\n            //键索引记数法第四步--回写\n            for(int i=0;i<N;i++)\n                a[i]=aux[i];\n        }\n}\n```\n\n- 高位优先排序\n\n```java\npublic class MSD {\n    private static int R = 256;    //字符串中最多可能出现的字符的数量\n    private static final int M = 15;    //当子字符串长度小于M时，用直接插入排序\n    private static String[] aux;    //辅助数组\n    //实现自己的chatAt()方法\n    private static int charAt(String s, int d) {\n        if(d<s.length())return s.charAt(d);\n        else return -1;\n    }\n\t\n    public static void sort(String[] a) {\n        int N = a.length;\n        aux = new String[N];\n        sort(a,0,N-1,0);\n    }\n    private static void sort(String[] a,int lo, int hi, int d) {\n        if(hi<=lo+M) {Insertion.sort(a,lo,hi,d);return;}    //切换为直接插入排序\n        int[] count = new int[R+2];\n        //键索引记数法第一步\n        for(int i=lo; i<=hi;i++)\n            count[charAt(a[i],d)+2]++;\n        //键索引记数法第二步\t\t\n        for(int r=0;r<R+1;r++)\n            count[r+1]+=count[r];\n        //键索引记数法第三步\t\t\n        for(int i=lo;i<=hi;i++)\n            aux[count[a[i].charAt(d)+1]++] = a[i];\n        //键索引记数法第四步\t\t\n        for(int i=lo;i<=hi;i++)\n            a[i]=aux[i-lo];\n\t\t//递归以每个字符为键进行排序\n        for(int r=0;r<R;r++)\n            sort(a,lo+count[r],lo+count[r+1]-1,d+1);\n    }\n}\n```\n\n- 三向字符串快速排序\n\n```java\npublic class Quick3string {\n    private static int charAt(String s, int d) {\n        if(d<s.length())return s.charAt(d);\n        else return -1;\n    }\n    public static void sort(String[] a) { sort(a,0,a.length-1,0); }\n\t\n    public static void sort(String[] a,int lo, int hi, int d) {\n        if(hi<=lo)\treturn;\n        int lt = lo, gt = hi;\n        int v = charAt(a[lo], d);\n        int i = lo+1;\n        while(i<=gt) {\n            int t = charAt(a[lo],d);\n            if(t<v)\texch(a,lt++,i++);\n            else if(t>v)\texch(a,i,gt--);\n            else i++;\n        }\n        sort(a,lo,lt-1,d);\n        if(v>=0) sort(a,lt,gt,d+1);\n        sort(a,gt+1,hi,d);\n    }\n}\n```\n\n## 单词查找树\n\n- 查找\n\n![](https://www.tuhd.top/img/alog/%E5%9B%BE5.2.2.jpg)\n\n- 插入\n\n![](https://www.tuhd.top/img/alog/%E5%9B%BE5.2.3.jpg)\n\n- 查询所有键　\n  - 通过递归的方式，如果有分叉，则生成一个由pre+branch的新字符串\n\n```java\npublic Interable<String> keys() {\n  return keysWithPrefix(\"\");\n}\npublic Interable<String> keysWithPrefix(String pre) {\n  Queue<String> q = new Queue<String>();\n  collect(get(root, pre, 0), pre, q);\n  return q;\n}\nprivate void collect(Node x, String pre, Queue<String> q) {\n  if (x == null) return;\n  if (x.val != null) q.enqueue(pre);\n  for (char c = 0; c < R; c++)\n    collect(x.next[c], pre + c, q);\n}\n```\n\n![](https://www.tuhd.top/img/alog/%E5%9B%BE5.2.5.jpg)\n\n- 删除\n\n找到键所对应的结点并将它的值设为空（null）。如果该结点含有一个非空的链接指向某个子结点，那么就不需要在进行其他操作了。如果它的所有链接均为空，那就需要在数据结构中删去这个结点。如果删去它使得它的父结点的所有链接也均为空，就需要继续删除它的父结点，以此类推\n\n```java\npublic void delete(String key) {\n  root = delete (root, key, 0);\n}\nprivate Node delete(Node x, String key, int d) {\n  if (x == null) return null;\n  if (d == key.length())\n    x.val = null;\n  else {\n    char c = key.charAt(d);\n    x.next[c] = delete(x.next[c], key, d+1);\n  }\n  if (x.val != null) return x;\n  for (char c = 0; c < R; c++)\n    if (x.next[c] != null) return x;\n  return null;\n}\n```\n\n### 三向单词查找树\n\n在三向单词查找树（TST）中，每个结点都含有一个字符、三条链接和一个值。这三条链接分别对应着当前字母小于、等于和大于结点字母的所有键\n\n![](https://www.tuhd.top/img/alog/%E5%9B%BE5.2.10.jpg)\n\n- 查找\n\n![](https://www.tuhd.top/img/alog/%E5%9B%BE5.2.11.jpg)\n\n## 子字符串查找\n\n- 暴力查找\n\n```java\npublic static int search(String pat, String txt) { \n        int M = pat.length(); \n        int N = txt.length(); \n \n        // 逐个位置匹配模式字符串 \n        for (int i = 0; i < N; i++) { \n            int j; \n            for (j = 0; j < M; j++) { \n                if (txt.charAt(i + j) != pat.charAt(j)) { \n                    break; \n                } \n            } \n \n            // 找到了匹配的字符串 \n            if (j == M) { \n                return i; \n            } \n        } \n        return N; \n}\n```\n\n- 暴力查找(显式回退)\n\n```java\n  public static int searchother(String pat, String txt) { \n        int M = pat.length(); \n        int N = txt.length(); \n        int i; \n        int j; \n \n        // 逐个位置匹配模式字符串 \n        for (i = 0, j = 0; i < N && j < M; i++) { \n            if (txt.charAt(i) == pat.charAt(j)) { \n                j++; \n            } else { \n                i -= j; \n                j = 0; \n            } \n        } \n \n        // 找到了匹配的字符串 \n        if (j == M) { \n            return i - M; \n       } else { \n            return N; \n       } \n\n  }\n```\n\n- KMP算法\n\n根据模式构造一个DFA,使用DFA匹配\n\n- BM算法\n- RK指纹字符查找算法\n\n## 正则表达式\n\n- 连接\n\nAB -> {AB}\n\n- 或\n\nＡ|B -> {A,B}\n\n- 闭包\n\nＢ* -> 0个或多个Ｂ\n\n### 构造正则表达式\n\n![](https://img-blog.csdnimg.cn/2018122615333966)\n\n## 数据压缩\n\n### 游程编码\n\n行程编码（Run Length Encoding，RLE), 又称游程编码、行程长度编码、变动长度编码 等，是一种统计编码。主要技术是检测重复的比特或字符序列，并用它们的出现次数取而代之\n\n### 霍夫曼压缩\n\n用较少的比特表示出现次数多的字符，用较多的比特表示出现频率低的字符\n\n- 变长前缀\n  - 使用单词查找树实现\n\n### LZW压缩\n\nLZW编码 (Encoding) 的核心思想其实比较简单，就是把出现过的字符串映射到记号上，这样就可能用较短的编码来表示长的字符串，实现压缩\n\nLZW的一个核心思想，即压缩后的编码是自解释 (self-explaining) 的。什么意思？即字典是不会被写进压缩文件的，在解压缩的时候，一开始字典里除了默认的0->A和1->B之外并没有其它映射，2->AB是在解压缩的过程中一边加入的。这就要求压缩后的数据自己能告诉解码器，完整的字典，例如2->AB是如何生成的，在解码的过程中还原出编码时用的字典\n\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}