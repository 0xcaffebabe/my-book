{"content":"# 查找\n\n## 顺序查找\n\n按照顺序一个个比较，直到序列末尾\n\n```c\nint seq_search(int array[], int n, int key)\n{\n    int i;\n    for(i = 0; i < n; i++)\n    {\n        if(key == array[i])\n        {\n            return i;   //查找成功\n        }   \n    }\n    return -1;          //查找失败\n}\n```\n\n## 二分查找\n\n**通过对一个有序数组中对元素依次比较，从而能实现对数级别时间复杂度的查找**\n\n根据左右指针计算出一个mid指针 如果mid指针处的元素等于目标值 则要查找的目标就是在这里\n\n否则如果mid处的指针比目标值大 则右指针等于mid-1 否则左指针等于mid+1\n\n然后重复上述操作 直到左指针大于右指针\n\n```java\nint l = 0, r = a.length - 1;\nwhile (l <= r) {\n    int mid = l + (r - l) / 2;\n    if (a[mid].equals(target)) {\n        return mid;\n    }\n    \n    if (less(target, a[mid])) {// 要查找的元素在左边\n        r = mid - 1;\n    } else if (greater(target, a[mid])) { // 要查找的元素在右边\n        l = mid + 1;\n    }\n}\nreturn -1;\n```\n\n## 二叉查找树\n\n- 高效\n\n**特点**\n\n每个结点的键值大于左孩子，小于右孩子\n\n每个孩子又是二叉查找树\n\n**二分查找树不一定是完全二叉树**\n\n### 插入\n\n```java\nif (root == null) {\n    count++;\n    return new Node(key, value); // 当前节点为null，则创建一个节点返回\n}\nif (key.equals(root.key)) { //　当前节点等于要插入的节点，则直接覆盖\n    root.value = value;\n} else if (less(key, root.key)) { //　当前节点比要插入的大，则向当前节点的左子树插入\n    root.left = insert(root.left, key, value);\n} else if (greater(key, root.key)) {  //　当前节点比要插入的小，则向当前节点的右子树插入\n    root.right = insert(root.right, key, value);\n}\n```\n\n### 查找\n\n原理同插入，根据左子树比父节点小，右子树比父节点大的条件\n\n```java\nif (root == null){\n    return null;\n}\nif (key.equals(root.key)){\n    return root.value;\n}else if(less(key,root.key)){\n    return search(root.left,key);\n}else {\n    return search(root.right,key);\n}\n```\n\n**floor与ceil**\n\n- floor：是最接近key值且**小于**key的节点\n- ceil：是最接近key值且**大于**key的节点\n\n\n### 遍历\n\n- 前序遍历\n\n先访问当前节点，再递归访问左右子树\n\n```java\nif (root != null){\n    consumer.accept(root.key,root.value);\n    preOrder(root.left,consumer);\n    preOrder(root.right,consumer);\n}\n```\n\n- 中序遍历\n\n先递归访问左子树，再访问自身，再递归访问右子树\n\n```java\nif (root != null){\n    preOrder(root.left,consumer);\n    consumer.accept(root.key,root.value);\n    preOrder(root.right,consumer);\n}\n```\n\n- 后序遍历\n\n先递归访问左右子树，在访问自身\n\n```java\nif (root != null){\n    preOrder(root.left,consumer);\n    preOrder(root.right,consumer);\n    consumer.accept(root.key,root.value);\n}\n```\n\n- 广度优先遍历(层序)\n\n```java\nQueue<Node> queue = new LinkedList<>();\nqueue.add(root);\nwhile (!queue.isEmpty()) {\n    var node = queue.remove();\n    consumer.accept(node.key,node.value);\n    if (node.left != null){\n        queue.add(node.left);\n    }\n    if (node.right != null){\n        queue.add(node.right);\n    }\n}\n```\n\n### 删除\n\n分为三种情况\n\n- 删除叶子节点\n  - 直接解除父节点对其的引用即可\n\n- 删除只有一个子节点的\n  - 将父节点指向其子节点\n\n```java\nprivate Node removeMax(Node node) {\n    \n    if (node.right == null) {\n        // 代表当前节点就是最大节点，所以返回当前节点的左子树给父节点\n        count--;\n        return node.left;\n    }\n    // 将删除的节点的左子树作为父节点的右子树\n    node.right = removeMax(node.right);\n    return node;\n}\n```\n\n- 删除有两个子节点的\n\n**Hubbard Deletion**\n\n 使用被删除节点右子树中的最小节点来代替被删除节点\n\n### 局限性\n\n- 同样的数据会对应不同的查找树\n  - 有可能退化成链表\n\n\n## 2-3查找树\n\n### 插入\n\n>2-3树之所以完美平衡，关键在于插入时的维护\n\n![](https://git.oschina.net/riteme/blogimg/raw/master/rbtree-and-2-3-tree/23-tree-insert-5-cases.png)\n\n#### 节点分裂\n\n![](https://git.oschina.net/riteme/blogimg/raw/master/rbtree-and-2-3-tree/23-tree-4-node-to-2-node.png)\n\n#### 插入示例\n\n![](https://git.oschina.net/riteme/blogimg/raw/master/rbtree-and-2-3-tree/23-tree-insert-example.png)\n\n### 删除\n\n## 红黑树\n\n![](https://git.oschina.net/riteme/blogimg/raw/master/rbtree-and-2-3-tree/rbtree-example-2.png)\n\n### 基本操作\n\n#### 旋转\n\n![](https://git.oschina.net/riteme/blogimg/raw/master/rbtree-and-2-3-tree/rbtree-rotate-1-2.png)\n\n#### 反色\n\n![](https://git.oschina.net/riteme/blogimg/raw/master/rbtree-and-2-3-tree/rbtree-flip-1.png)\n\n### 插入\n\n新插入的节点均设为红色\n\n- 情况１\n\n对ｂ逆时针旋转\n\n![](https://git.oschina.net/riteme/blogimg/raw/master/rbtree-and-2-3-tree/rbtree-insert-1.png)\n\n- 情况2\n\n反色\n\n![](https://git.oschina.net/riteme/blogimg/raw/master/rbtree-and-2-3-tree/rbtree-insert-2.png)\n\n- 情况3\n\n进行顺时针旋转,变成情况２\n\n![](https://git.oschina.net/riteme/blogimg/raw/master/rbtree-and-2-3-tree/rbtree-insert-3.png)\n\n### 删除\n\n## 散列表\n\n根据键（Key）而直接访问在内存存储位置的数据结构,也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度\n\n### 散列函数\n\n这个过程会讲键转化为数组的索引\n\n把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值\n\n### 散列冲突\n\n当不同的输入得到相同的hash值时，称为散列冲突\n\n#### 解决：拉链法\n\n当发生碰撞的时候，拉链法是将碰撞的元素串成一个链表\n\n![](https://images0.cnblogs.com/blog/631817/201502/271613146279675.x-png)\n\n#### 解决：线性探测\n\n当发生碰撞的时候，直接检查散列表中的下Ｎ个位置（Ｎ可正可负）\n\n![](http://static.oschina.net/uploads/img/201606/28163944_loVe.png)\n\n- 在查找的时候，如插入一样一直进行线性探测，直至碰到一个键为空的槽\n\n### 删除\n\n删除的时候，不能简单地将槽置为空，需要将与该键同散列值的键都往前移动，填补因为该键被删除而造成的空缺\n\n### 调整大小\n\n当数组大小发生改变，不能直接位置一对一迁移，而是需要对先前的每个元素，重新计算散列(rehash)，重新放入槽\n\n### java中的实现\n\nJDK8后，HashMap当冲突列表超过８个之后，会使用红黑树\n\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}