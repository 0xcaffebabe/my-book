{"content":"# 并查集\n\n并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题\n\n- 连接问题\n\n## find\n\n- find操作返回该节点连接的节点\n\n```java\nint find(int p) {\n    return data[p];\n}\n```\n\n另外一种实现，通过判断两个节点是否拥有同样的祖先来判断是否相连\n\n```java\nwhile (p != parent[p]) {\n    p = parent[p];\n}\nreturn p;\n```\n\n## isConnected\n\n- 判断两个节点是否连接在一起的（判断这两个节点是否连接了同一个节点）\n\n```java\nboolean isConnected(int p, int q) {\n    return find(p) == find(q);\n}\n```\n\n## union\n\n- 连接两个节点（将一个节点指向另外一个节点）\n\n```java\nint pid = find(p);\nint qid = find(q);\nif (pid == qid){\n    return;\n}\nfor (int i = 0; i < count; i++) {\n    if (data[i]==pid){\n        data[i]=qid;\n    }\n}\n```\n\n使用另外一种实现的union\n\n```java\nint qRoot = find(p);\nint pRoot = find(q);\nif (qRoot == pRoot){\n    return;\n}\nparent[pRoot]=qRoot;\n```\n\n基于size的优化，维护一个size数组，代表以i为根的集合的元素个数\n\n```java\nif (sz[pRoot]<sz[qRoot]){        \n    parent[pRoot] = qRoot;\n    sz[qRoot]+=sz[pRoot];\n}else {\n    parent[qRoot] = pRoot;\n    sz[qRoot]+=sz[pRoot];\n}\n```\n\n使用rank来决定谁连接谁\n\n```java\nif (rank[pRoot] < rank[qRoot]) {\n    parent[pRoot] = qRoot;\n} else if ((rank[pRoot] > rank[qRoot])) {\n    parent[qRoot] = pRoot;\n} else {\n    parent[pRoot] = qRoot;\n    rank[qRoot] += 1;\n}\n```\n\n## 路径压缩\n\n- find\n\n```java\nwhile (p != parent[p]) {\n    parent[p]=parent[parent[p]];\n    p = parent[p];\n}\nreturn p;\n```\n\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}