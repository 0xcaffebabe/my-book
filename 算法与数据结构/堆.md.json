{"content":"# 堆\n\n## 应用\n\n- 优先级队列\n\n## 堆的存储\n\n### 二叉堆\n\n- 是一棵完全二叉树（最大堆）\n\n### 用数组存储二叉堆\n\n![批注 2020-02-09 090145](/assets/批注%202020-02-09%20090145.png)\n\n### 操作\n\n- shift up\n\n新加入的元素与其父元素判断，是否比父元素大，如果是，交换两个元素，以此类推，直到小于其父亲\n\n```java\nwhile (less(data,i/2,i)) {\n    swap(data,i/2,i);\n    i/=2;\n}\n```\n\n- shift down\n\n只能取出根节点的元素，取出后，使用堆中的最后一个元素填补空缺\n\n填补后，跟左右两个孩子比较，哪个孩子大就跟谁交换...以此类推，直至自己比两个孩子都大\n\n```java\nwhile (2 * k <= count) {\n    int j =2*k;\n    // 确定要跟左子树比较还是跟右子树\n    if (j+1<=count && greater(data,j+1,j)){\n        // 右子树\n        j++;\n    }\n    // 如果自己大于要比较的子树，则停止\n    if (greaterThan(data,k,j)){\n        break;\n    }\n    swap(data,k,j);\n    k=j;\n}\n```\n\n## 堆排序\n\n```java\nMaxHeap<Comparable<?>> heap = new MaxHeap<>(a.length+1);\nfor (int i = 0; i < a.length; i++) {\n    heap.insert(a[i]);\n}\nfor (int i = 0; i < a.length; i++) {\n    a[i]=heap.remove();\n}\n```\n\n## Heapify（堆化【将数组转为堆】）\n\n对于一棵完全二叉树，其最后一个非叶子节点是元素个数除二取整\n\n所以要把一个数组堆化，只需要对其非叶子结点进行shift down\n\n```java\nfor (int i = 0; i < a.length; i++) {\n    data[i + 1] = a[i];\n}\ncount = a.length;\n// 对其非叶子结点进行shift down\nfor (int i = count / 2; i >= 1; i--) {\n    shiftDown(i);\n}\n```\n\n## 原地堆排序\n\n```java\nint n = a.length;\n// 先将整个数组构造成一个最大堆\nfor (int i = (n - 2) / 2; i >= 0; i--) {\n    shiftDown(a, n, i);\n}\n// 将堆中的第一大元素移到末尾，再次构造最大堆(排除末尾排好序的元素)\n// 然后下一次循环再将第一大元素移到倒数第二个...以此类推，直至只剩一个元素\nfor (int i = n - 1; i > 0; i--) {\n    swap(a, 0, i);\n    shiftDown(a, i, 0);\n}\n```\n\n## 索引堆\n\n- 引入一个index数组，在增删改查的时候，提供一个index\n- 索引堆根据这个index找到数据在data中的位置\n\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}