{"content":"# Handler\n[toc]\n\n>Handler 是一个消息分发对象。handler是Android给我们提供用来更新UI的一套机制，也是一套消息处理机制，我们可以发消息，也可以通过它处理消息\n\n由于非UI线程无法修改界面（主要的原因是防止数据不一致）\n\n那么，如果直接创建一个线程，进行UI更新操作，程序会崩掉：\n```java\nnew Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n                Toast.makeText(MainActivity.this,\"获取到消息\",Toast.LENGTH_SHORT).show();\n\n            }\n        }).start();\n```\n## 发送消息\n```java\n// 成员变量\nprivate Handler handler = new Handler(new Handler.Callback() {\n        @Override\n        public boolean handleMessage(Message msg) {\n            Toast.makeText(MainActivity.this,\"获取到消息\"+msg.what,Toast.LENGTH_SHORT).show();\n            return true;\n        }\n    });\n\n// 创建一个发送消息给Handler\nnew Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n                Toast.makeText(MainActivity.this,\"获取到消息\",Toast.LENGTH_SHORT).show();\n                Message message = new Message();\n                message.what=0x123;\n                handler.sendMessage(message);\n            }\n        }).start();\n```\n## 直接让Handler执行一段代码\n```java\nnew Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n\n                handler.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        Toast.makeText(MainActivity.this,\"获取到消息\",Toast.LENGTH_SHORT).show();\n                    }\n                });\n                \n            }\n        }).start();\n```\n## Callback\n这个类是Handler的一个内部类，作用主要是回调，在上面的例子我们已经认识到它的作用了\n\n## UI线程与子线程通信\n- Looper：类似一个消息泵。它本身是一个死循环，不断地从MessageQueue中提取Message或者Runnable\n- MessageQueue：一个消息队列，可以看作是一个容器，用来存放消息\n\n而Handler可以看做是一个Looper的暴露接口，向外部暴露一些事件，并暴露sendMessage()和post()函数\n\n除了UI线程/主线程以外，普通的线程(先不提HandlerThread)是不自带Looper的\n## 更新UI的四种方式\n- 使用Handler消息传递\n- Handler的post\n- AsyncTask\n- Activity.runOnUiThread\n- View.post\n后两种本质上也是使用了Handler\n\n## 非UI线程更新UI\n在oncreate方法中开启子线程更新ui，在thread没有休眠的情况下，因为ViewRootImp在activity的onresume方法中创建，在ViewRootImp方法中判断当前线程是否为主线程，oncreate在onresume之前执行，所以这种情况下，可以进行更新ui操作\n```java\n@Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        new Thread(new Runnable() {\n            @Override\n            public void run() {\n                \n                handler.post(new Runnable() {\n                    @Override\n                    public void run() {\n                        Toast.makeText(MainActivity.this,\"获取到消息\",Toast.LENGTH_SHORT).show();\n                    }\n                });\n\n            }\n        }).start();\n\n    }\n```\n以上代码可以正确运行","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}