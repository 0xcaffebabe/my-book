{"content":"# 存储器层次结构\n\n## 基本存储体系\n\n1)输入设备将程序与数据写入主存； 2) CPU取指令； 3) CPU执行指令期间读数据； 4) CPU写回运算结果； 5) 输出设备输出结果；\n\n### 主存速度慢的原因\n\n- 主存增速与CPU增速不同步；\n- 指令执行期间多次访问存储器；\n\n### 主存容量不足的原因\n\n- 存在制约主存容量的技术因素\n\n  - CPU、主板等相关技术指标确定\n\n- 应用对主存的需求不断扩大\n- 价格原因\n\n### 存储体系的层次结构\n\n![](http://www.pianshen.com/images/328/6f35b9255f2323c21c19478089c6d008.png)\n\n- L1 Cache集成在CPU中，分数据Cache(D-Cache)和指令Cache(I-Cache）\n- 早期L2 Cache在主板上或与CPU集成在同一电路板上。随着工艺的提高，L2Cache被集成在CPU内核中，不分D-Cache和I-Cache\n\n### 局部性\n\n- 时间局部性\n\n  - 现在被访问的信息2在不久的将来还将再次被访问\n  - 时间局部性的程序结构体现： 循环结构\n\n- 空间局部性\n\n  - 现访问信息2 ，下一次访问2附近的信息。\n  - 空间局部性的程序结构体现：顺序结构\n\n## 主存中的数据组织\n\n- 主存的一个存储单元所包含的二进制位数\n- 目前大多数计算机的主存按字节编址，存储字长也不断加大,如16位字长、32位字长和64位字长\n\n**ISA设计时要考虑的两个问题**：\n\n- 字的存放问题\n- 字的边界对齐问题\n\n### 数据存储与边界\n\n按边界对齐的数据存储：浪费一些空间\n\n![批注 2020-01-30 161009](/assets/批注%202020-01-30%20161009.png)\n\n未按边界对齐存放：虽节省了空间，但增加了访存次数\n\n![批注 2020-01-30 161136](/assets/批注%202020-01-30%20161136.png)\n\n需要在性能与容量间权衡\n\n- 双字长数据边界对齐的起始地址的最末三位为000(8字节整数倍；\n- 单字长边界对齐的起始地址的末二位为00(4字节整数倍)；\n- 半字长边界对齐的起始地址的最末一位为0(２字节整数倍)。\n\n#### 大端与小端存储\n\n- 小端存储\n\n  - 就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端\n\n- 大端存储\n\n  - 就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端\n\n无论是大端还是小端，每个系统内部是一致的，但在系统间通信时可能会发生问题！因为顺序不同，需要进行顺序转换\n\n## 存储技术\n\n## 随机访问存储器\n\n### 静态RAM(SRAM)\n\n![批注 2020-01-30 162459](/assets/批注%202020-01-30%20162459.png)\n\n**工作原理**\n\n- 读\n- 写\n- 保持\n\n#### 结构\n\n![批注 2020-01-15 092634](/assets/批注%202020-01-15%20092634.png)\n\n#### 静态存储器的不足\n\n- 晶体管过多\n- 存储密度低\n- 功耗大\n\n### 动态RAM(DRAM)\n\n![enter image description here](http://artimg.ishenping.com/20190430163945966_TSVNYF.jpg)\n\n![批注 2020-01-30 164801](/assets/批注%202020-01-30%20164801.png)\n\nDRAM与SRAM不同的是，需要间隔一段时间执行刷新操作\n\n- 读写\n- 保持\n\n#### 刷新\n\n- 集中刷新\n\n![批注 2020-01-30 165930](/assets/批注%202020-01-30%20165930.png)\n\n- 分散刷新\n\n![批注 2020-01-30 170041](/assets/批注%202020-01-30%20170041.png)\n\n- 异步刷新\n\n![批注 2020-01-30 190013](/assets/批注%202020-01-30%20190013.png)\n\n#### 其它结构的DRAM存储单元\n\n- 单管\n\n![批注 2020-01-30 190355](/assets/批注%202020-01-30%20190355.png)\n\n### 传统DRAM\n\n![](http://itfish.net/Home/Modules/Images/itfish_61045_2.jpg)\n\n- 内存模块\n\n  ![](http://itfish.net/Home/Modules/Images/itfish_61045_3.jpg)\n\n- 增强DRAM\n\n- 非易失性存储器\n\n- 访问主存\n\n  ![](http://itfish.net/Home/Modules/Images/itfish_61045_4.jpg)\n\n## 存储扩展\n\n- 位扩展\n\n用16K X 8 的存储芯片构建16K X 32的存储器\n\n- 字扩展\n\n用16K X 8 的存储芯片构建128k X 8的存储器\n\n- 字位扩展\n\n用16K X 8 的存储芯片构建128K X 32的存储器\n\n![批注 2020-01-30 190639](/assets/批注%202020-01-30%20190639.png)\n\n无论哪种类型的存储扩展都要完成CPU与主存间地址线、数据线、控制线的连接\n\n## 磁盘存储\n\n- 磁盘构造\n\n  ![](http://itfish.net/Home/Modules/Images/itfish_61045_5.jpg)\n\n- 磁盘容量\n\n  - 记录密度\n  - 磁道密度\n  - 面密度\n\n- 磁盘操作\n\n  - 寻道时间\n  - 旋转时间\n  - 传送时间\n\n- 逻辑磁盘块\n\n  （盘面，磁道，扇区）\n\n- 连接IO设备\n\n  ![](http://www.pianshen.com/images/281/0013ac41fa289bfec93c3c9ece6b41a9.png)\n\n  - 通用串行总线（USB）\n  - 图形卡\n  - 主机总线适配器\n\n- 访问磁盘\n\n  **内存映射**\n\n## 固态硬盘\n\n## raid\n\n- 将数据条带化后的存放在不同磁盘上，通过多磁盘的并行操作提高磁盘系统的读写速率\n- 使用基于异或运算为基础的校验技术恢复损坏的数据\n\n![批注 2020-02-08 204640](/assets/批注%202020-02-08%20204640.png)\n\n### raid0\n\n- 数据以条带方式均匀分散在各磁盘\n\n![批注 2020-02-08 204953](/assets/批注%202020-02-08%20204953.png)\n\n### raid1\n\n- 数据采用镜像的冗余方式，同一数据有多份拷贝\n\n![批注 2020-02-08 205138](/assets/批注%202020-02-08%20205138.png)\n\n### RAID 3/4\n\n- 数据按 位/条带 并行传输到多个磁盘上，同时校验数据存放到专用校验盘上\n\n![批注 2020-02-08 205227](/assets/批注%202020-02-08%20205227.png)\n\n### RAID5\n\n- 数据按条带分布在不同磁盘上，校验信息被均匀分散到各磁盘上\n\n![批注 2020-02-08 205428](/assets/批注%202020-02-08%20205428.png)\n\n### RAID10\n\n- 结合RAID1和RAID0，先镜像，再条带化\n\n![批注 2020-02-08 205601](/assets/批注%202020-02-08%20205601.png)\n\n### RAID01\n\n- 结合RAID0和RAID1，先条带化, 再镜像\n\n![批注 2020-02-08 205654](/assets/批注%202020-02-08%20205654.png)\n\n只能容忍一个磁盘故障，如0号盘损坏，左边RAID0失效，只能使用右边的RAID0，不能再有盘损坏，故冗余度为1\n\n### 实现方式\n\n- 软件RAID\n  - 功能都依赖于主机CPU完成,没有第三方的控制处理器和I/O芯片\n- 硬件RAID\n  - 专门RAID控制处理器和I/O处理芯片处理RAID任务，不占用主机CPU资源\n\n### 比较\n\n![批注 2020-02-08 205826](/assets/批注%202020-02-08%20205826.png)\n\n## 存储技术的趋势\n\n- 价格和性能折中\n- 不同存储技术的价格与属性以不同的速率变化\n\n## 对程序数据引用的局部性\n\n## 取指令的局部性\n\n## 多体交叉存储器\n\n其基本思想是在不提高存储器速率、不扩展数据通路位数的前提下，通过存储芯片的交叉组织，提高CPU单位时间内访问的数据量，从而缓解快速的CPU与慢速的主存之间的速度差异。\n\n### 高位多体交叉存储器\n\n![批注 2020-01-16 113946](/assets/批注%202020-01-16%20113946.png)\n\n### 低位多体交叉存储器\n\n![批注 2020-01-16 113919](/assets/批注%202020-01-16%20113919.png)\n\n![批注 2020-02-08 161132](/assets/批注%202020-02-08%20161132.png)\n\n## 高速缓存存储器\n\n### cache的工作过程\n\n![批注 2020-02-08 161925](/assets/批注%202020-02-08%20161925.png)\n\n- 如何判断数据在Cache中?\n- Cache中的数据是有效吗？（DMA【直接存储访问】修改主存）\n\n![批注 2020-02-08 162227](/assets/批注%202020-02-08%20162227.png)\n\n### cache地址映射机制\n\n![批注 2020-02-08 162555](/assets/批注%202020-02-08%20162555.png)\n\n### cache的结构\n\n- Cache被分成若干行，每行的大小与主存块相同\n- Cache每行包含四部分，是Cache要保存的信息。Tag从CPU访问主存的地址中剥离得到、Data是与主存交换的数据块、Valid表示Cache中的数据是否有效、 Dirty表示主存中的数据是最新\n\n![批注 2020-02-08 162726](/assets/批注%202020-02-08%20162726.png)\n\n### 相联存储器\n\n- 如何快速地查找\n  - 如何快速地判断数据是否存在\n\n### Cache地址映射与变换方法\n\n- 主存数据如何迁至Cache才能实现快速查找\n\n#### 全相联映射\n\n![批注 2020-02-08 164919](/assets/批注%202020-02-08%20164919.png)\n\n- 主存分块，Cache行 （Line），两者大小相同\n- 设每块4个字，主存大小为1024个字，则第61个字的主存地址为：\n  - 00001111 01 （块号 块内地址）\n- 主存分块后地址就从一维变成二维\n- 映射算法：主存的数据块可映射到Cache任意行，同时将该数据块地址对应行的标记存储体中保存\n\n**特点**\n\n- Cache利用率高\n- 块冲突率低\n- 淘汰算法复杂\n\n所以应用在小容量cache\n\n#### 直接映射\n\n![批注 2020-02-08 165705](/assets/批注%202020-02-08%20165705.png)\n\n- 主存分块，Cache行 （Line），两者大小相同\n- 主存分块后还将以Cache行数为标准进行分区\n- 设每块4个字，主存大小为1024个字，Cache分为4行，第61个字的主存地址为\n  - 000011 11 01 （区号，区内块号，块内地址）\n  - 主存地址从一维变成三维\n- 映射算法：Cache共n行，主存第j块号映射到Cache 的行号为 i=j mod n\n  - 即主存的数据块映射到Cache特定行\n\n**特点**\n\n- Cache利用率低\n- 块冲突率高\n- 淘汰算法简单\n\n应用在大容量cache\n\n#### 组相联映射\n\n![批注 2020-02-08 185829](/assets/批注%202020-02-08%20185829.png)\n\n- 主存分块，Cache行 （Line），两者大小相同；\n- Cache分组（每组中包k行），本例假定K=4\n- 主存分块后还将以Cache组数为标准进行分组；\n- 设每块4个字，主存大小为1024个字，Cache分为4行，第61个字的主存地址为：\n  - 0000111 1 01 （组号，组内块号，块内地址）\n  - 主存地址从一维变成三维；\n- 映射算法：\n  - Cache共n组，主存第j块号映射到Cache 的组号为：i=j mod n\n  - 即主存的数据块映射到Cache特定组的任意行\n\n### 替换算法\n\n程序运行一段时间后，Cache存储空间被占满，当再有新数据要调入时，就需要通过某种机制决定替换的对象\n\n#### 先进先出法-FIFO\n\n![批注 2020-02-08 191721](/assets/批注%202020-02-08%20191721.png)\n\n#### 最不经常使用法---LFU\n\n![批注 2020-02-08 191910](/assets/批注%202020-02-08%20191910.png)\n\n#### 近期最少使用法--- LRU\n\n![批注 2020-02-08 192722](/assets/批注%202020-02-08%20192722.png)\n\n#### 替换算法的抖动\n\n- 刚刚淘汰的块在下一时刻又被访问...\n\n## 虚拟存储器\n\n- 计算机能执行比主存空间大的程序吗？\n\n### 概述\n\n- 处于主存 –辅存存储层次\n- 解决主存容量不足的问题，为程序设计者提供比主存空间大的编程空间\n- 分类：页式虚拟存储器、段式虚拟存储器 、段页式虚拟存储器\n\n### 必须解决的问题\n\n![批注 2020-02-08 200857](/assets/批注%202020-02-08%20200857.png)\n\n- CPU访问存储系统的地址属性（采用MMU(Memory Management Unit):管理虚拟存储器与物理存储器）\n- 如何判断CPU要访问的信息是否在主存中（采用页表来判断）\n\n### 地址划分\n\n虚拟地址 = 虚页号+页偏移量\n\n### 逻辑地址与物理地址的转换\n\n## TLB (Translation Lookaside Buffer)\n\n### 虚实地址转换过程中存在的问题\n\n- 缺页异常\n\n![批注 2020-02-08 202837](/assets/批注%202020-02-08%20202837.png)\n\n### 工作原理\n\nTLB类似页表，也是PTE的集合。为实现对TLB的快速访问，类似于Cache中的映射方法，对来自于CPU的虚页号进行逻辑划分，得到相应的标记和索引字段\n\n![批注 2020-02-08 204051](/assets/批注%202020-02-08%20204051.png)\n\n## 缓存写\n\n## 高速缓存参数的性能影响\n\n- 不命中率\n- 命中率\n- 命中时间\n- 不命中处罚\n\n## 存储器层次结构中的缓存\n\n缓解快速CPU与慢速的主存之间的速度差异\n\n![](http://www.pianshen.com/images/46/61cff5bd9636e956ae24618f4e6a90de.png)\n\n### 工作工程\n\n- 缓存命中\n- 缓存不命中\n\n  - 冷不命中\n  - 冲突不命中\n\n- 缓存管理\n\n# 编写高速缓存友好的代码\n\n# 高速缓存对程序性能的影响\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}