{"content":"# 程序编码\n\n在编译时指定'-Og'选项让GCC产生符合原始程序结构的机器代码\n\n## 机器级代码\n\n对C语言隐藏， 但对汇编代码可见的：\n\n- 程序计数器\n- 整数寄存器文件\n- 条件码寄存器\n- 向量寄存器\n\n输出c源码的机器表示\n\n```shell\ngcc -Og -S mstore.c\n```\n\n机器代码与反汇编的特性：\n\n- x86-64的指令长度从1-15字节不等\n- 指令设计的格式， 从某个给定位置， 能将字节唯一解码成机器指令\n\n  _哈夫曼编码_\n\n- 反汇编无需访问源代码\n\n- 反汇编与gcc的命名规则有些许差别\n\n  _比如movq的q在反汇编中会被省略_\n\n## 关于格式的注解\n\n```assembly\n.file    \"mstore.c\"\n    .text\n    .globl    mulstore\n    .type    mulstore, @function\nmulstore:\n.LFB0:\n    .cfi_startproc\n    pushq    %rbx\n    .cfi_def_cfa_offset 16\n    .cfi_offset 3, -16\n    movq    %rdx, %rbx\n    call    mult2\n    movq    %rax, (%rbx)\n    popq    %rbx\n    .cfi_def_cfa_offset 8\n    ret\n    .cfi_endproc\n.LFE0:\n    .size    mulstore, .-mulstore\n    .ident    \"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-36)\"\n    .section    .note.GNU-stack,\"\",@progbits\n```\n\n以上是gcc完整生成的.s文件\n\n所有. 开头的是伪指令， 可以忽略\n\n### ATT汇编代码格式\n\n```asm\n.file    \"mstore.c\"\n    .text\n    .globl    mulstore\n    .type    mulstore, @function\nmulstore:\n.LFB0:\n    .cfi_startproc\n    pushq    %rbx\n    .cfi_def_cfa_offset 16\n    .cfi_offset 3, -16\n    movq    %rdx, %rbx\n    call    mult2\n    movq    %rax, (%rbx)\n    popq    %rbx\n    .cfi_def_cfa_offset 8\n    ret\n    .cfi_endproc\n.LFE0:\n    .size    mulstore, .-mulstore\n    .ident    \"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-36)\"\n    .section    .note.GNU-stack,\"\",@progbits\n```\n\n# 数据格式\n\n- 16位： 字(w)\n- 32位： 双字(l)\n- 64位： 四字(q)\n\n![enter image description here](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3376004043, 3845334967&fm=15&gp=0.jpg)\n\n- moveb： 传送字节\n- movew： 传送字\n- movel： 传送双字\n- moveq： 传送四字\n\n# 访问信息\n\nx86-64的CPU包含一组16个存储64位的通用目的寄存器\n\n![enter image description here](https://images2017.cnblogs.com/blog/123045/201708/123045-20170803104941928-1961116877.png)\n\n- 16位操作可以访问2位字节\n- 32位操作可以访问4位字节\n\n...\n\n**栈指针（%rsp）**\n\n## 操作数指示符\n\n- 立即数： 代表常数\n\n  $后面接c语言表示法的整数\n\n- 寄存器： 表示寄存器里的内容\n\n  r\n\n  <sub>a</sub>\n\n  用来表示寄存器a 用R[r\n\n  <sub> a </sub>\n\n  ]表示里面的内容\n\n- 内存引用： 指定内存地址里的内容 M[地址]\n\n![enter image description here](https://images2017.cnblogs.com/blog/1120165/201709/1120165-20170925204134214-1101378630.png)\n\n## 数据传送指令\n\n![enter image description here](https://img2018.cnblogs.com/blog/1294022/201811/1294022-20181111181730605-1915220225.png)\n\n![enter image description here](https://anduinwrynn.github.io/2018/03/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ACSAPP%E3%80%8B%E7%AC%94%E8%AE%B0/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180307215157.png)\n\n## 压入栈和弹出栈数据\n\n```asm\n. 将四字压入栈\npushq S \n\n. 将四字弹出栈\npopq D\n```\n\n_%rsp 是栈指针 %rax是返回值_\n\n# 算术和逻辑操作\n\n![enter image description here](https://img2018.cnblogs.com/blog/1539443/201811/1539443-20181127212130893-665387977.png)\n\n## 加载有效地址\n\n```asm\n. x= y+x*4\nleaq    (%rdi,%rsi,4), %rax\n```\n\n## 一元和二元操作\n\n```asm\n. 从%edi中减去%esi\nsubl    %esi, %edi\n```\n\n## 移位操作\n\n```asm\n. 将x左移四位\nsalq    $4, %rax\n```\n\n## 特殊的算术操作\n\n![enter image description here](https://123xzy.github.io/2018/03/29/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%882%EF%BC%89/2.jpg)\n\n# 控制\n\n## 条件码\n\n- CF:进位标志\n- ZF:零标志\n- SF:符号标志\n- OF:溢出标志\n\n![enter image description here](https://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004111725599-1349960030.png)\n\n## 读取条件码\n\n![enter image description here](https://img-blog.csdnimg.cn/20181122230816427.png)\n\n## 跳转指令\n\n![enter image description here](https://senzhangai.github.io/assets/images/csapp/csapp3_12.JPG)\n\n## 用条件控制实现分支控制\n\n```asm\ncmpq    %rsi, %rdi\n        jg      .L4\n        movq    %rdi, %rax\n        subq    %rsi, %rax\n        ret\n.L4:\n        leaq    (%rdi,%rsi), %rax\n        ret\n```\n\n对应的c代码：\n\n```c\nif (x > y){\n    return x+y;\n}else{\n    return x-y;\n}\n```\n\n## 用条件传送实现条件分支\n\n_分支预测_\n\n![enter image description here](https://images2017.cnblogs.com/blog/1120165/201710/1120165-20171004174749599-2077484997.png)\n\n## 循环\n\n- do-while\n- while\n\n  - guarded-do\n\n- for\n\n## switch语句\n\n**跳转表**\n\n# 过程\n\n- 传递控制\n- 传递数据\n- 分配和释放内存\n\n## 运行时栈\n\n![enter image description here](https://123xzy.github.io/2018/03/29/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%882%EF%BC%89/5.jpg)\n\n## 转移控制\n\n保存当前程序地址，将程序计数器设置为新过程地址 返回时读取保存的地址，继续执行\n\n## 数据传送\n\n- 传递函数参数的寄存器\n\n![enter image description here](https://123xzy.github.io/2018/03/29/CSAPP-%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%882%EF%BC%89/6.jpg)\n\n## 栈上的局部存储\n\n## 寄存器中的局部存储空间\n\n- 被调用者保存寄存器\n- 调用者保存寄存器\n\n## 递归过程\n\n# 数组的分配和访问\n\n## 基本原则\n\n```c\nT A[N]\n```\n\n## 指针运算\n\n&D [ i ] [ j ] = X\n\n<sub>D</sub>\n\nL(Ci+j)\n\n## 定长数组\n\n## 变长数组\n\n# 异质的数据结构\n\n都是对地址进行偏移得到的\n\n- 结构\n- 联合\n- 数据对齐\n\n# 在机器级程序中将控制与数据结合起来\n\n## 理解指针\n\n> 在计算机科学中，指针（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向（points to）存在电脑存储器中另一个地方的值\n\n## GDB调试器\n\n> UNIX及UNIX-like下的调试工具\n\n## 内存越界引用和缓冲区溢出\n\n## 对抗缓冲区溢出攻击\n\n- 栈随机化\n- 栈破坏检测\n- 限制可执行代码区域\n\n## 变长帧\n\n# 浮点代码\n\n%ymm0 ~ %ymm15\n\n## 浮点传送和转换操作\n\n![enter image description here](https://img2018.cnblogs.com/blog/1506992/201812/1506992-20181208151239913-42280385.png)\n\n![enter image description here](https://img2018.cnblogs.com/blog/1506992/201812/1506992-20181208151250319-378942177.png)\n\n![enter image description here](https://img2018.cnblogs.com/blog/1506992/201812/1506992-20181208151255477-1132526999.png)\n\n## 过程中的浮点代码\n\n使用XMM寄存器来传递浮点参数\n\n## 浮点运算操作\n\n![enter image description here](https://img2018.cnblogs.com/blog/1506284/201811/1506284-20181123015127972-2142531234.png)\n\n## 定义和使用浮点常数\n\n浮点操作不能把立即数作为操作数\n\n编译器必须为所有浮点常量初始化存储空间\n\n## 在浮点代码中使用位级操作\n\n![enter image description here](https://images2017.cnblogs.com/blog/1249675/201801/1249675-20180128141456459-808811945.jpg)\n\n## 浮点比较操作","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}