{"content":"编写高效程序需要注意的：\n\n- 合适的算法与数据结构\n- 编写出能让编译器转换为高效机器代码的源代码\n\n# 优化编译器的能力和局限性\n\n- 编译器优化级别与安全的优化\n\n_函数内联_\n\n**内存读写带来的开销** **函数调用带来的开销**\n\n# 表示程序性能\n\n每元素周期数(CPE)\n\n_循环展开_ _编译器可以自动进行_\n\n# 消除循环的低效率\n\n- 代码移动\n\n```c\nvoid f1(int a[]){\n\n    int i = length(a);\n    int j;\n    for(j=0;j<i;j++){\n        // DO SOMETHING\n    }\n}\n\nvoid f2(int a[]){\n\n    int j;\n    for(j=0;j< length(a);j++){\n        // DO SOMETHING\n    }\n}\n```\n\n# 减少过程调用\n\n# 消除不必要的内存引用\n\n```c\nvoid sum1(int a[],int n,int *ret){\n    int i=0;\n    for(;i<n;i++){\n        *ret += a[i];\n    }\n}\n\nvoid sum2(int a[],int n,int *ret){\n    int i=0;\n    int tmp=0;\n    for(;i<n;i++){\n        tmp += a[i];\n    }\n    *ret = tmp;\n}\n```\n\n# _理解现代处理器_\n\n## 整体操作\n\n- 分支预测\n\n_寄存器重命名_\n\n## 功能单元的性能\n\n## 处理器操作的抽象模型\n\n# 提高并行性\n\n## 多个累积变量\n\n```c\nvoid sum1(int a[],int n,int *ret){\n    int i=0;\n    int limit = n/2;\n    int tmp1=0;\n    int tmp2=0;\n\n    for(;i<limit;i++){\n        tmp1 += a[i];\n    }\n\n    for(i=limit;i<n;i++){\n\n        tmp2+=a[i];\n    }\n\n    *ret= tmp1 + tmp2;\n}\n```\n\n## 重新结合变换\n\n```c\ntmp = (tmp + a[i]) +a[i+1] // 1\ntmp = tmp + (a[i] +a[i+1]) // 2\n```\n\n# 限制因素\n\n## 寄存器溢出\n\n如果寄存器不够用，将会使用内存存放临时变量，造成性能下降\n\n## 分支预测和预测错误处罚\n\n- 不必过分关心\n- 编写适合用条件传送码实现的代码\n\n# 理解内存性能\n\n- 加载性能\n- 存储性能\n\n# 应用：性能提高技术\n\n- 高级设计：算法与数据结构\n- 基本编码原则\n\n  - 消除连续的函数调用\n  - 消除不必要的内存引用\n\n- 低级优化\n\n  - 展开循环\n  - 多个累积变量与重新结合\n  - 使得编译采用条件数据传送\n\n# 确认和消除性能瓶颈\n\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}