{"content":"# 物理和虚拟寻址\n\n![enter image description here](https://pjmike-1253796536.cos.ap-beijing.myqcloud.com/%E7%89%A9%E7%90%86%E5%AF%BB%E5%9D%80.png)\n\n![enter image description here](https://pjmike-1253796536.cos.ap-beijing.myqcloud.com/%E8%99%9A%E6%8B%9F%E5%AF%BB%E5%9D%80.jpg)\n\n**内存管理单元（MMU）**\n\n# 地址空间\n\n> 非负整数地址的有序集合\n\n- 虚拟地址空间\n- 物理地址空间\n\n# 虚拟内存作为缓存的工具\n\n- 未分配\n- 缓存的\n- 未缓存的\n\n![enter image description here](https://pjmike-1253796536.cos.ap-beijing.myqcloud.com/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98.jpg)\n\n## DRAM缓存的组织结构\n\n_与存储器的层次结构_\n\n## 页表\n\n![enter image description here](https://pjmike-1253796536.cos.ap-beijing.myqcloud.com/%E9%A1%B5%E8%A1%A8.jpg)\n\n## 页命中\n\n系统通过页表获取到物理内存当中的页\n\n## 缺页\n\n> 物理内存缓存不命中成为缺页\n\n## 分配页面\n\n## 局部性原理\n\n> 局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。\n\n# 虚拟内存作为内存管理工具\n\n![enter image description here](https://pjmike-1253796536.cos.ap-beijing.myqcloud.com/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.jpg)\n\n- 简化链接\n- 简化加载\n- 简化共享\n- 简化内存分配\n\n# 虚拟内存作为内存保护的工具\n\n![enter image description here](https://pjmike-1253796536.cos.ap-beijing.myqcloud.com/CSAPP/%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4%E5%B7%A5%E5%85%B7.jpg)\n\n# 地址翻译\n\n![enter image description here](https://images2017.cnblogs.com/blog/1143834/201711/1143834-20171119205319999-116509966.png)\n\n![enter image description here](https://pjmike-1253796536.cos.ap-beijing.myqcloud.com/%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91.png)\n\n- 通过虚拟地址找到页表(page table)中对应的条目\n- 检查有效位(valid bit)，是否需要触发页错误(page fault)\n- 然后根据页表中的物理页编号找到内存中的对应地址\n- 最后把虚拟页偏移和前面的实际地址拼起来，就是最终的物理地址\n\n当页面命中时：\n\n![enter image description here](https://pjmike-1253796536.cos.ap-beijing.myqcloud.com/CSAPP/%E9%A1%B5%E9%9D%A2%E5%91%BD%E4%B8%AD.png)\n\n当缺页时：\n\n![enter image description here](https://pjmike-1253796536.cos.ap-beijing.myqcloud.com/CSAPP/%E7%BC%BA%E9%A1%B5.png)\n\n## 结合高速缓存和虚拟内存\n\n![enter image description here](https://data2.liuin.cn/story-writer/2018_1_31_1517404781626.jpg)\n\n## 利用TLB加速地址翻译\n\n![enter image description here](https://pjmike-1253796536.cos.ap-beijing.myqcloud.com/CSAPP/TLB%E5%91%BD%E4%B8%AD.png)\n\n![enter image description here](https://pjmike-1253796536.cos.ap-beijing.myqcloud.com/CSAPP/TLB%E6%9C%AA%E5%91%BD%E4%B8%AD.png)\n\n## 多级页表\n\n![](https://img2018.cnblogs.com/blog/1521884/201811/1521884-20181110125535159-1010566207.png)\n\n# 内存映射\n\n> 将虚拟内存区域与一个磁盘对象关联起来，以初始化这个虚拟内存区域的内容\n\n- 普通文件\n- 匿名文件\n\n## 共享对象\n\n![](https://upload-images.jianshu.io/upload_images/8195112-fd3d19715bbc6dd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/570/format/webp)\n\n- 写时复制\n\n![](https://upload-images.jianshu.io/upload_images/8195112-8184c849b32b8b4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/722/format/webp)\n\n## 用户级内存映射\n\n```c\nvoid *mmap(void *start,size_t length,int prot,\n    int flags,int fd,off_t offset)\n```\n\n# 动态内存分配\n\n- 显式分配\n\n  程序员手动释放内存\n\n- 隐式分配\n\n  垃圾收集器回收\n\n## malloc与free函数\n\n```c\nvoid *malloc(size_t size);\nvoid free(void *p);\n```\n\n## 使用动态内存分配的原因\n\n- 程序运行的未知性\n\n## 分配器的要求和目标\n\n- 处理任意请求序列\n- 立即响应请求\n- 只使用堆\n- 对齐块\n- 不修改已分配的块\n\n### 目标\n\n- 最大化吞吐率\n- 最大化内存利用率\n\n## 碎片\n\n- 内部碎片\n- 外部碎片\n\n## 实现问题\n\n- 如何记录空闲块\n- 如何选择一个合适的空闲块放置一个新分配的块\n- 如何处理空闲块被分配后剩余的部分\n- 如何处理一个被释放的块\n\n## 隐式空闲链表\n\n![](http://images.cnitblog.com/blog/273314/201312/03215653-7d7dc5d9892d4e20965bf94921f28a96.png)\n\n![](http://images.cnitblog.com/blog/273314/201312/03215926-c7c3c3a7ae6648edba89ae08047cceb5.png)\n\n## 放置已分配的块\n\n- 首次适配\n- 下次适配\n- 最佳适配\n\n## 分割空闲块\n\n> 将空闲块分为两部分，一部分变成分配块，另一部分变成空闲块\n\n## 获取额外的堆内存\n\n## 合并空闲块\n\n_假碎片_\n\n- 块合并\n\n## 带边界标记的合并\n\n![](http://images.cnitblog.com/blog/273314/201312/03222821-394c7311449c4af6b354b586455928a9.png)\n\n## 显式空闲链表\n\n![](https://img-blog.csdnimg.cn/20190115203630741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA3NzIyODk=,size_16,color_FFFFFF,t_70)\n\n## 分离的空闲链表\n\n- 简单分离存储\n- 分离适配\n- 伙伴系统\n\n# 垃圾收集\n\n## 基本知识\n\n![](https://img-blog.csdnimg.cn/20190115203735265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA3NzIyODk=,size_16,color_FFFFFF,t_70)\n\n## 标记-清扫垃圾收集器\n\n![](https://img-blog.csdnimg.cn/20190115203819524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA3NzIyODk=,size_16,color_FFFFFF,t_70)\n\n\n# C程序常见的与内存有关的错误\n\n- 间接引用坏指针\n- 读未初始化的内存\n- 栈缓冲区溢出\n- 假设指针与指针所指向的对象大小相同\n- 错位错误\n- 引用了指针，而不是指针所指的对象\n- 误解指针运算\n- 引用不存在的变量\n- 引用空闲堆块中的数据\n- 内存泄漏\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}