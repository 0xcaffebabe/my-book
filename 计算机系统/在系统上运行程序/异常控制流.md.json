{"content":"# 异常\n\n![enter image description here](https://img-blog.csdn.net/20161128103126532)\n\n## 异常处理\n\n**异常表**\n\n![enter image description here](https://img-blog.csdn.net/20161128103239915)\n\n- 异常处理程序运行在内核模式下\n\n## 异常的类别\n\n![enter image description here](https://img-blog.csdn.net/20161128105219886)\n\n![enter image description here](https://img-blog.csdn.net/20161128103354361)\n\n![enter image description here](https://img-blog.csdn.net/20161128103512777)\n\n![enter image description here](https://img-blog.csdn.net/20161128103543403)\n\n## Linux/X86-64系统中的异常\n\n- 除法错误\n- 一般保护故障\n- 缺页\n- 机器检查\n\n### Linux 中的系统调用\n\n![enter image description here](http://img.wandouip.com/crawler/article/2019221/39e2bc90935349f0994183dbebfa4262)\n\n# 进程\n\n> 一个执行中程序的实例\n\n## 逻辑控制流\n\n![enter image description here](https://www.toolmao.com/wp-content/uploads/2017/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F16.jpg)\n\n## 并发流\n\n> 一个逻辑流的执行在时间上与另一个流重叠\n\n## 私有地址空间\n\n> 进程为每个程序提供一个假象，好像它独占使用了系统的全部内存\n\n![enter image description here](https://root1iu.github.io/2018/12/02/CSAPP-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/7-15.png)\n\n## 用户模式与内核模式\n\n> 寄存器中的一个模式位，设置该模式位可以用来切换用户模式或是内核模式\n\n## 上下文切换\n\n> 内核使用上下文切换来实现多任务\n\n![enter image description here](https://www.toolmao.com/wp-content/uploads/2017/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F10.jpg)\n\n# 系统调用错误处理\n\n包装系统调用进行错误处理\n\n# 进程控制\n\n- 获取进程ID\n\n  ![批注 2019-07-12 103606](/assets/批注%202019-07-12%20103606.png)\n\n- 创建和终止进程\n\n  ```c\n  void exit(int status); // 终止\n    pid_t fork(void); // 创建新子进程\n  ```\n\n- 回收子进程\n\n  ```c\n  pid_t waitpid(pid_t pid,int *statusp,int options);\n  ```\n\n- 让进程休眠\n\n  ```c\n  unsigned int sleep(unsigned int secs);\n    int pause(void);\n  ```\n\n- 加载并运行程序\n\n  ```c\n  execve(cont char *filename,const char *argv[],const char *envp[]); \n  // 使用当前的进程运行新的程序\n  ```\n\n# \n\n## 信号术语\n\n- 发送信号\n\n  - 进程组\n\n    ```c\n    pid_t getpgrp(void);\n    ```\n\n  - 用kill发送信号\n\n    ```shell\n    /bin/kill -9 1235\n    ```\n\n  - 用kill函数发送信号\n\n    ```c\n    int kill(pid_t pid,int sig);\n    ```\n\n  - 用alarm函数\n\n    ```c\n    unigned int alarm(unsigned int secs);\n    ```\n\n- 接收信号\n\n  ```c\n  sighandler_t signal(int signum,sighandler_t handler);\n  ```\n\n- 阻塞信号和解除阻塞信号\n\n  - 隐式阻塞\n  - 显式阻塞\n\n- 编写信号处理程序\n\n  - 安全\n  - 正确\n  - 可移植\n\n- 同步流\n\n- 显式等待信号\n\n# 非本地跳转\n\n> 用户级异常控制流形式\n\n```c\n// 保存当前调用环境，供后面的longjmp调用\nint setjmp(jmp_buf env);\nint sigsetjmp(sigjmp_buf env,int savesigs);\n```\n\n```c\nvoid longjmp(jmp_buf env,int retval);\nvoid siglongjmp(sigjmp_buf env,int retval);\n```\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}