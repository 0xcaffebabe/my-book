{"content":"# rabbitmq\n\n> RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而集群和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。\n\n- 性能非常高\n\n## 对比\n\n![批注 2020-03-12 143412](/assets/批注%202020-03-12%20143412.png)\n\n## 安装\n\n- 安装erlang\n- 安装rabbitmq-server\n\n以上操作均可以使用包管理工具完成\n\n### 使用docker\n\n```shell\ndocker run -d --hostname my-rabbit --name some-rabbit -p 15672:15672 -p 5672:5672 rabbitmq:3-management\n```\n\n## 核心概念\n\n- Server\n- Connection\n- Channel\n  - （信道）：它建立在上述的TCP连接中\n- Message\n- Virtual host\n  - 权限控制的基本单位（类似于数据库中的database），一个VirtualHost里面有若干Exchange和 MessageQueue，以及指定被哪些user使用\n- Exchange\n  - 生产者将消息发送到Exchange（交换机），由Exchange将消息路由到一个 或多个Queue中（或者丢弃）。Exchange并不存储消息\n- Binding\n- Routing key\n  - 生产者在将消息发送给Exchange的时候，一般会指定一个routing key， 来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联 合使用才能最终生效\n- Queue\n  - （队列）是RabbitMQ的内部对象，用于存储消息\n\n## 使用\n\n## JAVA客户端\n\n- 获取连接\n\n```java\nConnectionFactory factory = new ConnectionFactory();\nfactory.setHost(\"192.168.182.129\");\nfactory.setUsername(\"my\");\nfactory.setPassword(\"123\");\nfactory.setPort(5672);\nfactory.setVirtualHost(\"/\");\n\nConnection connection = factory.newConnection();\n```\n\n- 创建队列/绑定队列\n\n```java\nChannel channel = connection.createChannel();\nchannel.queueDeclare(\"queue1\",false,false,false,null);\n```\n\n- 生产者发送消息\n\n```java\nString msg = UUID.randomUUID().toString();\nchannel.basicPublish(\"\",\"queue1\",null,msg.getBytes());\n```\n\n- 消费者监听\n\n```java\nDefaultConsumer consumer = new DefaultConsumer(channel){\n    @Override\n    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n        System.out.println(\"接收到消息:\"+new String(body));\n\n    }\n};\nchannel.basicConsume(\"queue1\",true,consumer);\n```\n\n### SpringBoot\n\n- 引入依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n\n- 配置（生产者、消费者）\n\n```yml\nspring:\n  rabbitmq:\n    addresses: 192.168.182.129\n    username: my\n    password: 123\n    virtual-host: /\n```\n\n- 生产者发送消息\n\n```java\n@Autowired\nprivate RabbitTemplate rabbitTemplate;\n\npublic void sendUser(User user) throws Exception{\n    CorrelationData correlationData = new CorrelationData(user.getUsername());\n    rabbitTemplate.convertAndSend(\"user-exchange\",\"user.abcd\",user,correlationData);\n}\n```\n\n- 消费端配置\n\n```properties\nspring.rabbitmq.listener.simple.concurrency=5\nspring.rabbitmq.listener.simple.acknowledge-mode=auto\nspring.rabbitmq.listener.simple.max-concurrency=10\nspring.rabbitmq.listener.simple.prefetch=1\n```\n\n- 消费\n\n```java\n@RabbitListener(bindings = @QueueBinding(\n        value = @Queue(value = \"user-queue\"),\n        exchange = @Exchange(name = \"user-exchange\",type = \"topic\"),\n        key = \"user.#\"\n))\n@RabbitHandler\npublic void onMessage(@Payload User user){\n    // 当这里抛出异常，会自动进行重试\n    log.info(\"on message:{}\",user);\n}\n```\n\n## 消息模型\n\n### 点对点\n\n![批注 2020-03-12 151023](/assets/批注%202020-03-12%20151023.png)\n\n当有多个消费端时，mq会把消息公平分发到每个消费端（轮询）\n\n### 工作队列\n\n![](https://www.rabbitmq.com/img/tutorials/python-two.png)\n\n消息转发机制是平均分配，这样就会出现俩个消费者，由于每个消费者处理任务的效率不一，可以通过设置qos的方式来决定消费者的消费能力，从而达到资源的充分利用\n\n```java\nchannel.basicQos(1);\n```\n\n手动ack后的消费端，mq会继续发消息给它，这样就能达到消费速度更快的客户端消费更多数据\n\n### 订阅模型-Fanout\n\nFanout exchange（扇型交换机）将消息路由给绑定到它身上的所有队列\n\n![批注 2020-03-12 181837](/assets/批注%202020-03-12%20181837.png)\n\n- 生产者\n\n```java\nString exchangeName = \"exchange1\";\nchannel.exchangeDeclare(exchangeName,\"fanout\");\nString msg = UUID.randomUUID().toString();\nchannel.basicPublish(exchangeName,\"\",null,msg.getBytes());\n```\n\n- 消费者\n\n端a\n\n```java\nString queueName = \"queue1\";\nString exchangeName = \"exchange1\";\nchannel.queueDeclare(queueName, false, false, false, null);\nchannel.queueBind(queueName, exchangeName, \"\");\nDefaultConsumer consumer = new DefaultConsumer(channel) {\n    @Override\n    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n        System.out.println(\"消费者接收到消息:\" + new String(body));\n    }\n};\nchannel.basicConsume(queueName,true,consumer);\n```\n\n端b\n\n```java\n...\nString queueName = \"queue2\";\n...\n```\n\n### 订阅模型-Direct\n\nDirect exchange（直连交换机）是根据消息携带的路由键（routing key）将消息投递给对应队列\n\n![20203121903](/assets/20203121903.png)\n\n- 生产端\n\n```java\n...\nchannel.basicPublish(exchangeName,\"routing_key\",null,msg.getBytes());\n```\n\n- 消费端\n\n```java\n...\nchannel.queueBind(queueName, exchangeName, \"routing_key\");\n...\n```\n\n### 订阅模型-Topic\n\nTopic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符\n\n![202031311031](/assets/202031311031.png)\n\n端a\n\n```java\nchannel.queueBind(queueName, exchangeName, \"#.sms\");\n```\n\n端b\n\n```java\nchannel.queueBind(queueName, exchangeName, \"#.email\");\n```\n\n当生产者的routingKey为log.sms时，消息会发送到端a\n\n- `#` 可以匹配一个或多个词\n- `*`只能匹配一个词\n\n## 消息确认机制（ACK）\n\nACK：消费者通知RabbitMQ消息已经接收并且处理完毕了。RabbitMQ就可以删除该条消息了\n\n- 自动ACK：消息一旦被接收，消费者自动发送ACK\n- 手动ACK：消息接收后，不会发送ACK，需要手动调用\n\n```java\nDefaultConsumer consumer = new DefaultConsumer(channel){\n    @Override\n    public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n        System.out.println(\"接收到消息:\"+new String(body));\n        channel.basicAck(envelope.getDeliveryTag(),false);\n    }\n};\nchannel.basicConsume(\"queue1\",false,consumer);\n```\n\n### 事务\n\n```java\ntry{\n    channel.txSelect();\n    String msg = UUID.randomUUID().toString();\n    channel.basicPublish(exchangeName,\"log.email\",null,msg.getBytes());\n    channel.txCommit();\n}catch (Exception e){\n    channel.txRollback();\n}\n```\n\n## 保证幂等性\n\n当引入异常重试机制时，如何保证同一条消息不被重复消费\n\n- 重试配置\n\n```yml\nspring:\n  rabbitmq:\n    listener:\n      simple:\n        retry:\n          initial-interval: 100ms\n          enabled: true\n          max-attempts: 3\n```\n\n解决这个问题，需要根据业务的具体情况来分析，可以：\n\n- 全局消息ID\n- redis的天然幂等性\n- 数据库的唯一约束\n\n### 全局消息ID\n\n当消费者处理完一条消息之后，将这个消息ID记录下来，当一条新消息到来之后，要判断是否记录过这条消息的ID，如果是，不再继续往下处理\n\n## 死信队列\n\n当由于一些诸如队列满或者消息被拒绝等原因，这些消息将被移入到一个备胎队列，死信队列就是专门用来存放这些消息的队列\n\n### 普通队列绑定私信队列\n\n```java\nMap<String, Object> args = new HashMap<>(2);\n// 死信队列交换机与死信队列路由键\nargs.put(\"deadExchangeName\", deadExchangeName);\nargs.put(\"deadRoutingKey\", deadRoutingKey);\nQueue queue = new Queue(\"user_queue\", true, false, false, args);\n```\n\n## 高可用\n\n- 镜像集群模式\n\n创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上\n\n![批注 2020-03-18 194849](/assets/批注%202020-03-18%20194849.png)\n\n## 顺序性\n\n当多个consumer同时消费一个queue时，很有可能造成消费的顺序和存入的顺序不一致，解决方法是：\n拆分多个 queue，每个 queue 一个 consumer","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}