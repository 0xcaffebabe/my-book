{"content":"# ActiveMQ\n\n## 使用\n\n- 初始化\n\n```java\n// 创建连接\nConnectionFactory connectionFactory = new ActiveMQConnectionFactory(url);\nConnection connection = connectionFactory.createConnection();\nconnection.start();\n// 创建会话 自动确认消息\nSession session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);\n// 创建目的\nDestination destination = session.createQueue(queueName);\n```\n\n## 队列模式\n\n### 生产消息\n\n```java\nMessageProducer producer = session.createProducer(destination);\n\nfor (int i = 0; i < 100; i++) {\n    TextMessage textMessage = session.createTextMessage();\n    textMessage.setText(\"text\"+i);\n    producer.send(textMessage);\n}\n```\n\n### 消费消息\n\n- 使用消息监听器\n\n```java\nMessageConsumer consumer = session.createConsumer(destination);\n\nconsumer.setMessageListener(new MessageListener() {\n    public void onMessage(Message message) {\n        System.out.println(message);\n    }\n});\n```\n\n- 同步消费消息模式\n\n```java\nActiveMQTextMessage msg = (ActiveMQTextMessage) consumer.receive();\nSystem.out.println(msg);\n```\n\n#### 队列模式\n\n```java\ndestination = session.createQueue(sourceQueue);\n```\n\n> 在队列模式下，消费者会平均消费生产者生产的消息\n\n#### 主题模式\n\n```java\nDestination destination = session.createTopic(topicName);\n```\n\n> 主题模式也被称为订阅通知模式，订阅之后才能收到消息 生产者生产消息会推送给所有消费者\n\n## 消息持久化\n\n- PERSISTENT：指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失\n- NON_PERSISTENT:不要求JMS provider持久保存消息\n\n```java\nproducer.setDeliveryMode(DeliveryMode.PERSISTENT);\n```\n\n## 可靠数据传输\n\nJMS消息只有在被确认之后，才认为已经被成功的消费了\n\n- Session.AUTO_ACKNOWLEDGE：当客户成功的从receive方法返回的时候，或者从MessageListener.onMessage方法成功返回的时候，会话自动确认客户收到的消息\n- Session.CLIENT_ACKNOWLEDGE:客户通过调用消息的acknowledge方法确认消息\n- Session.DUPS_ACKNOWLEDGE:该选择只是会话迟钝的确认消息的提交\n\n## 集成Spring JMS\n\n- 配置\n\n```java\n@Bean\npublic ConnectionFactory connectionFactory(){\n    return new ActiveMQConnectionFactory(\"tcp://127.0.0.1:61616\");\n}\n\n@Bean\npublic Destination destination(){\n    return new ActiveMQQueue(\"queue\");\n}\n\n@Bean\npublic JmsTemplate jmsTemplate(ConnectionFactory connectionFactory){\n    return new JmsTemplate(connectionFactory);\n}\n```\n\n- 使用\n\n```java\njmsTemplate.send(destination,new MessageCreator() {\n    public Message createMessage(Session session) throws JMSException {\n        TextMessage msg = session.createTextMessage();\n        msg.setText(message);\n        return msg;\n    }\n});\n```\n\n- 配置消费者\n\n```java\n@Bean\npublic MessageListener messageListener(){\n    return new ConsumerMessageListener();\n}\n\n@Bean\npublic DefaultMessageListenerContainer \ndefaultMessageListenerContainer(Destination destination,\n                                ConnectionFactory connectionFactory,\n                                MessageListener messageListener){\n\n    DefaultMessageListenerContainer container = new DefaultMessageListenerContainer();\n    container.setConnectionFactory(connectionFactory);\n    container.setMessageListener(messageListener);\n    container.setDestination(destination);\n    return container;\n}\n```\n\n## SpringBoot整合\n\n- 依赖\n\n```xml\n<dependency>\n\t<groupId>org.springframework.boot</groupId>\n\t<artifactId>spring-boot-starter-activemq</artifactId>\n</dependency>\n```\n\n- 配置\n\n```yml\nspring:\n  activemq:\n    broker-url: tcp://127.0.0.1:61616\n    user: admin\n    password: admin\nqueue: myQueue\n```\n\n```java\n@Value(\"${queue}\")\nprivate String queueName;\n\n@Bean\npublic Queue queue(){\n    return new ActiveMQQueue(queueName);\n}\n```\n\n- 使用\n\n生产者\n\n```java\n@Component\npublic class Producer {\n\n    @Autowired\n    private JmsMessagingTemplate template;\n\n    @Autowired\n    private Queue queue;\n\n    @Scheduled(fixedDelay = 5000)\n    public void send() {\n        String payload = UUID.randomUUID().toString();\n        System.out.println(\"producer send:\" + payload);\n        template.convertAndSend(queue, payload);\n    }\n}\n```\n\n消费者\n\n```java\n@Component\npublic class Consumer {\n\n    @JmsListener(destination = \"myQueue\")\n    public void receive(String msg){\n        System.out.println(\"consumer receive:\"+msg);\n    }\n}\n```\n\n## 集群\n\n- 高可用\n- 负载均衡\n\n### 集群方式\n\n- 客户端集群\n- Broker集群\n- Master Slave\n\n## 企业开发需要解决的问题\n\n\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}