{"content":"## 持久化\n\n通用持久化方案：\n\n- 快照\n- 日志\n\n不要只使用某一持久化机制\n\n要充分利用两种持久化机制的优点并避免它们的缺点\n\n### RDB\n\n将某个时间点的所有数据都存放到硬盘上, 是对 redis 中的数据执行周期性的持久化\n\n`bgsave`命令：使用的fork系统调用创建一个子进程来持久化数据, 由于fork出来的子进程是写时复制，所以这达到了一个性能的平衡\n\n![屏幕截图 2020-09-29 132917](/assets/屏幕截图%202020-09-29%20132917.png)\n\n可以在redis-cli执行config set dir{newDir}和config set\ndbfilename{newFileName} 来改变持久化文件位置\n\n- 配置文件\n\n> after 60 sec if at least 10000 keys changed save 60 10000\n\n默认开启，保存在dump.rdb\n\n```shell\nsave 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。\n\nsave 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。\n\nsave 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。\n```\n\n**优缺点**\n\n- 是某个时刻的全部数据，非常适合做冷备 全量备份等\n- 恢复比较迅速\n- **bgsave每次运行都要执行fork操作创建子进程，属于重量级操作**\n- **会丢失一定数据**\n\n### AOF\n\n- 以日志的形式保存每次操作\n- 对每条写入命令作为日志\n\n![屏幕截图 2020-09-29 133711](/assets/屏幕截图%202020-09-29%20133711.png)\n\n为什么使用AOF缓冲：Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载\n载\n\n```\nappendonly yes 开启aof\n\nappendfsync always    每一次操作都进行持久化 （每次写操作都执行fsync 性能极差）\nappendfsync everysec  每隔一秒进行一次持久化 (折中的方案)\nappendfsync no        让操作系统来决定何时同步 （让操作系统决定何时写到磁盘 数据不安全）\n```\n\nRedis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。\n\n如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点\n\n**优缺点**\n\n- 更好地保护数据不丢失\n- append-only没有磁盘寻址开销\n- 适合做灾备\n- **aof文件比rdb大**\n- **aof对性能有一定的影响**\n\n#### AOF重写\n\n随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的\n\n- 手动触发：bgrewriteaof\n- 自动触发：根据auto-aof-rewrite-min-sizeauto-aof-rewrite-percentage参数确定自动触发时机\n\n![屏幕截图 2020-09-29 135550](/assets/屏幕截图%202020-09-29%20135550.png)\n\n执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。\n\n当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致\n\n#### 重启恢复流程\n\n![屏幕截图 2020-09-29 135820](/assets/屏幕截图%202020-09-29%20135820.png)\n\n如果aof文件损坏 可以尝试使用redis-check-aof --fix进行修复\n\n### 问题定位与优化\n\nfork的问题：\n\n- 重量级操作 如果使用虚拟化技术 fork会比物理机更耗时\n- fork虽然是写时复制 但是还是需要复制内存页表\n\n持久化时各类资源的消耗：\n\n- CPU：子进程负责把进程内的数据分批写入文件，这个过程\n属于CPU密集操作\n- 内存：子进程通过fork操作产生，占用内存大小等同于父进程，理论上需要两倍的内存来完成持久化操作，但Linux有写时复制机制\n（copy-on-write）\n- 磁盘：写入时硬盘压力很大 避免将redis和其他高硬盘负载的服务部署在一起\n\nAOFfsync策略：\n\n![屏幕截图 2020-09-29 142515](/assets/屏幕截图%202020-09-29%20142515.png)\n\n使用everysec这种同步策略 当一个命令写入缓冲区后发现上次同步到磁盘的时间大于2秒 就会阻塞住 直至同步磁盘完成\n\n这意味着使用这种策略至多会丢失2秒的数据","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}