{"content":"## 客户端\n\n### RESP(redis 序列化协议)\n\n- 发送命令\n\n```\n*< 参数数量 > CRLF\n$< 参数 1 的字节数量 > CRLF\n< 参数 1> CRLF\n...\n$< 参数 N 的字节数量 > CRLF\n< 参数 N> CRLF\n```\n\n- 返回结果\n\n状态回复：在RESP中第一个字节为\"+\"。\n\n错误回复：在RESP中第一个字节为\"-\"。\n\n整数回复：在RESP中第一个字节为\"：\"。\n\n字符串回复：在RESP中第一个字节为\"$\"。\n\n多条字符串回复：在RESP中第一个字节为\"*\"。\n\n###  java 客户端 Jedis\n\n基本使用\n\n```java\nJedis jedis = new Jedis(\"127.0.0.1\");\n\njedis.set(\"name\",\"my\");\nSystem.out.println(jedis.get(\"name\"));\njedis.close();\n```\n\n连接池\n\n```java\nJedisPoolConfig config = new JedisPoolConfig();\nconfig.setMaxIdle(15);\nconfig.setMaxTotal(30);\n\nJedisPool pool = new JedisPool(config);\n\nJedis resource = pool.getResource();\nSystem.out.println(resource.ping());\nresource.close();\n\npool.close();\n```\n\n### Spring Data Redis\n\nRedisTemplate基本操作\n\n- redisTemplate.opsForValue() ：操作字符串\n- redisTemplate.opsForHash() ：操作hash\n- redisTemplate.opsForList()：操作list\n- redisTemplate.opsForSet()：操作set\n- redisTemplate.opsForZSet()：操作zset\n\nStringRedisTemplate是K,V均为String的RedisTemplate\n\n使用\n\n```java\ntemplate.opsForValue().set(\"name\",\"hello,bitch\");\n```\n\n### 事务\n\n```sh\nmulti # 开启事务\nset name hello\nset hello world\nexec # 提交事务\n# discard 停止事务执行\n```\n\n命令语法错误导致的错误整个事务会回滚\n\n```sh\nset key java\nwatch key\nmulti\nset key cxk\nexec # 如果key在这个事务过程中别其他客户端修改 这个事务就不会执行\n```\n\n```java\n// 开启事务支持\ntemplate.setEnableTransactionSupport(true);\ntry{\n    // begin\n    template.multi();\n    // 事务中的多个命令被一次性发送给服务器\n    template.opsForValue().set(\"java\",\"langeuage\");\n    template.opsForValue().set(\"python\",\"langeuage\");\n    // commit\n    template.exec();    \n}catch (Exception e){\n    template.discard();\n}\n```\n\n### 客户端管理\n\n```sh\nclient list\n```\n```\nid=10733 addr=127.0.0.1:42158 fd=9 name= age=84021 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client user=default\n```\n\n![屏幕截图 2020-09-28 153101](/assets/屏幕截图%202020-09-28%20153101.png)\n\n标识：\n\n- id\n- addr\n- fd\n- name\n\n输入缓冲区：\n\nRedis为每个客户端分配了输入缓冲区，它的作用是将客户端发送的命令临时保存，同时Redis从会输入缓冲区拉取命令并执行\n\n- qbuf 缓冲区的总容量\n- qbuf-free 剩余容量\n\n如果Redis的处理速度跟不上输入缓冲区的输入速度 机会造成缓冲区十分大\n\n输出缓冲区：\n\nRedis为每个客户端分配了输出缓冲区，它的作用是保存命令执行的结果返回给客户端\n\n输出缓冲区由两部分组成：固定缓冲区（16KB）和动态缓冲区，其中固定缓冲区返回比较小的执行结果，而动态缓冲区返回比较大的结果。 固定缓冲区使用的是字节数组，动态缓冲区使用的是列表\n\n- obl 固定缓冲区的长度\n- oll 动态缓冲区列表的长度\n- omem 代表使用的字节数\n\n客户端存活状态：\n\n单位为秒\n\n- age 客户端已经连接的时间\n- idle 最近一次的空闲时间\n\n客户端类型：\n\n- flag\n\n![屏幕截图 2020-09-28 152911](/assets/屏幕截图%202020-09-28%20152911.png)\n\n#### setName getName\n\n设置名称方便管理\n\n```sh\nclient setName cxk\nclient getName\n```\n\n#### 杀掉客户\n\n```sh\nclient kill ip:port\n```\n\n#### 阻塞客户\n\n```sh\nclient pause timeout # 阻塞当前客户端指定毫秒数\n```\n\n#### 监控客户端命令执行\n\n```sh\nmonitor\n```\n\n### 客户端相关配置\n\n- timeout 检测客户端空闲连接的超时时间，一旦idle时间达到了\ntimeout，客户端将会被关闭，如果设置为0就不进行检测\n- maxclients 客户端最大连接数\n- tcp-keepalive 检测TCP连接活性的周期\n- tcp-backlog TCP三次握手后，会将接受的连接放入队列中，tcp-backlog就是队列的大小\n\n### 客户端统计\n\n```sh\ninfo clients\n```\n\n- connected_clients：代表当前Redis节点的客户端连接数\n- client_recent_max_input_buffer：当前所有输出缓冲区中队列对象个数的最大值\n- client_recent_max_output_buffer: 前所有输入缓冲区中占用的最大容量\n- locked_clients：正在执行阻塞命令（例如blpop、brpop、brpoplpush）的客户端个数","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}