{"content":"## API\n\n### 通用\n\n- keys * : 查看所有的键(生产环境应禁用，原因：正则表达式可能会占用大量资源)\n- dbsize 返回当前数据库中建的总数\n- type key ： 获取键对应的value的类型\n- del key：删除指定的key(可以是多个)\n- exists key：判断指定的key是否存在\n- expire key time：指定key的生存时间，单位：秒\n- ttl key 查看键的剩余过期时间\n\n### 字符串类型\n\n![屏幕截图 2020-09-26 145223](/assets/屏幕截图%202020-09-26%20145223.png)\n\n```sh\nset key value [ex seconds] [px milliseconds] [nx|xx] # 设置值\n# ex 以秒为单位的过期时间\n# px 毫秒单位的过期时间\n# nx：set if not exists\n# xx set if exists\nget key # 获取值\n\nmset name cxk age 18 # 批量设置值\nmget name age # 批量获取值\n\nincr a # 自增1\nincrby a 15 # 自增指定值\ndecrby a 15 # 自减指定值\nincrbyfloat a 10.5 # 自增浮点数\n\nappend name jntm # 字符串追加值\nstrlen name # 获取字符串长度\nset name 蔡徐坤\nstrlen name # redis将中文序列化为byte数组 中文的长度取决于终端的编码集\ngetset name world # 设置新值并返回旧值\nsetrange name 2 kd # 从指定位置设置字符串\ngetrange name 0 -1 # 获取指定范围的字符串\n```\n\n![屏幕截图 2020-09-24 143108](/assets/屏幕截图%202020-09-24%20143108.png)\n\n- 在redis中 自增操作都是原子的 不用担心被别的客户端修改\n\n#### bitmap\n\n这个数据类型适合用来处理海量数据\n\n```sh\nsetbit map 5 1 # 将偏移量为5的bit设置为1 在第一次初始化Bitmaps时，假如偏移量非常大，那么整个初始化过程执行会比较慢，可能会造成Redis的阻塞\ngetbit map 5 # 获取偏移量为5的值\nbitcount map 0 -1 # 获取指定范围内1的个数\nbitop and|or|not|xor ret map map1 # bitmap 集合运算\nbitpos map 1 # bitmap 第一个值为1的bit的偏移量\n```\n\n例子：\n\n统计某个时间窗口内的登录天数\n\n```sh\nsetbit cxk 1 1 # 第一天登录\nsetbit cxk 364 1 # 第364天登录\nbitcount cxk 0 10 # 0 - 10天这个时间窗口登录了几天\n```\n\n统计某个时间窗口活跃用户数\n\n```sh\nsetbit 200618 1 1 # 18号1号用户登录\nsetbit 200619 1 1 # 19号1号用户登录\nsetbit 200619 7 1 # 19号7号用户登录\nbitop or ret 200618 200619 # 使用或运算合并bit\nbitcount ret 0 0 # 统计有多少位1\n```\n\n#### HyperLogLog\n\n通过HyperLogLog可以利用极小的内存空间完成大量元素的独立总数的统计\n\n用小空间来估算如此巨大的数据，其中一定存在误差率（类似于布隆过滤器）\n\n使用这个来估算数据 可以容忍一定的误差率\n\n```sh\npfadd users user1 user2 user3 user4 # 添加元素\npfcount users # 统计个数\n```\n\n### 哈希类型\n\n![屏幕截图 2020-09-26 145321](/assets/屏幕截图%202020-09-26%20145321.png)\n\n```sh\nhset user:1 name cxk age 18 # 设置field\nhsetnx user:1 name cxk # set if not exists\nhget user:1 name # 获取field\nhdel user:1 name age # 删除field\nhlen user:1 # 计算field个数\nhmget user:1 name age # 批量获取field\nhexists user:1 name # 判断field是否存在\nhkeys user:1 # 获取所有field名称\nhvals user:1 # 获取所有field value\nhgetall user:1 # 获取全部kv对\nhincrby user:1 age 1 # 对指定field自增\nhincrbyfloat user:1 age 1.5 # 浮点数自增\n```\n\n内部编码：\n\n- ziplist 压缩列表 这种类型使用更加紧凑的结构实现多个元素的连续存储 **节省内存**\n- hashtable 读写效率比ziplist高\n\n使用场景：\n\n- 哈希类型是稀疏的，而关系型数据库是完全结构化的，哈希类型每个键可以有不同的field，而关系型数据库一旦添加新的列，所有行都要为其设置值\n- 关系型数据库可以做复杂的关系查询，而Redis去模拟关系型复杂查询开发困难\n\n### 列表类型\n\n![屏幕截图 2020-09-26 145350](/assets/屏幕截图%202020-09-26%20145350.png)\n\n- 将元素加入列表左边：`lpush key value`\n- 将元素加入列表右边：`rpush key value`\n- 元素插入：`linsert key before|after pivot value`\n- 范围获取：`lrange key start end`\n- 获取指定下标：`lindex key i`\n- 获取列表长度:`llen key`\n- 删除列表最左边的元素，并将元素返回:`lpop key`\n- 删除列表最右边的元素，并将元素返回:`rpop key`\n- 删除指定元素\n  - 从左到右 最多删除一个：`lrem list 1 java`\n  - 从右到左 最多删除一个：`lrem list -1 java`\n  - 删除全部：`lrem list 0 java`\n- 索引范围内的元素：`ltrim list 0 1`\n- 修改指定下标的元素：`lset list 0 java`\n- 阻塞操作\n  - 3秒内获取不到就返回:`brpop list 3`\n\n内部编码：\n\n- ziplist\n- linkedlist\n- quicklist 结合了ziplist和linkedlist两者的优势\n\n使用场景：\n\n- 消息队列 户端使用lrpush从列表左侧插入元素 多个消费者客户端使用brpop命令阻塞式的“抢”\n\n![屏幕截图 2020-09-24 153949](/assets/屏幕截图%202020-09-24%20153949.png)\n\n- 分页列表 使用lrange实现\n\n其他：\n\n·lpush+lpop=Stack\n·lpush+rpop=Queue\n·lpsh+ltrim=Capped Collection\n·lpush+brpop=Message Queue\n\n### 集合类型\n\n![屏幕截图 2020-09-26 145411](/assets/屏幕截图%202020-09-26%20145411.png)\n\n```sh\nsadd set a b c # 添加元素\nsrem set b # 删除元素\nscard set # 计算元素个数(维护一个变量得到)\nsismember set c # 判断元素是否在集合内\nsrandmember set 2 # 随机从集合返回指定个数元素\n# 正数：取出一个去重的结果集（不能超过已有集）\n# 负数：取出一个带重复的结果集，一定满足你要的数量\n# 如果：0，不返回\nspop set 1 # 随机弹出元素\nsmembers set # 获取所有元素\n\nsinter s1 s2 # 求交集\nsunion s1 s2 # 求并集\nsdiff s1 s2 # 求差集\nsinterstore s3 s1 s2 # 交集结果存储到s3\n# ...\n```\n\n内部编码：\n\n- intset 占用内存小\n- hashtable\n\n例子：用户标签\n\n```sh\nsadd user1 food movie sport music\nsadd user2 food music network\nsinter user1 user2 # 计算用户共同感兴趣的标签\n```\n\n例子：抽奖\n\n```sh\nsadd k 1 2 3 4 5 6 7 8 9 # 9个用户\nSRANDMEMBER k 3 # 抽取三个不重复用户\nSRANDMEMBER k -3 # 抽取三个可能会重复的用户\n```\n\n- sadd=Tagging（标签）\n- spop/srandmember=Random item（生成随机数，比如抽奖）\n- sadd+sinter=Social Graph（社交需求）\n\n### 有序集合类型\n\n![屏幕截图 2020-09-26 145503](/assets/屏幕截图%202020-09-26%20145503.png)\n\n```sh\nhelp @sorted_set\n```\n\n![批注 2020-06-19 113509](/assets/批注%202020-06-19%20113509.png)\n\n物理内存左小右大\n\n```sh\nzadd users 251 tom # 添加成员 分数251\nzcard users # 计算成员个数\nzscore users tom # 获取某个成员分数\nzrank users tom # 计算某个成员排名\nzrem users tom # 删除成员\nzincrby users 8 jerry # 增加某个成员的分数\nzrange users 0 10 # 正序返回指定排名范围的成员\nzrevrange users 0 10 # 倒序返回指定排名范围的成员\nzrangebyscore users 0 255 # 正序返回指定分数范围的成员\nzrevrangebyscore users 0 255 # 正序返回指定分数范围的成员\nzcount users 0 255 # 计算指定分数范围的成员个数\nzremrangebyrank users 0 1 # 删除指定排名范围内的成员\nzremrangebyscore users 0 10 # 删除指定分数范围内的成员\n\nzinterstore user:ranking:1_inter_2 2 user:ranking:1 user:ranking:2 weights 1 0.5 aggregate max # 并集\n```\n\n内部数据结构：\n\n- ziplist\n- skiplist\n\n例子：点赞\n\n```sh\nzadd video 0 cxk # cxk发布了一个视频 0赞\nzincrby video 1 cxk # 有人给cxk视频点了一个赞\nzrem video cxk # 清空cxk的视频点赞\nzrevrange video 0 9 # 获取点赞排行榜\n```\n\n### 键管理\n\n单键管理：\n\n```sh\nrename name newname # 键重命名\nrandomkey # 随机返回数据库里的一个键\nexpire name 10 # 设置键10秒后过期\nexpireat name timestamp # 设置键在指定时间戳后过期\n# 对于字符串 set 会清除其过期时间\n# Redis不支持二级数据结构（例如哈希、列表）内部元素的过期功能\npersist name # 去除键的过期时间\n```\n\n键迁移：\n\n- move 同一redis内\n- dump restre 通过RDB文件的方式\n- migrate 自动通过网络传输数据\n\n遍历键：\n\n```sh\nkeys * # 获取所有键 如果Redis包含了大量的键，执行keys命令很可能会造成Redis阻塞\nscan 0 # 渐进式遍历 该命令返回两个部分：1. 下一个游标 2. 遍历结果\n# 如果要继续遍历 下一次scan后面接的就是返回的游标\n```\n\n数据库管理：\n\n```sh\nselect 2 # 切换到2号数据库\nflushdb # 清空数据库 如果当前数据库键值数量比较多，flushdb/flushall存在阻塞Redis的可能\nflushall\n```\n\nRedis3.0后已经逐渐弱化多数据库这个功能","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}