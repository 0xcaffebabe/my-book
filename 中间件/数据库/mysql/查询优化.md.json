{"content":"# 查询优化\n\n## 查询慢的原因\n\n网络 CPU IO 上下文切换 系统调用 生成统计信息 锁等待\n\n## 优化数据访问\n\n查询性能低下的主要原因是访问的数据太多 需要避免检索、传输大量数据\n\n### 访问了太多行和列\n\n如果是由于访问太多行，则首先应避免写出这种SQL，MySQL会直接返回客户端所查询的全部数据，所以可以使用LIMIT来进行限制\n\n访问了太多的列，则应该审视是否真的需要这些列，其次可以通过覆盖索引扫描的方式来进行优化。\n\n### MySQL扫描了过多的数据行\n\n通过检查慢日志记录可以找出扫描行数过多的查询。\n\n也可以通过EXPLAIN语句列出结果rows属性，理想情况下扫描的行和返回的行数量一致。\n\n如果要对扫描行数与返回行数量相差较多的查询进行优化，主要可以通过\n\n1. 覆盖索引扫描的方式\n2. 改变表结构 使用单独的汇总表之类的\n3. 重写掉这个复杂的查询\n\n## 重构查询\n\n对于一些操作数据量大的SQL，如果可以将其拆分成几个小SQL，在应用层进行处理，那可以把服务器的压力分摊到各个时间点中。\n\n如可以对一些关联查询进行分解：\n\n1. 可以利用缓存\n2. 降低锁争用\n3. 应用层处理拥有较高的可扩展性\n4. ...\n\n## 执行过程优化\n\n![屏幕截图 2021-03-16 152127](/assets/屏幕截图%202021-03-16%20152127.png)\n\n### 查询优化处理\n\n- 计算的依据\n\n每个表或者索引的页面个数\n索引的基数\n索引和数据行的长度\n索引的分布情况\n\n很多情况下mysql会选择错误的执行计划\n\n- 优化策略\n  - 静态优化 直接对解析树进行分析，并完成优化\n  - 动态优化 动态优化与查询的上下文有关，也可能跟取值、索引对应的行数有关\n\n- 优化类型\n  - 重新定义关联表的顺序\n  - 将外连接转化成内连接，内连接的效率要高于外连接\n  - 使用等价变换规则，mysql可以使用一些等价变化来简化并规划表达式\n  - 优化count(),min(),max()\n  - 预估并转化为常数表达式，当mysql检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行处理\n  - 索引覆盖扫描，当索引中的列包含所有查询中需要使用的列的时候，可以使用覆盖索引\n  - 子查询优化\n  - 等值传播\n\n- 排序优化\n\n- 优化特定类型查询\n  - count 查询\n    - 只有没有任何where条件的count(*)才是比较快的\n    - 不需要完全精确的值，可以参考使用近似值来代替，比如可以使用explain来获取近似的值\n    - 实际操作的时候可以考虑使用索引覆盖扫描，或者增加汇总表，或者增加外部缓存系统\n  - 关联查询\n    - 确保on或者using子句中的列上有索引\n    - 确保任何的groupby和order by中的表达式只涉及到一个表中的列\n  - 子查询优化\n    - 使用关联查询替代\n  - limit 分页优化\n    - 优化此类查询的最简单的办法就是尽可能地使用覆盖索引，而不是查询所有的列\n  - 优化union查询\n    - 除非确实需要服务器消除重复的行，否则一定要使用union all\n  - 使用用户自定义变量\n\n## 使用索引\n\n索引的原理：\n\n![屏幕截图 2020-08-27 093235](/assets/屏幕截图%202020-08-27%20093235.png)\n\nMySQL 使用索引的方式：\n\n- WHERE ORDER BY GROUP PY子句\n- 对于使用MIN MAX函数的查询直接使用索引就可完成\n- 对于某些查询 只使用索引的数据就可返回 无需回表查询\n\n索引的代价：\n\n- 降低了大部分写操作的速度\n- 占用磁盘空间\n\n挑选索引：\n\n- 用于搜索 排序 分组的列\n- 列的基数(列的值不重复的个数)越高 索引效果越好\n- 索引尽量选择较小的数据类型\n  - IO 操作更快\n  - 降低存储空间需求 可以在缓存中缓存更多数据 加快速度\n- 字符串索引指定前缀长度\n  - 大多数字符串前n个字符就足以是唯一的 当成索引\n- 最左索引\n  - 对于(a,b,c)这种类型的复合索引 利用其排列顺序进行操作 能有效利用索引\n- 不要过多的索引\n- 保持参与比较的索引类型匹配\n  - 散列 B+树\n\n## 查询优化程序\n\n```sql\nEXPLAIN SELECT * FROM person WHERE FALSE\n```\n\n有助于优化程序对索引充分利用：\n\n- 分析表 `ANALYZE TABLE`\n  - 生成键值分析\n- 使用 EXPLAIN 验证哪些索引会被使用到\n- 必要时给予 EXPLAIN提示\n  - 表名后面加上`FORE INDEX, USE INDEX, IGNORE INDEX`\n  - `STRAIGHT_JOIN`要求按特定顺序使用表\n- 比较的列数据类型相同\n- 索引列不要参与运算\n- LIKE 语句开始位置不要使用通配符\n- 将子查询转换为连接\n- 尝试查收的各种替代形式\n- 避免过多类型的自动转换\n\n## 数据类型高效查询\n\n- 多用数字运算 少用字符串运算\n  - ENUM SET\n- 优先使用较小数据类型\n  - 加快操作速度\n  - 节省存储空间\n- 数据列声明NOT NULL\n  - 避免 MySQL 运行时检查 NULL\n- 考虑使用ENUM\n- 输出MySQL对数据类型的建议\n  - `SELECT * FROM tb PROCEDURE ANALYSE()`\n- 整理表碎片\n  - `OPTIMIZE TABLE tb`\n  - 某些存储引擎不支持 使用mysqldump导出再导入来整理\n- 使用BLOB TEXT存储非结构化数据\n  - 注意删除更新时留下的碎片\n  - 避免过大\n  - 抽离到一张独立的表\n- 合成索引\n  - 计算一个散列值存放到一个列\n\n## 表存储格式高效查询\n\nMyISAM:\n\n- 默认使用固定长度的行\n  - 当某个列长度可变时 则行也会变成可变\n  - 固定长度的行比变长行处理速度比较快\n\nMEMORY:\n\n- 使用都是固定长度的行\n\nInnoDB：\n\n- 默认情况是COMPACT行格式\n- 对于包含重复数据表 使用 COMPRESSED航格式 占用空间较少\n- 带有TEXT 或 BLOB 使用 DYNAMIC\n\n```sql\nCREATE TABLE tb (...) ROW_FORMAT = xxx;\n```\n\n## 高效加载数据\n\n- LOAD DATA 比 INSERT 效率更高\n- 数据加载时磁盘IO操作越少 效率越高\n\n## 调度 锁定 并发\n\n调度策略：\n\n- 写入优先级比读取优先级高\n- 写入操作一次只能执行一个 写入操作时公平的\n- 可以同时处理多个对同一个表的读取\n\nInnoDB: 行级锁 更精细 并发度更高 \n\nMyISAM: 表级锁 不会出现死锁问题","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}