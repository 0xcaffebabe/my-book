{"content":"# 并发控制\n\n## 封锁\n\n### 封锁粒度\n\n锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高\n封锁粒度越小，系统开销就越大\n\n### 封锁类型\n\n#### 读写锁\n\n- 共享锁：简写为S锁，可读不可写\n- 排它锁：简写为X锁，可读可写\n\n加了排它锁的数据，就只能允许加锁的事务进行读写\n加了共享锁的数据，允许其他事务对其再加共享锁进行读，但不允许再加排它锁\n\n#### 意向锁\n\n意向锁在读写锁的基础上，增加了IX（表的排它锁）与IS（表的共享锁）\n\n- 当一个事务要对数据加S锁之前，就必须获得IS锁或者IX锁\n- 当一个事务要对数据加X锁之前，必须获得IX锁\n\n### 封锁协议\n\n#### 三级封锁协议\n\n- 一级封锁协议\n\n事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁\n\n![批注 2020-03-08 201422](/assets/批注%202020-03-08%20201422.png)\n\n- 二级封锁协议\n\n在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁\n\n![批注 2020-03-08 201650](/assets/批注%202020-03-08%20201650.png)\n\n- 三级封锁协议\n\n在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁\n\n![批注 2020-03-08 201840](/assets/批注%202020-03-08%20201840.png)\n\n#### 两阶段封锁协议\n\n加锁和解锁分为两个阶段进行\n\n- 增长阶段：可以获得锁，不能释放锁\n- 缩减阶段：可以释放锁，不能获得锁\n\nMySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定\n\n- 封锁的实现\n\n- 基于图的协议\n\n# 死锁处理\n\n- 死锁预防\n\n  - 对加锁请求进行排序\n  - 有可能导致死锁时，进行事务回滚\n\n**锁超时**\n\n- 死锁检测与恢复\n\n  - 等待图\n  - 恢复\n\n    - 选择牺牲者\n    - 回滚\n    - 饿死\n\n# 多粒度\n\n# 基于时间戳的协议\n\n- 时间戳\n- 时间戳排序协议\n- Thomas写规则\n\n# 基于有效性检查的协议\n\n# 多版本机制\n\n## 多版本并发控制\n\nMVCC（Multi-Version Concurrency Control） 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系\n\n### undo日志\n\nMVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中\n\n```sql\nINSERT INTO t(id, x) VALUES(1, \"a\");\nUPDATE t SET x=\"b\" WHERE id=1;\nUPDATE t SET x=\"c\" WHERE id=1;\n```\n\n上面的三条sql对应于三个事务\n\n![批注 2020-03-08 203234](/assets/批注%202020-03-08%20203234.png)\n\n### ReadView\n\nMVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表\n\n![批注 2020-03-08 203401](/assets/批注%202020-03-08%20203401.png)\n\n## 多版本时间戳排序\n\n## 多版本两阶封锁\n\n# 快照隔离\n\n# 插入操作、删除操作与谓词读\n\n# 实践中的弱一致性级别\n\n# 索引结构中的并发\n","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}