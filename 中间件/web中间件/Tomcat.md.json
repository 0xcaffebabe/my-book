{"content":"# Tomcat\n\n## 目录结构\n\n![屏幕截图 2020-08-26 141912](/assets/屏幕截图%202020-08-26%20141912.png)\n\n## 部署方式\n\n- 直接将项目放到webapps目录下\n- 配置conf/server.xml文件\n\n  ```\n  在<Host>标签体中配置\n                    <Context docBase=\"D:\\hello\" path=\"/hehe\" />\n                     docBase:项目存放的路径\n                     path：虚拟目录\n  ```\n\n- 在conf\\Catalina\\localhost创建任意名称的xml文件。在文件中编写\n\n  ```\n  <Context docBase=\"D:\\hello\" />\n  ```\n\n  - 虚拟目录：xml文件的名称\n\n**JAVA WEB项目目录结构**\n\n- 项目的根目录\n  - WEB-INF目录：\n    - web.xml：web项目的核心配置文件\n    - classes目录：放置字节码文件的目录\n    - lib目录：放置依赖的jar包\n\n## 架构\n\n整体设计：\n\n![屏幕截图 2020-08-26 143148](/assets/屏幕截图%202020-08-26%20143148.png)\n\n- Connector负责连接的建立以及数据返回\n- Container(Engine)负责请求的具体处理\n- Service 负责维护Conenctor与Container之间的映射关系\n\nContainer设计：\n\n![屏幕截图 2020-08-26 144406](/assets/屏幕截图%202020-08-26%20144406.png)\n\n- Engine：Container的具体实现\n- Host：以域名为主的一个虚拟主机\n- Wrapper：代表Servlet实例\n- Context：代表一个独立的web应用\n- PipeLine：各个组件之间传递消息的管道\n\nConnector设计：\n\n![屏幕截图 2020-08-26 144755](/assets/屏幕截图%202020-08-26%20144755.png)\n\n- Endpoint负责监听连接，将连接交给Processor处理\n- Processor再将请求映射到Container\n\nExecutor：\n\n共享线程池由Service维护\n\n外部依赖 Bootstrap和Catalina：\n\nBootstrap启动Cataina Catalina启动Server 实现了Bootstrap 与 Server进行解耦\n\n### 启动流程\n\n![屏幕截图 2020-08-26 145611](/assets/屏幕截图%202020-08-26%20145611.png)\n\n### 请求处理\n\n![屏幕截图 2020-08-26 145856](/assets/屏幕截图%202020-08-26%20145856.png)\n\n总体流程：\n\n- `CoyoteAdapter.service`\n  - 请求映射：`CoyoteAdapter.postParseRequest`\n  - 调用容器：`connector.getService().getContainer().getPipeline().getFirst().invoke(request, response)`\n\nCatalina请求处理：\n\n![屏幕截图 2020-08-27 145924](/assets/屏幕截图%202020-08-27%20145924.png)\n\n### 类加载器\n\n![屏幕截图 2020-08-26 150126](/assets/屏幕截图%202020-08-26%20150126.png)\n\n通过每个app使用自己的类加载器来达到：\n\n- 隔离：不同的app依赖类库不会相互影响\n- 灵活：重新部署时的问题\n\n对于Web 应用类加载器，它的加载顺序：\n\n- 从缓存加载\n- 如果缓存没有 从JVM的Bootstrap类加载器加载 （防止JAVA SE核心类被覆盖）\n- 如果还是没有 从当前类加载器加载 （如果开启委托 则会遵循JVM双亲委托模型）\n- 还没有 再从父类加载器加载\n\n## Catalina\n\n- Servlet容器\n- Digester : XML解析工具\n\n### Server 创建\n\n- 解析Server：`Catalina.createStartDigester`\n- 解析Engine：`EngineRuleSet.addRuleInstances`\n- 解析Host：`HostRuleSet.addRuleInstances`\n- 解析Context：`ContextRuleSet.addRuleInstances`\n\n### Web应用启动流程\n\n![屏幕截图 2020-08-26 153133](/assets/屏幕截图%202020-08-26%20153133.png)\n\nStandardHost：\n\n- 从server.xml配置加载\n- 或者扫描webapps目录加载\n\nHostConfig：\n\n- START_EVENT事件：会根据context描述文件或者对webapps目录下war包目录等部署应用 调用`deployApps()`\n- PERIODIC_EVENT事件：检查文件是否发生变更 是则重新部署(之前不存在的应用)或者重新加载(之前存在的应用)\n\nStandardContext：\n\n应用初始化及启动\n\nContextConfig：\n\n- AFTER_INIT_EVENT事件：加载Context配置文件\n- BEFORE_START_EVENT事件：处理docBase(应用所在文件夹)问题\n- CONFIGURE_START_EVENT：初始化操作, 解析XML配置文件(或者扫描目录 使用注解的方式) 创建 Servlet Filter等组件\n\nStandardWrapper：\n\n- 根据配置load servlet 以及对 servlet 初始化\n\n### Context的命名与请求路径映射\n\n![屏幕截图 2020-08-26 160757](/assets/屏幕截图%202020-08-26%20160757.png)\n\n### Catalina 自带的 Servlet\n\n- DefaultServlet：处理静态资源 处理目录请求\n  - 可配参数：<https://tomcat.apache.org/tomcat-7.0-doc/default-servlet.html>\n- JspServlet:编译jsp文件 处理jsp请求\n\n## Coyote\n\n- 请求连接器的实现\n\n支持的传输协议：\n\n- HTTP1.1\n- HTTP2.0\n- AJP1.3\n\n支持的IO方案：\n\n- NIO\n- NIO2\n- APR\n\nHTTP 配置：\n\n```xml\n<!-- server.xml -->\n<Connector executor=\"tomcatThreadPool\"\n               port=\"8080\" protocol=\"HTTP/1.1\"\n               connectionTimeout=\"20000\"\n               redirectPort=\"8443\" />\n\n<!-- 使用NIO方式处理HTTP1.1 -->\n<Connector port=\"8443\" protocol=\"org.apache.coyote.http11.Http11NioProtocol\"\n               maxThreads=\"150\" SSLEnabled=\"true\">\n<!-- \n  maxThreads:指定Connector创建请求处理线程的最大数\n  maxSpareThreads：允许空闲线程的最大数\n  minSpareThreads\n  tcpNoDelay：禁止TCP通过批量发送数据来提高网络利用率\n  maxKeepAliveRequest: 最大keepalive的连接数\n  socketBuffer\n  enableLookups：是否开启request.getRemoteHost() DNS查询\n -->\n```\n\n### 概念\n\n- Endpoint 通信端点 负责Socekt接收处理\n- Porcessor 负责创建请求和响应 将请求转发到Catalina\n- ProtocolHandler 封装Endpoint Processor\n- UpgradeProtocol 处理HTTP协议的升级协议\n\n### 请求流程\n\n![屏幕截图 2020-08-27 152428](/assets/屏幕截图%202020-08-27%20152428.png)\n\n### AJP\n\n```xml\n<!-- server.xml -->\n<Connector protocol=\"AJP/1.3\"\n               address=\"::1\"\n               port=\"8009\"\n               redirectPort=\"8443\" />\n```\n\n>AJP（Apache JServ Protocol）是定向包协议。因为性能原因，使用二进制格式来传输可读性文本。WEB服务器通过 TCP连接 和 SERVLET容器连接\n\n包结构：\n\n![屏幕截图 2020-08-27 154533](/assets/屏幕截图%202020-08-27%20154533.png)\n\n有效载荷的前一个字节代表类型\n\n![屏幕截图 2020-08-27 155233](/assets/屏幕截图%202020-08-27%20155233.png)\n\n请求处理：\n\n![屏幕截图 2020-08-27 155429](/assets/屏幕截图%202020-08-27%20155429.png)\n\n## Jasper\n\n使用单独的类加载器\n\n### 编译方式\n\n运行时编译：\n\n![屏幕截图 2020-09-03 144855](/assets/屏幕截图%202020-09-03%20144855.png)\n\n编译结果：\n\n- 首选存放在 context-param 的scratchdir\n- 否则是 $CATALINA_BASE/work/Engine名称/Host名称/Context名称\n- 再否则在系统临时文件目录下\n\n预编译：\n\njspc\n\n### 编译原理\n\n```java\n// 继承该类\nclass index_jsp extends HttpJspBase\n```\n\n```java\nprivate static final JspFactory _jspxFactory = JspFactory.getDefaultFactory();\nprivate static Map<String, Long> _jspx_dependants; // 依赖的外部资源\nprivate static final Set<String> _jspx_imports_packages = new HashSet(); // 导入的包\nprivate static final Set<String> _jspx_imports_classes; // 导入的类\n```\n\n`_jspService` 处理请求：\n\n- 定义了out pageContext session application config page 等局部变量\n- 对于静态内容调用out.write\n- 处理jsp标签\n\n![屏幕截图 2020-09-03 152717](/assets/屏幕截图%202020-09-03%20152717.png)\n\n## 配置管理\n\n### JVM配置\n\n```bat\n:: JVM启动参数\nset \"JAVA_OPTS=%JAVA_OPTS% %JSSE_OPTS%\"\n```\n\n系统属性：略\n\n### 服务器配置\n\ncatalina.properties: 容器启动阶段的配置\n\nserver.xml: 服务器核心配置\n\n- Server\n- Service\n- Executor 线程池配置 默认其他组件会创建自己的线程池\n\n  ```xml\n  <Executor name=\"tomcatThreadPool\" namePrefix=\"catalina-exec-\"\n          maxThreads=\"150\" minSpareThreads=\"4\"/>\n  ```\n- Connector 默认配置了两个 HTTP 和 AJP\n  ```xml\n  <Connector port=\"8080\" -- 监听端口\n  executor=\"sharedThreadPool\" -- 线程池\n  enableLookups=\"false\" -- 调用request.getRemoteHost 是否调用DNS解析获取主机名\n  redirectPort=\"8443\" -- SSL 转发端口\n  acceptCount=\"100\"  -- 控制 socket 排队连接的最大数\n  connectionTimeout=\"2000o\" -- Connector 接收连接处理的超时时间\n  URIEncoding=\"UTF-8\" -- 解码URI的编码\n  compression=\"on\" -- 开启压缩\n  compressionMinSize=\"2048\" -- 最小压缩尺寸\n  noCompressionUserAgents=\"gozilla,traviata\" -- 符合表达式的UA头不压缩\n  compressableMimeType=\"text/html,text/xml,text/javascript,text/css,text/plain\" />\n  ```\n- Engine 可以指定虚拟主机\n- Host\n  - name 域名\n  - appBase 存放应用的目录\n  - unpackWARs 是否解压war包\n  - autoDeploy 定期检测 自动部署\n  - Alias 可以配置新的域名\n- Context\n  - docBase 具体应用的目录\n  - path Context路径\n- CookieProcessor 指定cookie处理器\n- Loader 用于管理 web 应用的类加载器\n  - delegate 属性可以打破双亲委派模型\n  - reloadable 属性会监控资源变化后重新加载应用\n  - loaderClass 指定类加载器的具体实现\n- Manger 会话管理器\n  - Standard和Presistent\n- Resources 资源共享\n  ```xml\n  <Context docBase=\"myApp\" path=\" /myApp\">\n    <Resources>\n      <PreResources\n      className='org.apache.catalina.webresources.FileResourceSet'\n      base=\" /Users/liuguangrui/Documents/sample/app.jsp\"\n      webAppMount=\" /app/app.jsp\"/>\n    </Resources>\n  </Context>\n  ```\n- JarScanner\n- content.xml\n\n### Web 应用配置\n\n- context-param: ServerContext.getInitParameter() 可以获取到的参数\n- session-config 会话配置\n  - 三种追踪模式 COOKIE URL SSL\n- servlet 声明servlet及其映射\n- listener\n- filter\n- mime-mapping 映射文件类型与对应的content-type\n- welcome-file-list\n- error-page\n- locale-encoding-mapping-list 本地化与响应编码的关系\n- 安全配置\n- jndi配置\n\n### 内置的 Filter\n\n- CorsFilter：解决跨域问题\n- CsrfPreventionFilter：防止CSRF攻击\n- ExpiresFilter：控制缓存过期与否\n- FailedRequestFilter：解析参数失败就返回错误\n- RemoteAddrFilter：只放行符合特定表达式的IP地址\n- RemoteHostFilter：只放行符合特定表达式的主机\n- RemoteIpFilter：前方有负载均衡器的情况下 将getRemoteAddr()替换为 X-Forwarded-For 中的IP\n- RequestDumperFilter：以日志形式输出请求和响应对象 主要用于调试\n- SetCharacterEncodingFilter：设置请求编码\n\n### Tomcat 管理\n\n`/host-manager/html`\n\n## 集群\n\n![屏幕截图 2020-09-04 111658](/assets/屏幕截图%202020-09-04%20111658.png)\n\nTomcat 本身就不适合配置集群 一种通用的解决方案是 接入层为 Nginx\n\nNginx 对后端的Tomcat进行负载均衡 \n\nTomcat上的Web应用最好是设计成无状态的 如果仍然需要保持会话 最好使用一台独立的服务器来存储会话 比如 Redis \n\n而不要使用Tomcat的会话同步功能\n\n## 安全\n\n安装部署：下载安全 移除自带的几个Web应用\n\nserver.xml: \n\n- 删除不必要的连接器\n- 删除UserDatabase\n- 修改关键配置：8005管理端口\n- 避免恶意web应用的自动启动：autoDeploy\n- 允许有限的客户端访问\n- 避免将异常堆栈打印到客户端\n- listing会导致目录泄漏以及DoS攻击\n\n应用安全\n\n传输安全(SSL)\n\nJAVA安全策略\n\n## 优化\n\n### JVM 优化\n\n### Tomcat 配置优化\n\nserver.xml:\n\n- 链接器maxConnections 属性：超过该属性的连接会被阻塞\n- tcpNoDelay：禁止TCP缓存并发送\n- maxKeepAliveRequest\n- socketBuffer\n- enableLookups\n\n网络传输优化：\n\n- 静态文件压缩\n- 高性能链接器(NIO NIO2)\n- 禁用自动部署\n\nJSP页面配置(web.xml):\n\n- development 设置为false 不自动检测JSP页面变动\n- ...\n\n继承 web 服务器：\n\n- 动静分离\n- 负载均衡\n\n### 应用优化\n\n- 减少通信次数\n- 减少通信数据流\n- 推迟会话创建\n- 不在会话存储大对象\n- 合理定义对象作用域\n- 使用连接池提高性能\n- 使用缓存提高性能\n- 最小化日志\n\n## 附加功能\n\n- 嵌入式启动\n- websocket","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}