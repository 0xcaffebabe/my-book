{"content":"# MyCat\n\nMyCAT是一款由阿里Cobar演变而来的用于支持数据库，读写分离、分表分库的分布式中间件\nMyCAT原理MyCAT主要是通过对SQL的拦截，然后经过一定规则的分片解析、路由分析、读写分离分析、缓存分析等，然后将SQL发给后端真实的数据块，并将返回的结果做适当处理返回给客户端\n\n## 使用\n\n- server.xml\n\n```xml\n<!-- 读写都可用的用户 -->\n<user name=\"root\" defaultAccount=\"true\">\n    <property name=\"password\">123</property>\n    <property name=\"schemas\">mycat_testdb</property>\n\n    <!-- 表级 DML 权限设置 -->\n    <!--        \n    <privileges check=\"false\">\n        <schema name=\"TESTDB\" dml=\"0110\" >\n            <table name=\"tb01\" dml=\"0000\"></table>\n            <table name=\"tb02\" dml=\"1111\"></table>\n        </schema>\n    </privileges>       \n     -->\n</user>\n\n<!-- 只读用户 -->\n<user name=\"user\">\n    <property name=\"password\">123</property>\n    <property name=\"schemas\">mycat_testdb</property>\n    <property name=\"readOnly\">true</property>\n</user>\n```\n\n- schema.xml\n\n```xml\n    <!-- TESTDB1 是mycat的逻辑库名称，链接需要用的 -->\n    <schema name=\"mycat_testdb\" checkSQLschema=\"false\" sqlMaxLimit=\"100\" dataNode=\"dn1\"></schema>\n        <!-- database 是MySQL数据库的库名 -->\n    <dataNode name=\"dn1\" dataHost=\"localhost1\" database=\"test\" />\n    <!--\n    dataNode节点中各属性说明：\n    name：指定逻辑数据节点名称；\n    dataHost：指定逻辑数据节点物理主机节点名称；\n    database：指定物理主机节点上。如果一个节点上有多个库，可使用表达式db$0-99，     表示指定0-99这100个数据库；\n\n    dataHost 节点中各属性说明：\n        name：物理主机节点名称；\n        maxCon：指定物理主机服务最大支持1000个连接；\n        minCon：指定物理主机服务最小保持10个连接；\n        writeType：指定写入类型；\n            0，只在writeHost节点写入；\n            1，在所有节点都写入。慎重开启，多节点写入顺序为默认写入根据配置顺序，第一个挂掉切换另一个；\n        dbType：指定数据库类型；\n        dbDriver：指定数据库驱动；\n        balance：指定物理主机服务的负载模式。\n            0，不开启读写分离机制；\n            1，全部的readHost与stand by writeHost参与select语句的负载均衡，简单的说，当双主双从模式(M1->S1，M2->S2，并且M1与 M2互为主备)，正常情况下，M2,S1,S2都参与select语句的负载均衡；\n            2，所有的readHost与writeHost都参与select语句的负载均衡，也就是说，当系统的写操作压力不大的情况下，所有主机都可以承担负载均衡；\n-->\n    <dataHost name=\"localhost1\" maxCon=\"1000\" minCon=\"10\" balance=\"3\" writeType=\"0\" dbType=\"mysql\" dbDriver=\"native\" switchType=\"1\"  slaveThreshold=\"100\">\n        <heartbeat>select user()</heartbeat>\n        <!-- 可以配置多个主从 -->\n        <writeHost host=\"hostM1\" url=\"192.168.182.131:3306\" user=\"root\" password=\"123\">\n            <!-- 可以配置多个从库 -->\n            <readHost host=\"hostS2\" url=\"192.168.182.132:3306\" user=\"root\" password=\"123\" />\n        </writeHost>\n    </dataHost>\n```\n\n## 分片枚举\n\n分片枚举算法就是根据不同的枚举(常量)，分类存储。\n\n- schema.xml\n\n```xml\n<schema name=\"mycat_testdb\" checkSQLschema=\"false\" sqlMaxLimit=\"100\" dataNode=\"dn1\">\n \n  <table name=\"order_info\"  dataNode=\"dn1,dn2,dn3\" rule=\"role2\" /> \n\n</schema>\n<!-- database 是MySQL数据库的库名 -->\n<dataNode name=\"dn1\" dataHost=\"localhost1\" database=\"db1\" />\n<dataNode name=\"dn2\" dataHost=\"localhost1\" database=\"db2\" />\n<dataNode name=\"dn3\" dataHost=\"localhost1\" database=\"db3\" />\n```\n\n- rule.xml\n\n```xml\n<tableRule name=\"role2\">\n         <rule>\n              <columns>name</columns>\n            <algorithm>hash-int</algorithm>\n            </rule>\n</tableRule>\n\n<function name=\"hash-int\" class=\"io.mycat.route.function.PartitionByFileMap\">\n\t<property name=\"mapFile\">partition-hash-int.txt</property>\n\t<property name=\"type\">1</property>\n    <!-- 如果mapfile没有满足的条件，则使用节点 -->\n\t<property name=\"defaultNode\">1</property>\n</function>\n```\n\n- partition-hash-int.txt\n\n```text\nwuhan=0\nshanghai=1\nsuzhou=2\n```\n\n## 取模\n\n使用根据ID对节点数量取余，得到存放节点\n这种方式数据库节点一开始就是固定的，如果节点数量发生变更，需要迁移数据rehash\n\n## 查询原理\n\n如果含有分片字段，则根据字段计算出数据所在DB，向DB发送查询请求并返回给客户端\n\n否则向所有DB节点发送查询请求，汇总结果后拼接返回给客户端\n所以如果没有排序，会发现同样的条件查询，会有不同的顺序","commitList":[{"date":"2021-10-08T12:45:10+08:00","author":"cjiping","message":"doc开发期 构建期调整","hash":"704efe7455b7fb2fbd81ec60099191ff982e639a"},{"date":"2021-10-07T19:38:58+08:00","author":"My","message":"init","hash":"4e0456332231ba0523aa526415f9982377358870"}],"hasMoreCommit":false,"totalCommits":0}